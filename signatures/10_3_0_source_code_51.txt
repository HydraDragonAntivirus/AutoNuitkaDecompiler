.Crypto.Cipher.ChaCha20K|B a_raw_chacha20_libahchacha20ac_uint8_ptruError %d when deriving subkey with HChaCha20a_copy_bytesanoncea_HChaCha20:nlnb:lnnaXChaCha20a_nameaChaCha20Taencryptadecrypta_nextaVoidPointera_stateachacha20_initaaddress_ofac_size_tuError %d instantiating a %s cipheraSmartPointeragetachacha20_destroyuInitialize a ChaCha20/XChaCha20 cipher object

        See also `new()` at the module level.aencryptuCipher object can only be used for decryptionTaencrypta_encryptuEncrypt a piece of data.

        Args:
          plaintext(bytes/bytearray/memoryview): The data to encrypt, of any size.
        Keyword Args:
          output(bytes/bytearray/memoryview): The location where the ciphertext
            is written to. If ``None``, the ciphertext is returned.
        Returns:
          If ``output`` is ``None``, the ciphertext is returned as ``bytes``.
          Otherwise, ``None``.
        acreate_string_bufferais_writeable_bufferuoutput must be a bytearray or a writeable memoryviewuoutput must have the same length as the input  (%d bytes)achacha20_encryptaplaintextuError %d while encrypting with %saoutputaget_raw_bufferuEncrypt without FSM checksadecryptuCipher object can only be used for encryptionTadecryptareplaceTaencadecuDecrypt a piece of data.

        Args:
          ciphertext(bytes/bytearray/memoryview): The data to decrypt, of any size.
        Keyword Args:
          output(bytes/bytearray/memoryview): The location where the plaintext
            is written to. If ``None``, the plaintext is returned.
        Returns:
          If ``output`` is ``None``, the plaintext is returned as ``bytes``.
          Otherwise, ``None``.
        l@utoo many values to unpack (expected 2)ql achacha20_seekac_ulonguError %d while seeking with %suSeek to a certain position in the key stream.

        Args:
          position (integer):
            The absolute position within the key stream, in bytes.
        uPoly1305 with ChaCha20 requires a 32-byte keyaget_random_bytesTluPoly1305 with ChaCha20 requires an 8- or 12-byte nonceanewTakeyanonceTb uDerive a tuple (r, s, nonce) for a Poly1305 MAC.

    If nonce is ``None``, a new 12-byte nonce is generated.
    akeyuMissing parameter %sapopTanoncenTluChaCha20/XChaCha20 key must be 32 bytes longTllluNonce must be 8/12 bytes(ChaCha20) or 24 bytes (XChaCha20)uUnknown parameters: aChaCha20CipheruCreate a new ChaCha20 or XChaCha20 cipher

    Keyword Args:
        key (bytes/bytearray/memoryview): The secret key to use.
            It must be 32 bytes long.
        nonce (bytes/bytearray/memoryview): A mandatory value that
            must never be reused for any other encryption
            done with this key.

            For ChaCha20, it must be 8 or 12 bytes long.

            For XChaCha20, it must be 24 bytes long.

            If not provided, 8 bytes will be randomly generated
            (you can find them back in the ``nonce`` attribute).

    :Return: a :class:`Crypto.Cipher.ChaCha20.ChaCha20Cipher` object
    a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.RandomTaget_random_bytesluCrypto.Util.py3compatTa_copy_bytesuCrypto.Util._raw_apiTaload_pycryptodome_raw_libacreate_string_bufferaget_raw_bufferaVoidPointeraSmartPointerac_size_tac_uint8_ptrac_ulongais_writeable_bufferaload_pycryptodome_raw_libTuCrypto.Cipher._chacha20u
                    int chacha20_init(void **pState,
                                      const uint8_t *key,
                                      size_t keySize,
                                      const uint8_t *nonce,
                                      size_t nonceSize);

                    int chacha20_destroy(void *state);

                    int chacha20_encrypt(void *state,
                                         const uint8_t in[],
                                         uint8_t out[],
                                         size_t len);

                    int chacha20_seek(void *state,
                                      unsigned long block_high,
                                      unsigned long block_low,
                                      unsigned offset);
                    int hchacha20(  const uint8_t key[32],
                                    const uint8_t nonce16[16],
                                    uint8_t subkey[32]);
                    TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher.ChaCha20a__module__uChaCha20 (or XChaCha20) cipher object.
    Do not create it directly. Use :py:func:`new` instead.

    :var nonce: The nonce with length 8, 12 or 24 bytes
    :vartype nonce: bytes
    a__qualname__lablock_sizea__init__uChaCha20Cipher.__init__TnuChaCha20Cipher.encryptuChaCha20Cipher._encryptuChaCha20Cipher.decryptaseekuChaCha20Cipher.seeka__orig_bases__a_derive_Poly1305_key_pairakey_sizeuCrypto\Cipher\ChaCha20.pyu<module Crypto.Cipher.ChaCha20>Ta__class__TakeyanonceasubkeyaresultTaselfakeyanoncearesultTakeyanonceapadded_noncearsTaselfaplaintextaoutputaciphertextaresultTaselfaciphertextaoutputweTaselfaplaintextaoutputTakwargsakeyweanonceTaselfapositionaoffsetablock_lowablock_higharesultu.Crypto.Cipher._EKSBlowfish45apopTakeyTasaltTacostuMissing EKSBlowfish parameter: Tainverttakey_sizeuIncorrect EKSBlowfish key length (%d bytes)a_raw_blowfish_libaEKSBlowfish_start_operationaEKSBlowfish_stop_operationaVoidPointerac_uint8_ptrac_size_tac_uintaaddress_ofuError %X while instantiating the EKSBlowfish cipheraSmartPointeragetuThis method instantiates and returns a smart pointer to
    a low-level base cipher. It will absorb named parameters in
    the process.asaltacostainverta_create_cipherasysamodulesuCrypto.Cipher._EKSBlowfishuCreate a new EKSBlowfish cipher

    Args:

      key (bytes, bytearray, memoryview):
        The secret key to use in the symmetric cipher.
        Its length can vary from 0 to 72 bytes.

      mode (one of the supported ``MODE_*`` constants):
        The chaining mode to use for encryption or decryption.

      salt (bytes, bytearray, memoryview):
        The salt that bcrypt uses to thwart rainbow table attacks

      cost (integer):
        The complexity factor in bcrypt

      invert (bool):
        If ``False``, in the inner loop use ``ExpandKey`` first over the salt
        and then over the key, as defined in
        the `original bcrypt specification <https://www.usenix.org/legacy/events/usenix99/provos/provos_html/node4.html>`_.
        If ``True``, reverse the order, as in the first implementation of
        `bcrypt` in OpenBSD.

    :Return: an EKSBlowfish object
    a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.CipherTa_create_cipherluCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointerac_size_tac_uint8_ptrac_uintaload_pycryptodome_raw_libTuCrypto.Cipher._raw_eksblowfishu
        int EKSBlowfish_start_operation(const uint8_t key[],
                                        size_t key_len,
                                        const uint8_t salt[16],
                                        size_t salt_len,
                                        unsigned cost,
                                        unsigned invert,
                                        void **pResult);
        int EKSBlowfish_encrypt(const void *state,
                                const uint8_t *in,
                                uint8_t *out,
                                size_t data_len);
        int EKSBlowfish_decrypt(const void *state,
                                const uint8_t *in,
                                uint8_t *out,
                                size_t data_len);
        int EKSBlowfish_stop_operation(void *state);
        a_create_base_cipheranewlaMODE_ECBlablock_size;llIluCrypto\Cipher\_EKSBlowfish.pyu<module Crypto.Cipher._EKSBlowfish>T
adict_parametersakeyasaltacostweainvertastart_operationastop_operationavoid_paresultTakeyamodeasaltacostainvertakwargsu.Crypto.Cipher._mode_cbc[aVoidPointera_statearaw_cbc_libaCBC_start_operationagetac_uint8_ptrac_size_taaddress_ofuError %d while instantiating the CBC modeaSmartPointeraCBC_stop_operationareleaseablock_sizea_copy_bytesaivaIVaencryptadecrypta_nextuCreate a new block cipher, configured in CBC mode.

        :Parameters:
          block_cipher : C pointer
            A smart pointer to the low-level block cipher instance.

          iv : bytes/bytearray/memoryview
            The initialization vector to use for encryption or decryption.
            It is as long as the cipher block.

            **The IV must be unpredictable**. Ideally it is picked randomly.

            Reusing the *IV* for encryptions performed with the same key
            compromises confidentiality.
        uencrypt() cannot be called after decrypt()acreate_string_bufferais_writeable_bufferuoutput must be a bytearray or a writeable memoryviewuoutput must have the same length as the input  (%d bytes)aCBC_encryptaplaintextluData must be padded to %d byte boundary in CBC modeuError %d while encrypting in CBC modeaoutputaget_raw_bufferuEncrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have encrypted a message
        you cannot encrypt (or decrypt) another message using the same
        object.

        The data to encrypt can be broken up in two or
        more pieces and `encrypt` can be called multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        That also means that you cannot reuse an object for encrypting
        or decrypting other data with the same key.

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
            Its lenght must be multiple of the cipher block size.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
          If ``output`` is ``None``, the ciphertext is returned as ``bytes``.
          Otherwise, ``None``.
        udecrypt() cannot be called after encrypt()aCBC_decryptaciphertextuError %d while decrypting in CBC modeuDecrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        The data to decrypt can be broken up in two or
        more pieces and `decrypt` can be called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            Its length must be multiple of the cipher block size.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return:
          If ``output`` is ``None``, the plaintext is returned as ``bytes``.
          Otherwise, ``None``.
        a_create_base_cipherapopTaIVnTaivnTnnaget_random_bytesuYou must either use 'iv' or 'IV', not bothuIncorrect IV length (it must be %d bytes long)uUnknown parameters for CBC: %saCbcModeuInstantiate a cipher object that performs CBC encryption/decryption.

    :Parameters:
      factory : module
        The underlying block cipher, a module from ``Crypto.Cipher``.

    :Keywords:
      iv : bytes/bytearray/memoryview
        The IV to use for CBC.

      IV : bytes/bytearray/memoryview
        Alias for ``iv``.

    Any other keyword will be passed to the underlying block cipher.
    See the relevant documentation for details (at least ``key`` will need
    to be present).
    u
Ciphertext Block Chaining (CBC) mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__uCrypto.Util.py3compatTa_copy_bytesluCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeracreate_string_bufferaget_raw_bufferaSmartPointerac_size_tac_uint8_ptrais_writeable_bufferaload_pycryptodome_raw_libuCrypto.RandomTaget_random_bytesTuCrypto.Cipher._raw_cbcu
                int CBC_start_operation(void *cipher,
                                        const uint8_t iv[],
                                        size_t iv_len,
                                        void **pResult);
                int CBC_encrypt(void *cbcState,
                                const uint8_t *in,
                                uint8_t *out,
                                size_t data_len);
                int CBC_decrypt(void *cbcState,
                                const uint8_t *in,
                                uint8_t *out,
                                size_t data_len);
                int CBC_stop_operation(void *state);
                TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_cbca__module__u*Cipher-Block Chaining (CBC)*.

    Each of the ciphertext blocks depends on the current
    and all previous plaintext blocks.

    An Initialization Vector (*IV*) is required.

    See `NIST SP800-38A`_ , Section 6.2 .

    .. _`NIST SP800-38A` : http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf

    :undocumented: __init__
    a__qualname__a__init__uCbcMode.__init__TnuCbcMode.encryptuCbcMode.decrypta__orig_bases__a_create_cbc_cipheruCrypto\Cipher\_mode_cbc.pyu<module Crypto.Cipher._mode_cbc>Ta__class__Taselfablock_cipheraivaresultTafactoryakwargsacipher_stateaivaIVTaselfaciphertextaoutputaplaintextaresultTaselfaplaintextaoutputaciphertextaresultu.Crypto.Cipher._mode_ccmf2aEnumTuCrypto.Cipher._mode_ccmablock_sizea_copy_bytesanoncea_factorya_keya_mac_lena_msg_lena_assoc_lena_cipher_paramsa_mac_tagluCCM mode is only available for ciphers that operate on 128 bits blocksTllll
llluParameter 'mac_len' must be even and in the range 4..16 (not %d)uLength of parameter 'nonce' must be in the range 7..13 bytesanewaMODE_CBCDaivba_macaMacStatusaNOT_STARTEDa_mac_statusa_tLaupdateaencryptadecryptadigestaverifya_nextla_cumul_assoc_lena_cumul_msg_lena_cacheaMODE_CTRastructapackwBa_cipheraencryptTba_s_0a_start_macl@llalong_to_bytesclqclcainsertlaPROCESSING_AUTH_DATAa_updatedaupdateuupdate() can only be called immediately after initializationuAssociated data is too longuProtect associated data

        If there is any associated data, the caller has to invoke
        this function one or more times, before using
        ``decrypt`` or ``encrypt``.

        By *associated data* it is meant any data (e.g. packet headers) that
        will not be encrypted and will be transmitted in the clear.
        However, the receiver is still able to detect any modification to it.
        In CCM, the *associated data* is also called
        *additional authenticated data* (AAD).

        If there is no associated data, this method must not be called.

        The caller may split associated data in segments of any size, and
        invoke this method multiple times, each time with the next segment.

        :Parameters:
          assoc_data : bytes/bytearray/memoryview
            A piece of associated data. There are no restrictions on its size.
        ais_writeable_bufferaappendaassoc_data_ptamin:lnnuUpdate the MAC with associated data or plaintext
           (without FSM checks)uencrypt() can only be called after initialization or an update()adigestuAssociated data is too shortaplaintextuMessage is too longa_pad_cache_and_updateaPROCESSING_PLAINTEXTTaoutputuEncrypt data with the key set at initialization.

        A cipher object is stateful: once you have encrypted a message
        you cannot encrypt (or decrypt) another message using the same
        object.

        This method can be called only **once** if ``msg_len`` was
        not passed at initialization.

        If ``msg_len`` was given, the data to encrypt can be broken
        up in two or more pieces and `encrypt` can be called
        multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
          If ``output`` is ``None``, the ciphertext as ``bytes``.
          Otherwise, ``None``.
        adecryptudecrypt() can only be called after initialization or an update()averifyaciphertextuDecrypt data with the key set at initialization.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        This method can be called only **once** if ``msg_len`` was
        not passed at initialization.

        If ``msg_len`` was given, the data to decrypt can be
        broken up in two or more pieces and `decrypt` can be
        called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return:
          If ``output`` is ``None``, the plaintext as ``bytes``.
          Otherwise, ``None``.
        udigest() cannot be called when decrypting or validating a messagea_digestuCompute the *binary* MAC tag.

        The caller invokes this function at the very end.

        This method returns the MAC that shall be sent to the receiver,
        together with the ciphertext.

        :Return: the MAC, as a byte string.
        uMessage is too shortastrxoruu%02xaborduCompute the *printable* MAC tag.

        This method is like `digest`.

        :Return: the MAC, as a hexadecimal string.
        uverify() cannot be called when encrypting a messageaget_random_bytesTlaBLAKE2slTadigest_bitsakeyadatauMAC check faileduValidate the *binary* MAC tag.

        The caller invokes this function at the very end.

        This method checks if the decrypted message is indeed valid
        (that is, if the key is correct) and it has not been
        tampered with while in transit.

        :Parameters:
          received_mac_tag : bytes/bytearray/memoryview
            This is the *binary* MAC, as received from the sender.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        aunhexlifyuValidate the *printable* MAC tag.

        This method is like `verify`.

        :Parameters:
          hex_mac_tag : string
            This is the *printable* MAC, as received from the sender.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        uPerform encrypt() and digest() in one step.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
            a tuple with two items:

            - the ciphertext, as ``bytes``
            - the MAC tag, as ``bytes``

            The first item becomes ``None`` when the ``output`` parameter
            specified a location for the result.
        uPerform decrypt() and verify() in one step.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
          received_mac_tag : bytes/bytearray/memoryview
            This is the *binary* MAC, as received from the sender.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return: the plaintext as ``bytes`` or ``None`` when the ``output``
            parameter specified a location for the result.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        akeyuMissing parameter: apopTanoncenTlamac_lenTamsg_lennTaassoc_lennaCcmModeuCreate a new block cipher, configured in CCM mode.

    :Parameters:
      factory : module
        A symmetric cipher module from `Crypto.Cipher` (like
        `Crypto.Cipher.AES`).

    :Keywords:
      key : bytes/bytearray/memoryview
        The secret key to use in the symmetric cipher.

      nonce : bytes/bytearray/memoryview
        A value that must never be reused for any other encryption.

        Its length must be in the range ``[7..13]``.
        11 or 12 bytes are reasonable values in general. Bear in
        mind that with CCM there is a trade-off between nonce length and
        maximum message size.

        If not specified, a 11 byte long random string is used.

      mac_len : integer
        Length of the MAC, in bytes. It must be even and in
        the range ``[4..16]``. The default is 16.

      msg_len : integer
        Length of the message to (de)cipher.
        If not specified, ``encrypt`` or ``decrypt`` may only be called once.

      assoc_len : integer
        Length of the associated data.
        If not specified, all data is internally buffered.
    u
Counter with CBC-MAC (CCM) mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__abinasciiTaunhexlifyuCrypto.Util.py3compatTabyte_stringaborda_copy_bytesabyte_stringuCrypto.Util._raw_apiTais_writeable_bufferuCrypto.Util.strxorTastrxoruCrypto.Util.numberTalong_to_bytesuCrypto.HashTaBLAKE2suCrypto.RandomTaget_random_bytesaenumTlllTaNOT_STARTEDaPROCESSING_AUTH_DATAaPROCESSING_PLAINTEXTTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>a__module__uCounter with CBC-MAC (CCM).

    This is an Authenticated Encryption with Associated Data (`AEAD`_) mode.
    It provides both confidentiality and authenticity.

    The header of the message may be left in the clear, if needed, and it will
    still be subject to authentication. The decryption step tells the receiver
    if the message comes from a source that really knowns the secret key.
    Additionally, decryption detects if any part of the message - including the
    header - has been modified or corrupted.

    This mode requires a nonce. The nonce shall never repeat for two
    different messages encrypted with the same key, but it does not need
    to be random.
    Note that there is a trade-off between the size of the nonce and the
    maximum size of a single message you can encrypt.

    It is important to use a large nonce if the key is reused across several
    messages and the nonce is chosen randomly.

    It is acceptable to us a short nonce if the key is only used a few times or
    if the nonce is taken from a counter.

    The following table shows the trade-off when the nonce is chosen at
    random. The column on the left shows how many messages it takes
    for the keystream to repeat **on average**. In practice, you will want to
    stop using the key way before that.

    +--------------------+---------------+-------------------+
    | Avg. # of messages |    nonce      |     Max. message  |
    | before keystream   |    size       |     size          |
    | repeats            |    (bytes)    |     (bytes)       |
    +====================+===============+===================+
    |       2^52         |      13       |        64K        |
    +--------------------+---------------+-------------------+
    |       2^48         |      12       |        16M        |
    +--------------------+---------------+-------------------+
    |       2^44         |      11       |         4G        |
    +--------------------+---------------+-------------------+
    |       2^40         |      10       |         1T        |
    +--------------------+---------------+-------------------+
    |       2^36         |       9       |        64P        |
    +--------------------+---------------+-------------------+
    |       2^32         |       8       |        16E        |
    +--------------------+---------------+-------------------+

    This mode is only available for ciphers that operate on 128 bits blocks
    (e.g. AES but not TDES).

    See `NIST SP800-38C`_ or RFC3610_.

    .. _`NIST SP800-38C`: http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C.pdf
    .. _RFC3610: https://tools.ietf.org/html/rfc3610
    .. _AEAD: http://blog.cryptographyengineering.com/2012/05/how-to-choose-authenticated-encryption.html

    :undocumented: __init__
    a__qualname__a__init__uCcmMode.__init__uCcmMode._start_macuCcmMode._pad_cache_and_updateuCcmMode.updateTcuCcmMode._updateTnuCcmMode.encryptuCcmMode.decryptuCcmMode.digestuCcmMode._digestahexdigestuCcmMode.hexdigestuCcmMode.verifyahexverifyuCcmMode.hexverifyaencrypt_and_digestuCcmMode.encrypt_and_digestadecrypt_and_verifyuCcmMode.decrypt_and_verifya__orig_bases__a_create_ccm_cipheruCrypto\Cipher\_mode_ccm.pyu<module Crypto.Cipher._mode_ccm>Ta__class__Taselfafactoryakeyanonceamac_lenamsg_lenaassoc_lenacipher_paramswqTafactoryakwargsakeyweanonceamac_lenamsg_lenaassoc_lenacipher_paramsTaselfTaselfalen_cacheTaselfwqaflagsab_0aassoc_len_encodedaenc_sizeafirst_data_to_macTaselfaassoc_data_ptafilleraupdate_lenTaselfaciphertextaoutputaplaintextTaselfaciphertextareceived_mac_tagaoutputaplaintextTaselfaplaintextaoutputTaenumsTaselfahex_mac_tagTaselfaassoc_dataTaselfareceived_mac_tagasecretamac1amac2.Crypto.Cipher._mode_cfbv]aVoidPointera_statearaw_cfb_libaCFB_start_operationagetac_uint8_ptrac_size_taaddress_ofuError %d while instantiating the CFB modeaSmartPointeraCFB_stop_operationareleaseablock_sizea_copy_bytesaivaIVaencryptadecrypta_nextuCreate a new block cipher, configured in CFB mode.

        :Parameters:
          block_cipher : C pointer
            A smart pointer to the low-level block cipher instance.

          iv : bytes/bytearray/memoryview
            The initialization vector to use for encryption or decryption.
            It is as long as the cipher block.

            **The IV must be unpredictable**. Ideally it is picked randomly.

            Reusing the *IV* for encryptions performed with the same key
            compromises confidentiality.

          segment_size : integer
            The number of bytes the plaintext and ciphertext are segmented in.
        uencrypt() cannot be called after decrypt()acreate_string_bufferais_writeable_bufferuoutput must be a bytearray or a writeable memoryviewuoutput must have the same length as the input  (%d bytes)aCFB_encryptaplaintextuError %d while encrypting in CFB modeaoutputaget_raw_bufferuEncrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have encrypted a message
        you cannot encrypt (or decrypt) another message using the same
        object.

        The data to encrypt can be broken up in two or
        more pieces and `encrypt` can be called multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
          If ``output`` is ``None``, the ciphertext is returned as ``bytes``.
          Otherwise, ``None``.
        udecrypt() cannot be called after encrypt()aCFB_decryptaciphertextuError %d while decrypting in CFB modeuDecrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        The data to decrypt can be broken up in two or
        more pieces and `decrypt` can be called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return:
          If ``output`` is ``None``, the plaintext is returned as ``bytes``.
          Otherwise, ``None``.
        a_create_base_cipherapopTaIVnTaivnTnnaget_random_bytesuYou must either use 'iv' or 'IV', not bothuIncorrect IV length (it must be %d bytes long)Tasegment_sizellutoo many values to unpack (expected 2)lu'segment_size' must be positive and multiple of 8 bitsuUnknown parameters for CFB: %saCfbModeuInstantiate a cipher object that performs CFB encryption/decryption.

    :Parameters:
      factory : module
        The underlying block cipher, a module from ``Crypto.Cipher``.

    :Keywords:
      iv : bytes/bytearray/memoryview
        The IV to use for CFB.

      IV : bytes/bytearray/memoryview
        Alias for ``iv``.

      segment_size : integer
        The number of bit the plaintext and ciphertext are segmented in.
        If not present, the default is 8.

    Any other keyword will be passed to the underlying block cipher.
    See the relevant documentation for details (at least ``key`` will need
    to be present).
    u
Counter Feedback (CFB) mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__uCrypto.Util.py3compatTa_copy_bytesuCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeracreate_string_bufferaget_raw_bufferaSmartPointerac_size_tac_uint8_ptrais_writeable_bufferaload_pycryptodome_raw_libuCrypto.RandomTaget_random_bytesTuCrypto.Cipher._raw_cfbu
                    int CFB_start_operation(void *cipher,
                                            const uint8_t iv[],
                                            size_t iv_len,
                                            size_t segment_len, /* In bytes */
                                            void **pResult);
                    int CFB_encrypt(void *cfbState,
                                    const uint8_t *in,
                                    uint8_t *out,
                                    size_t data_len);
                    int CFB_decrypt(void *cfbState,
                                    const uint8_t *in,
                                    uint8_t *out,
                                    size_t data_len);
                    int CFB_stop_operation(void *state);TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_cfba__module__u*Cipher FeedBack (CFB)*.

    This mode is similar to CFB, but it transforms
    the underlying block cipher into a stream cipher.

    Plaintext and ciphertext are processed in *segments*
    of **s** bits. The mode is therefore sometimes
    labelled **s**-bit CFB.

    An Initialization Vector (*IV*) is required.

    See `NIST SP800-38A`_ , Section 6.3.

    .. _`NIST SP800-38A` : http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf

    :undocumented: __init__
    a__qualname__a__init__uCfbMode.__init__TnuCfbMode.encryptuCfbMode.decrypta__orig_bases__a_create_cfb_cipheruCrypto\Cipher\_mode_cfb.pyu<module Crypto.Cipher._mode_cfb>Ta__class__Taselfablock_cipheraivasegment_sizearesultTafactoryakwargsacipher_stateaivaIVasegment_size_bytesaremTaselfaciphertextaoutputaplaintextaresultTaselfaplaintextaoutputaciphertextaresultu.Crypto.Cipher._mode_ctr#xa_copy_bytesanonceaVoidPointeraselfa_statearaw_ctr_libaCTR_start_operationagetac_uint8_ptrac_size_taaddress_ofuError %X while instantiating the CTR modeaSmartPointeraCTR_stop_operationareleaseablock_sizeaencryptadecrypta_nextuCreate a new block cipher, configured in CTR mode.

        :Parameters:
          block_cipher : C pointer
            A smart pointer to the low-level block cipher instance.

          initial_counter_block : bytes/bytearray/memoryview
            The initial plaintext to use to generate the key stream.

            It is as large as the cipher block, and it embeds
            the initial value of the counter.

            This value must not be reused.
            It shall contain a nonce or a random component.
            Reusing the *initial counter block* for encryptions
            performed with the same key compromises confidentiality.

          prefix_len : integer
            The amount of bytes at the beginning of the counter block
            that never change.

          counter_len : integer
            The length in bytes of the counter embedded in the counter
            block.

          little_endian : boolean
            True if the counter in the counter block is an integer encoded
            in little endian mode. If False, it is big endian.
        uencrypt() cannot be called after decrypt()acreate_string_bufferais_writeable_bufferuoutput must be a bytearray or a writeable memoryviewuoutput must have the same length as the input  (%d bytes)aCTR_encryptaplaintextluThe counter has wrapped around in CTR modeuError %X while encrypting in CTR modeaoutputaget_raw_bufferuEncrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have encrypted a message
        you cannot encrypt (or decrypt) another message using the same
        object.

        The data to encrypt can be broken up in two or
        more pieces and `encrypt` can be called multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
          If ``output`` is ``None``, the ciphertext is returned as ``bytes``.
          Otherwise, ``None``.
        udecrypt() cannot be called after encrypt()aCTR_decryptaciphertextuError %X while decrypting in CTR modeuDecrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        The data to decrypt can be broken up in two or
        more pieces and `decrypt` can be called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return:
          If ``output`` is ``None``, the plaintext is returned as ``bytes``.
          Otherwise, ``None``.
        a_create_base_cipherapopTacounternTanoncenTainitial_valuenuInvalid parameters for CTR mode: %sTnnu'counter' and 'nonce'/'initial_value' are mutually exclusiveluImpossible to create a safe nonce for short block sizesaget_random_bytesluNonce is too longlais_native_intlluInitial counter value is too largealong_to_bytesuIncorrect length for counter byte string (%d bytes, expected %d)aCtrModeacounter_lenaprefixasuffixainitial_valuealittle_endianuIncorrect counter object (use Crypto.Util.Counter.new)awordsaappendastructapackwBldamaxareversecuSize of the counter block (%d bytes) must match block size (%d)uInstantiate a cipher object that performs CTR encryption/decryption.

    :Parameters:
      factory : module
        The underlying block cipher, a module from ``Crypto.Cipher``.

    :Keywords:
      nonce : bytes/bytearray/memoryview
        The fixed part at the beginning of the counter block - the rest is
        the counter number that gets increased when processing the next block.
        The nonce must be such that no two messages are encrypted under the
        same key and the same nonce.

        The nonce must be shorter than the block size (it can have
        zero length; the counter is then as long as the block).

        If this parameter is not present, a random nonce will be created with
        length equal to half the block size. No random nonce shorter than
        64 bits will be created though - you must really think through all
        security consequences of using such a short block size.

      initial_value : posive integer or bytes/bytearray/memoryview
        The initial value for the counter. If not present, the cipher will
        start counting from 0. The value is incremented by one for each block.
        The counter number is encoded in big endian mode.

      counter : object
        Instance of ``Crypto.Util.Counter``, which allows full customization
        of the counter block. This parameter is incompatible to both ``nonce``
        and ``initial_value``.

    Any other keyword will be passed to the underlying block cipher.
    See the relevant documentation for details (at least ``key`` will need
    to be present).
    u
Counter (CTR) mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__uCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeracreate_string_bufferaget_raw_bufferaSmartPointerac_size_tac_uint8_ptrais_writeable_bufferaload_pycryptodome_raw_libuCrypto.RandomTaget_random_bytesuCrypto.Util.py3compatTa_copy_bytesais_native_intuCrypto.Util.numberTalong_to_bytesTuCrypto.Cipher._raw_ctru
                    int CTR_start_operation(void *cipher,
                                            uint8_t   initialCounterBlock[],
                                            size_t    initialCounterBlock_len,
                                            size_t    prefix_len,
                                            unsigned  counter_len,
                                            unsigned  littleEndian,
                                            void **pResult);
                    int CTR_encrypt(void *ctrState,
                                    const uint8_t *in,
                                    uint8_t *out,
                                    size_t data_len);
                    int CTR_decrypt(void *ctrState,
                                    const uint8_t *in,
                                    uint8_t *out,
                                    size_t data_len);
                    int CTR_stop_operation(void *ctrState);TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_ctra__module__u*CounTeR (CTR)* mode.

    This mode is very similar to ECB, in that
    encryption of one block is done independently of all other blocks.

    Unlike ECB, the block *position* contributes to the encryption
    and no information leaks about symbol frequency.

    Each message block is associated to a *counter* which
    must be unique across all messages that get encrypted
    with the same key (not just within the same message).
    The counter is as big as the block size.

    Counters can be generated in several ways. The most
    straightword one is to choose an *initial counter block*
    (which can be made public, similarly to the *IV* for the
    other modes) and increment its lowest **m** bits by one
    (modulo *2^m*) for each block. In most cases, **m** is
    chosen to be half the block size.

    See `NIST SP800-38A`_, Section 6.5 (for the mode) and
    Appendix B (for how to manage the *initial counter block*).

    .. _`NIST SP800-38A` : http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf

    :undocumented: __init__
    a__qualname__a__init__uCtrMode.__init__TnuCtrMode.encryptuCtrMode.decrypta__orig_bases__a_create_ctr_cipheruCrypto\Cipher\_mode_ctr.pyu<module Crypto.Cipher._mode_ctr>Ta__class__Taselfablock_cipherainitial_counter_blockaprefix_lenacounter_lenalittle_endianaresultT
afactoryakwargsacipher_stateacounteranonceainitial_valueacounter_lenainitial_counter_blocka_counteraprefixasuffixalittle_endianawordsTaselfaciphertextaoutputaplaintextaresultTaselfaplaintextaoutputaciphertextaresultu.Crypto.Cipher._mode_eaxp%ablock_sizea_copy_bytesanoncea_mac_lena_mac_tagLaupdateaencryptadecryptadigestaverifya_nextlu'mac_len' must be at least 2 and not larger than %duNonce cannot be empty in EAX modeais_bufferunonce must be bytes, bytearray or memoryview;lllaCMACanewakeydaselflastructapackwBafactoryacipher_paramsTaciphermodacipher_paramsa_omaclaupdatea_signerabytes_to_longadigestaMODE_CTRainitial_valueca_cipheruEAX cipher modeuupdate() can only be called immediately after initializationuProtect associated data

        If there is any associated data, the caller has to invoke
        this function one or more times, before using
        ``decrypt`` or ``encrypt``.

        By *associated data* it is meant any data (e.g. packet headers) that
        will not be encrypted and will be transmitted in the clear.
        However, the receiver is still able to detect any modification to it.

        If there is no associated data, this method must not be called.

        The caller may split associated data in segments of any size, and
        invoke this method multiple times, each time with the next segment.

        :Parameters:
          assoc_data : bytes/bytearray/memoryview
            A piece of associated data. There are no restrictions on its size.
        aencryptuencrypt() can only be called after initialization or an update()TaoutputuEncrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have encrypted a message
        you cannot encrypt (or decrypt) another message using the same
        object.

        The data to encrypt can be broken up in two or
        more pieces and `encrypt` can be called multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
          If ``output`` is ``None``, the ciphertext as ``bytes``.
          Otherwise, ``None``.
        adecryptudecrypt() can only be called after initialization or an update()averifyuDecrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        The data to decrypt can be broken up in two or
        more pieces and `decrypt` can be called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return:
          If ``output`` is ``None``, the plaintext as ``bytes``.
          Otherwise, ``None``.
        udigest() cannot be called when decrypting or validating a messageastrxorataguCompute the *binary* MAC tag.

        The caller invokes this function at the very end.

        This method returns the MAC that shall be sent to the receiver,
        together with the ciphertext.

        :Return: the MAC, as a byte string.
        uu%02xaborduCompute the *printable* MAC tag.

        This method is like `digest`.

        :Return: the MAC, as a hexadecimal string.
        uverify() cannot be called when encrypting a messageaget_random_bytesTlaBLAKE2slTadigest_bitsakeyadatauMAC check faileduValidate the *binary* MAC tag.

        The caller invokes this function at the very end.

        This method checks if the decrypted message is indeed valid
        (that is, if the key is correct) and it has not been
        tampered with while in transit.

        :Parameters:
          received_mac_tag : bytes/bytearray/memoryview
            This is the *binary* MAC, as received from the sender.
        :Raises MacMismatchError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        aunhexlifyuValidate the *printable* MAC tag.

        This method is like `verify`.

        :Parameters:
          hex_mac_tag : string
            This is the *printable* MAC, as received from the sender.
        :Raises MacMismatchError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        uPerform encrypt() and digest() in one step.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
            a tuple with two items:

            - the ciphertext, as ``bytes``
            - the MAC tag, as ``bytes``

            The first item becomes ``None`` when the ``output`` parameter
            specified a location for the result.
        uPerform decrypt() and verify() in one step.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
          received_mac_tag : bytes/bytearray/memoryview
            This is the *binary* MAC, as received from the sender.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return: the plaintext as ``bytes`` or ``None`` when the ``output``
            parameter specified a location for the result.
        :Raises MacMismatchError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        apopTanoncenamac_lenuMissing parameter: aEaxModeuCreate a new block cipher, configured in EAX mode.

    :Parameters:
      factory : module
        A symmetric cipher module from `Crypto.Cipher` (like
        `Crypto.Cipher.AES`).

    :Keywords:
      key : bytes/bytearray/memoryview
        The secret key to use in the symmetric cipher.

      nonce : bytes/bytearray/memoryview
        A value that must never be reused for any other encryption.
        There are no restrictions on its length, but it is recommended to use
        at least 16 bytes.

        The nonce shall never repeat for two different messages encrypted with
        the same key, but it does not need to be random.

        If not specified, a 16 byte long random string is used.

      mac_len : integer
        Length of the MAC, in bytes. It must be no larger than the cipher
        block bytes (which is the default).
    u
EAX mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__abinasciiTaunhexlifyuCrypto.Util.py3compatTabyte_stringaborda_copy_bytesabyte_stringuCrypto.Util._raw_apiTais_bufferuCrypto.Util.strxorTastrxoruCrypto.Util.numberTalong_to_bytesabytes_to_longalong_to_bytesuCrypto.HashTaCMACaBLAKE2suCrypto.RandomTaget_random_bytesTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_eaxa__module__u*EAX* mode.

    This is an Authenticated Encryption with Associated Data
    (`AEAD`_) mode. It provides both confidentiality and authenticity.

    The header of the message may be left in the clear, if needed,
    and it will still be subject to authentication.

    The decryption step tells the receiver if the message comes
    from a source that really knowns the secret key.
    Additionally, decryption detects if any part of the message -
    including the header - has been modified or corrupted.

    This mode requires a *nonce*.

    This mode is only available for ciphers that operate on 64 or
    128 bits blocks.

    There are no official standards defining EAX.
    The implementation is based on `a proposal`__ that
    was presented to NIST.

    .. _AEAD: http://blog.cryptographyengineering.com/2012/05/how-to-choose-authenticated-encryption.html
    .. __: http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/eax/eax-spec.pdf

    :undocumented: __init__
    a__qualname__a__init__uEaxMode.__init__uEaxMode.updateTnuEaxMode.encryptuEaxMode.decryptuEaxMode.digestahexdigestuEaxMode.hexdigestuEaxMode.verifyahexverifyuEaxMode.hexverifyaencrypt_and_digestuEaxMode.encrypt_and_digestadecrypt_and_verifyuEaxMode.decrypt_and_verifya__orig_bases__a_create_eax_cipheruCrypto\Cipher\_mode_eax.pyu<module Crypto.Cipher._mode_eax>Ta__class__Taselfafactoryakeyanonceamac_lenacipher_paramsacounter_intTafactoryakwargsakeyanonceamac_lenweTaselfaciphertextaoutputTaselfaciphertextareceived_mac_tagaoutputaptTaselfatagwiTaselfaplaintextaoutputactTaselfaplaintextaoutputTaselfTaselfahex_mac_tagTaselfaassoc_dataTaselfareceived_mac_tagatagwiasecretamac1amac2.Crypto.Cipher._mode_ecbJablock_sizeaVoidPointera_statearaw_ecb_libaECB_start_operationagetaaddress_ofuError %d while instantiating the ECB modeaSmartPointeraECB_stop_operationareleaseuCreate a new block cipher, configured in ECB mode.

        :Parameters:
          block_cipher : C pointer
            A smart pointer to the low-level block cipher instance.
        acreate_string_bufferais_writeable_bufferuoutput must be a bytearray or a writeable memoryviewuoutput must have the same length as the input  (%d bytes)aECB_encryptac_uint8_ptraplaintextac_size_tluData must be aligned to block boundary in ECB modeuError %d while encrypting in ECB modeaoutputaget_raw_bufferuEncrypt data with the key set at initialization.

        The data to encrypt can be broken up in two or
        more pieces and `encrypt` can be called multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
            The length must be multiple of the cipher block length.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
          If ``output`` is ``None``, the ciphertext is returned as ``bytes``.
          Otherwise, ``None``.
        aECB_decryptaciphertextuError %d while decrypting in ECB modeuDecrypt data with the key set at initialization.

        The data to decrypt can be broken up in two or
        more pieces and `decrypt` can be called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            The length must be multiple of the cipher block length.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return:
          If ``output`` is ``None``, the plaintext is returned as ``bytes``.
          Otherwise, ``None``.
        a_create_base_cipheruUnknown parameters for ECB: %saEcbModeuInstantiate a cipher object that performs ECB encryption/decryption.

    :Parameters:
      factory : module
        The underlying block cipher, a module from ``Crypto.Cipher``.

    All keywords are passed to the underlying block cipher.
    See the relevant documentation for details (at least ``key`` will need
    to be presentu
Electronic Code Book (ECB) mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__uCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeracreate_string_bufferaget_raw_bufferaSmartPointerac_size_tac_uint8_ptrais_writeable_bufferlaload_pycryptodome_raw_libTuCrypto.Cipher._raw_ecbu
                    int ECB_start_operation(void *cipher,
                                            void **pResult);
                    int ECB_encrypt(void *ecbState,
                                    const uint8_t *in,
                                    uint8_t *out,
                                    size_t data_len);
                    int ECB_decrypt(void *ecbState,
                                    const uint8_t *in,
                                    uint8_t *out,
                                    size_t data_len);
                    int ECB_stop_operation(void *state);
                    TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_ecba__module__u*Electronic Code Book (ECB)*.

    This is the simplest encryption mode. Each of the plaintext blocks
    is directly encrypted into a ciphertext block, independently of
    any other block.

    This mode is dangerous because it exposes frequency of symbols
    in your plaintext. Other modes (e.g. *CBC*) should be used instead.

    See `NIST SP800-38A`_ , Section 6.1.

    .. _`NIST SP800-38A` : http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf

    :undocumented: __init__
    a__qualname__a__init__uEcbMode.__init__TnaencryptuEcbMode.encryptadecryptuEcbMode.decrypta__orig_bases__a_create_ecb_cipheruCrypto\Cipher\_mode_ecb.pyu<module Crypto.Cipher._mode_ecb>Ta__class__Taselfablock_cipheraresultTafactoryakwargsacipher_stateTaselfaciphertextaoutputaplaintextaresultTaselfaplaintextaoutputaciphertextaresultu.Crypto.Cipher._mode_gcmL/acollectionsTanamedtuplelanamedtupleTa_GHash_ImpTaghashaghash_expandaghash_destroyTaghashaghash_expandaghash_destroyw_apostfixa_ghash_api_templateareplaceTu%imp%aportableaload_pycryptodome_raw_libuCrypto.Hash._ghash_portablea_build_implaportablea_cpu_featuresahave_clmulTu%imp%aclmuluCrypto.Hash._ghash_clmulaclmuluReturn None if CLMUL implementation is not availableaghash_caVoidPointera_exp_keyaghash_expandac_uint8_ptraaddress_ofuError %d while expanding the GHASH keyaSmartPointeragetaghash_destroyacreate_string_bufferTla_last_ylaghashac_size_tuError %d while updating GHASHaget_raw_bufferaEnumTuCrypto.Cipher._mode_gcmablock_sizeuGCM mode is only available for ciphers that operate on 128 bits blocksuNonce cannot be emptyais_bufferuNonce must be bytes, bytearray or memoryviewg+uNonce exceeds maximum lengtha_copy_bytesanoncea_factorya_keya_taga_mac_lenluParameter 'mac_len' must be in the range 4..16Laupdateaencryptadecryptadigestaverifya_nexta_no_more_assoc_dataa_auth_lena_msg_lenanewaMODE_ECBaencryptTbbdalong_to_bytesla_GHASHaupdateadigest:nlnabytes_to_longlqaMODE_CTRainitial_valuea_cipherahash_subkeya_signerca_tag_ciphera_cacheaMacStatusaPROCESSING_AUTH_DATAa_statusuupdate() can only be called immediately after initializationa_updateuAdditional Authenticated Data exceeds maximum lengthuProtect associated data

        If there is any associated data, the caller has to invoke
        this function one or more times, before using
        ``decrypt`` or ``encrypt``.

        By *associated data* it is meant any data (e.g. packet headers) that
        will not be encrypted and will be transmitted in the clear.
        However, the receiver is still able to detect any modification to it.
        In GCM, the *associated data* is also called
        *additional authenticated data* (AAD).

        If there is no associated data, this method must not be called.

        The caller may split associated data in segments of any size, and
        invoke this method multiple times, each time with the next segment.

        :Parameters:
          assoc_data : bytes/bytearray/memoryview
            A piece of associated data. There are no restrictions on its size.
        aminuencrypt() can only be called after initialization or an update()Taoutputa_pad_cache_and_updateaPROCESSING_CIPHERTEXTquPlaintext exceeds maximum lengthuEncrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have encrypted a message
        you cannot encrypt (or decrypt) another message using the same
        object.

        The data to encrypt can be broken up in two or
        more pieces and `encrypt` can be called multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
          If ``output`` is ``None``, the ciphertext as ``bytes``.
          Otherwise, ``None``.
        adecryptudecrypt() can only be called after initialization or an update()averifyuDecrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        The data to decrypt can be broken up in two or
        more pieces and `decrypt` can be called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return:
          If ``output`` is ``None``, the plaintext as ``bytes``.
          Otherwise, ``None``.
        udigest() cannot be called when decrypting or validating a messagea_compute_macuCompute the *binary* MAC tag in an AEAD mode.

        The caller invokes this function at the very end.

        This method returns the MAC that shall be sent to the receiver,
        together with the ciphertext.

        :Return: the MAC, as a byte string.
        uCompute MAC without any FSM checks.uu%02xaborduCompute the *printable* MAC tag.

        This method is like `digest`.

        :Return: the MAC, as a hexadecimal string.
        uverify() cannot be called when encrypting a messageaget_random_bytesaBLAKE2slTadigest_bitsakeyadatauMAC check faileduValidate the *binary* MAC tag.

        The caller invokes this function at the very end.

        This method checks if the decrypted message is indeed valid
        (that is, if the key is correct) and it has not been
        tampered with while in transit.

        :Parameters:
          received_mac_tag : bytes/bytearray/memoryview
            This is the *binary* MAC, as received from the sender.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        aunhexlifyuValidate the *printable* MAC tag.

        This method is like `verify`.

        :Parameters:
          hex_mac_tag : string
            This is the *printable* MAC, as received from the sender.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        uPerform encrypt() and digest() in one step.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
            a tuple with two items:

            - the ciphertext, as ``bytes``
            - the MAC tag, as ``bytes``

            The first item becomes ``None`` when the ``output`` parameter
            specified a location for the result.
        uPerform decrypt() and verify() in one step.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
          received_mac_tag : byte string
            This is the *binary* MAC, as received from the sender.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return: the plaintext as ``bytes`` or ``None`` when the ``output``
            parameter specified a location for the result.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        akeyuMissing parameter:apopTanoncenTamac_lenlTause_clmulta_ghash_clmula_ghash_portableaGcmModeuCreate a new block cipher, configured in Galois Counter Mode (GCM).

    :Parameters:
      factory : module
        A block cipher module, taken from `Crypto.Cipher`.
        The cipher must have block length of 16 bytes.
        GCM has been only defined for `Crypto.Cipher.AES`.

    :Keywords:
      key : bytes/bytearray/memoryview
        The secret key to use in the symmetric cipher.
        It must be 16 (e.g. *AES-128*), 24 (e.g. *AES-192*)
        or 32 (e.g. *AES-256*) bytes long.

      nonce : bytes/bytearray/memoryview
        A value that must never be reused for any other encryption.

        There are no restrictions on its length,
        but it is recommended to use at least 16 bytes.

        The nonce shall never repeat for two
        different messages encrypted with the same key,
        but it does not need to be random.

        If not provided, a 16 byte nonce will be randomly created.

      mac_len : integer
        Length of the MAC, in bytes.
        It must be no larger than 16 bytes (which is the default).
    u
Galois/Counter Mode (GCM).
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__abinasciiTaunhexlifyuCrypto.Util.py3compatTaborda_copy_bytesuCrypto.Util._raw_apiTais_bufferuCrypto.Util.numberTalong_to_bytesabytes_to_longuCrypto.HashTaBLAKE2suCrypto.RandomTaget_random_bytesTaload_pycryptodome_raw_libaVoidPointeracreate_string_bufferaget_raw_bufferaSmartPointerac_size_tac_uint8_ptruCrypto.UtilTa_cpu_featuresu
    int ghash_%imp%(uint8_t y_out[16],
                    const uint8_t block_data[],
                    size_t len,
                    const uint8_t y_in[16],
                    const void *exp_key);
    int ghash_expand_%imp%(const uint8_t h[16],
                           void **ghash_tables);
    int ghash_destroy_%imp%(void *ghash_tables);
a_get_ghash_portablea_get_ghash_clmulTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>a__module__uGHASH function defined in NIST SP 800-38D, Algorithm 2.

    If X_1, X_2, .. X_m are the blocks of input data, the function
    computes:

       X_1*H^{m} + X_2*H^{m-1} + ... + X_m*H

    in the Galois field GF(2^256) using the reducing polynomial
    (x^128 + x^7 + x^2 + x + 1).
    a__qualname__a__init__u_GHASH.__init__u_GHASH.updateu_GHASH.digesta__orig_bases__aenumTllTaPROCESSING_AUTH_DATAaPROCESSING_CIPHERTEXTuGalois Counter Mode (GCM).

    This is an Authenticated Encryption with Associated Data (`AEAD`_) mode.
    It provides both confidentiality and authenticity.

    The header of the message may be left in the clear, if needed, and it will
    still be subject to authentication. The decryption step tells the receiver
    if the message comes from a source that really knowns the secret key.
    Additionally, decryption detects if any part of the message - including the
    header - has been modified or corrupted.

    This mode requires a *nonce*.

    This mode is only available for ciphers that operate on 128 bits blocks
    (e.g. AES but not TDES).

    See `NIST SP800-38D`_.

    .. _`NIST SP800-38D`: http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf
    .. _AEAD: http://blog.cryptographyengineering.com/2012/05/how-to-choose-authenticated-encryption.html

    :undocumented: __init__
    uGcmMode.__init__uGcmMode.updateuGcmMode._updateuGcmMode._pad_cache_and_updateTnuGcmMode.encryptuGcmMode.decryptuGcmMode.digestuGcmMode._compute_macahexdigestuGcmMode.hexdigestuGcmMode.verifyahexverifyuGcmMode.hexverifyaencrypt_and_digestuGcmMode.encrypt_and_digestadecrypt_and_verifyuGcmMode.decrypt_and_verifya_create_gcm_cipheruCrypto\Cipher\_mode_gcm.pyu<module Crypto.Cipher._mode_gcm>Ta__class__T
aselfafactoryakeyanonceamac_lenacipher_paramsaghash_cahash_subkeyaj0afillaghash_inanonce_ctraiv_ctrTaselfasubkeyaghash_caresultTalibapostfixanamedtupleafuncsaGHASH_Impaimp_funcsaparamsTaselfas_tagTafactoryakwargsakeyweanonceamac_lenause_clmulaghash_cTaapialibaresultTaselfalen_cacheTaselfadataafilleraupdate_lenTaselfaciphertextaoutputTaselfaciphertextareceived_mac_tagaoutputaplaintextTaselfTaselfaplaintextaoutputaciphertextTaselfaplaintextaoutputTaenumsTaselfahex_mac_tagTaselfaassoc_dataTaselfablock_dataaresultTaselfareceived_mac_tagasecretamac1amac2.Crypto.Cipher._mode_ocb*ablock_sizeluOCB mode is only available for ciphers that operate on 128 bits blocksa_copy_bytesanonce;llluNonce must be at most 15 bytes longais_bufferuNonce must be bytes, bytearray or memoryviewa_mac_lenluMAC tag must be between 8 and 16 bytes longa_mac_tagca_cache_Aa_cache_PLaupdateaencryptadecryptadigestaverifya_nextakeylabchrlddabordll?lanewaMODE_ECBaencryptastructapacku15sB:nlnastrxor:nln:llnalong_to_bytesabytes_to_longl@l:lnna_create_base_cipheruUnknown keywords: aVoidPointera_statea_raw_ocb_libaOCB_start_operationagetac_size_taaddress_ofuError %d while instantiating the OCB modeaSmartPointeraOCB_stop_operationareleaseaOCB_updateac_uint8_ptruError %d while computing MAC in OCB modeaupdateuupdate() can only be called immediately after initializationLaencryptadecryptadigestaverifyaupdateaminutoo many values to unpack (expected 2)a_updateuProcess the associated data.

        If there is any associated data, the caller has to invoke
        this method one or more times, before using
        ``decrypt`` or ``encrypt``.

        By *associated data* it is meant any data (e.g. packet headers) that
        will not be encrypted and will be transmitted in the clear.
        However, the receiver shall still able to detect modifications.

        If there is no associated data, this method must not be called.

        The caller may split associated data in segments of any size, and
        invoke this method multiple times, each time with the next segment.

        :Parameters:
          assoc_data : bytes/bytearray/memoryview
            A piece of associated data.
        acreate_string_bufferuError %d while %sing in OCB modeaget_raw_buffera_transcrypt_alignedatrans_funcatrans_descuencrypt() can only be called after initialization or an update()adigesta_transcryptaOCB_encryptuEncrypt the next piece of plaintext.

        After the entire plaintext has been passed (but before `digest`),
        you **must** call this method one last time with no arguments to collect
        the final piece of ciphertext.

        If possible, use the method `encrypt_and_digest` instead.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The next piece of data to encrypt or ``None`` to signify
            that encryption has finished and that any remaining ciphertext
            has to be produced.
        :Return:
            the ciphertext, as a byte string.
            Its length may not match the length of the *plaintext*.
        adecryptudecrypt() can only be called after initialization or an update()averifyaOCB_decryptuDecrypt the next piece of ciphertext.

        After the entire ciphertext has been passed (but before `verify`),
        you **must** call this method one last time with no arguments to collect
        the remaining piece of plaintext.

        If possible, use the method `decrypt_and_verify` instead.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The next piece of data to decrypt or ``None`` to signify
            that decryption has finished and that any remaining plaintext
            has to be produced.
        :Return:
            the plaintext, as a byte string.
            Its length may not match the length of the *ciphertext*.
        TlaOCB_digestuError %d while computing digest in OCB modeudigest() cannot be called now for this ciphera_compute_mac_taguCompute the *binary* MAC tag.

        Call this method after the final `encrypt` (the one with no arguments)
        to obtain the MAC tag.

        The MAC tag is needed by the receiver to determine authenticity
        of the message.

        :Return: the MAC, as a byte string.
        uu%02xuCompute the *printable* MAC tag.

        This method is like `digest`.

        :Return: the MAC, as a hexadecimal string.
        uverify() cannot be called now for this cipheraget_random_bytesaBLAKE2slTadigest_bitsakeyadatauMAC check faileduValidate the *binary* MAC tag.

        Call this method after the final `decrypt` (the one with no arguments)
        to check if the message is authentic and valid.

        :Parameters:
          received_mac_tag : bytes/bytearray/memoryview
            This is the *binary* MAC, as received from the sender.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        aunhexlifyuValidate the *printable* MAC tag.

        This method is like `verify`.

        :Parameters:
          hex_mac_tag : string
            This is the *printable* MAC, as received from the sender.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        uEncrypt the message and create the MAC tag in one step.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The entire message to encrypt.
        :Return:
            a tuple with two byte strings:

            - the encrypted data
            - the MAC
        uDecrypted the message and verify its authenticity in one step.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The entire message to decrypt.
          received_mac_tag : byte string
            This is the *binary* MAC, as received from the sender.

        :Return: the decrypted data (byte string).
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        TlapopTamac_lenluKeyword missing: aOcbModeuCreate a new block cipher, configured in OCB mode.

    :Parameters:
      factory : module
        A symmetric cipher module from `Crypto.Cipher`
        (like `Crypto.Cipher.AES`).

    :Keywords:
      nonce : bytes/bytearray/memoryview
        A  value that must never be reused for any other encryption.
        Its length can vary from 1 to 15 bytes.
        If not specified, a random 15 bytes long nonce is generated.

      mac_len : integer
        Length of the MAC, in bytes.
        It must be in the range ``[8..16]``.
        The default is 16 (128 bits).

    Any other keyword will be passed to the underlying block cipher.
    See the relevant documentation for details (at least ``key`` will need
    to be present).
    u
Offset Codebook (OCB) mode.

OCB is Authenticated Encryption with Associated Data (AEAD) cipher mode
designed by Prof. Phillip Rogaway and specified in `RFC7253`_.

The algorithm provides both authenticity and privacy, it is very efficient,
it uses only one key and it can be used in online mode (so that encryption
or decryption can start before the end of the message is available).

This module implements the third and last variant of OCB (OCB3) and it only
works in combination with a 128-bit block symmetric cipher, like AES.

OCB is patented in US but `free licenses`_ exist for software implementations
meant for non-military purposes.

Example:
    >>> from Crypto.Cipher import AES
    >>> from Crypto.Random import get_random_bytes
    >>>
    >>> key = get_random_bytes(32)
    >>> cipher = AES.new(key, AES.MODE_OCB)
    >>> plaintext = b"Attack at dawn"
    >>> ciphertext, mac = cipher.encrypt_and_digest(plaintext)
    >>> # Deliver cipher.nonce, ciphertext and mac
    ...
    >>> cipher = AES.new(key, AES.MODE_OCB, nonce=nonce)
    >>> try:
    >>>     plaintext = cipher.decrypt_and_verify(ciphertext, mac)
    >>> except ValueError:
    >>>     print "Invalid message"
    >>> else:
    >>>     print plaintext

:undocumented: __package__

.. _RFC7253: http://www.rfc-editor.org/info/rfc7253
.. _free licenses: http://web.cs.ucdavis.edu/~rogaway/ocb/license.htm
a__doc__a__file__a__spec__aoriginahas_locationa__cached__labinasciiTaunhexlifyuCrypto.Util.py3compatTaborda_copy_bytesabchruCrypto.Util.numberTalong_to_bytesabytes_to_longuCrypto.Util.strxorTastrxoruCrypto.HashTaBLAKE2suCrypto.RandomTaget_random_bytesuCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeracreate_string_bufferaget_raw_bufferaSmartPointerac_size_tac_uint8_ptrais_bufferaload_pycryptodome_raw_libTuCrypto.Cipher._raw_ocbu
                                    int OCB_start_operation(void *cipher,
                                        const uint8_t *offset_0,
                                        size_t offset_0_len,
                                        void **pState);
                                    int OCB_encrypt(void *state,
                                        const uint8_t *in,
                                        uint8_t *out,
                                        size_t data_len);
                                    int OCB_decrypt(void *state,
                                        const uint8_t *in,
                                        uint8_t *out,
                                        size_t data_len);
                                    int OCB_update(void *state,
                                        const uint8_t *in,
                                        size_t data_len);
                                    int OCB_digest(void *state,
                                        uint8_t *tag,
                                        size_t tag_len);
                                    int OCB_stop_operation(void *state);
                                    TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_ocba__module__uOffset Codebook (OCB) mode.

    :undocumented: __init__
    a__qualname__a__init__uOcbMode.__init__uOcbMode._updateuOcbMode.updateuOcbMode._transcrypt_aligneduOcbMode._transcryptTnuOcbMode.encryptuOcbMode.decryptuOcbMode._compute_mac_taguOcbMode.digestahexdigestuOcbMode.hexdigestuOcbMode.verifyahexverifyuOcbMode.hexverifyaencrypt_and_digestuOcbMode.encrypt_and_digestadecrypt_and_verifyuOcbMode.decrypt_and_verifya__orig_bases__a_create_ocb_cipheruCrypto\Cipher\_mode_ocb.pyu<module Crypto.Cipher._mode_ocb>Ta__class__Taselfafactoryanonceamac_lenacipher_paramsaparams_without_keyakeyataglen_mod128abottom_bitsatop_bitsaktop_cipheraktopastretchaoffset_0araw_cipheraresultTaselfamac_tagaresultTafactoryakwargsanonceamac_lenweTaselfain_dataatrans_funcatrans_descaout_dataaprefixafilleratrans_lenaresultTaselfain_dataain_data_lenatrans_funcatrans_descaout_dataaresultTaselfaassoc_dataaassoc_data_lenaresultTaselfaciphertextTaselfaciphertextareceived_mac_tagaplaintextTaselfTaselfaplaintextTaselfahex_mac_tagTaselfaassoc_dataafillerasegaupdate_lenTaselfareceived_mac_tagasecretamac1amac2.Crypto.Cipher._mode_ofbYaVoidPointera_statearaw_ofb_libaOFB_start_operationagetac_uint8_ptrac_size_taaddress_ofuError %d while instantiating the OFB modeaSmartPointeraOFB_stop_operationareleaseablock_sizea_copy_bytesaivaIVaencryptadecrypta_nextuCreate a new block cipher, configured in OFB mode.

        :Parameters:
          block_cipher : C pointer
            A smart pointer to the low-level block cipher instance.

          iv : bytes/bytearray/memoryview
            The initialization vector to use for encryption or decryption.
            It is as long as the cipher block.

            **The IV must be a nonce, to to be reused for any other
            message**. It shall be a nonce or a random value.

            Reusing the *IV* for encryptions performed with the same key
            compromises confidentiality.
        uencrypt() cannot be called after decrypt()acreate_string_bufferais_writeable_bufferuoutput must be a bytearray or a writeable memoryviewuoutput must have the same length as the input  (%d bytes)aOFB_encryptaplaintextuError %d while encrypting in OFB modeaoutputaget_raw_bufferuEncrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have encrypted a message
        you cannot encrypt (or decrypt) another message using the same
        object.

        The data to encrypt can be broken up in two or
        more pieces and `encrypt` can be called multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
          If ``output`` is ``None``, the ciphertext is returned as ``bytes``.
          Otherwise, ``None``.
        udecrypt() cannot be called after encrypt()aOFB_decryptaciphertextuError %d while decrypting in OFB modeuDecrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        The data to decrypt can be broken up in two or
        more pieces and `decrypt` can be called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext is written to.
            If ``None``, the plaintext is returned.
        :Return:
          If ``output`` is ``None``, the plaintext is returned as ``bytes``.
          Otherwise, ``None``.
        a_create_base_cipherapopTaIVnTaivnTnnaget_random_bytesuYou must either use 'iv' or 'IV', not bothuIncorrect IV length (it must be %d bytes long)uUnknown parameters for OFB: %saOfbModeuInstantiate a cipher object that performs OFB encryption/decryption.

    :Parameters:
      factory : module
        The underlying block cipher, a module from ``Crypto.Cipher``.

    :Keywords:
      iv : bytes/bytearray/memoryview
        The IV to use for OFB.

      IV : bytes/bytearray/memoryview
        Alias for ``iv``.

    Any other keyword will be passed to the underlying block cipher.
    See the relevant documentation for details (at least ``key`` will need
    to be present).
    u
Output Feedback (CFB) mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__uCrypto.Util.py3compatTa_copy_bytesluCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeracreate_string_bufferaget_raw_bufferaSmartPointerac_size_tac_uint8_ptrais_writeable_bufferaload_pycryptodome_raw_libuCrypto.RandomTaget_random_bytesTuCrypto.Cipher._raw_ofbu
                        int OFB_start_operation(void *cipher,
                                                const uint8_t iv[],
                                                size_t iv_len,
                                                void **pResult);
                        int OFB_encrypt(void *ofbState,
                                        const uint8_t *in,
                                        uint8_t *out,
                                        size_t data_len);
                        int OFB_decrypt(void *ofbState,
                                        const uint8_t *in,
                                        uint8_t *out,
                                        size_t data_len);
                        int OFB_stop_operation(void *state);
                        TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_ofba__module__u*Output FeedBack (OFB)*.

    This mode is very similar to CBC, but it
    transforms the underlying block cipher into a stream cipher.

    The keystream is the iterated block encryption of the
    previous ciphertext block.

    An Initialization Vector (*IV*) is required.

    See `NIST SP800-38A`_ , Section 6.4.

    .. _`NIST SP800-38A` : http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf

    :undocumented: __init__
    a__qualname__a__init__uOfbMode.__init__TnuOfbMode.encryptuOfbMode.decrypta__orig_bases__a_create_ofb_cipheruCrypto\Cipher\_mode_ofb.pyu<module Crypto.Cipher._mode_ofb>Ta__class__Taselfablock_cipheraivaresultTafactoryakwargsacipher_stateaivaIVTaselfaciphertextaoutputaplaintextaresultTaselfaplaintextaoutputaciphertextaresultu.Crypto.Cipher._mode_openpgpCablock_sizea_done_first_blockanewaMODE_CFBaIVdasegment_sizela_copy_bytesaencrypt:lnna_encrypted_IVladecrypt:nlnuLength of IV must be %d or %d bytes for MODE_OPENPGPaiva_cipheruEncrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have encrypted a message
        you cannot encrypt (or decrypt) another message using the same
        object.

        The data to encrypt can be broken up in two or
        more pieces and `encrypt` can be called multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.

        :Return:
            the encrypted data, as a byte string.
            It is as long as *plaintext* with one exception:
            when encrypting the first message chunk,
            the encypted IV is prepended to the returned ciphertext.
        uDecrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        The data to decrypt can be broken up in two or
        more pieces and `decrypt` can be called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.

        :Return: the decrypted data (byte string).
        apopTaivnTnnaget_random_bytesuYou must either use 'iv' or 'IV', not bothTakeyuMissing component: aOpenPgpModeafactoryuCreate a new block cipher, configured in OpenPGP mode.

    :Parameters:
      factory : module
        The module.

    :Keywords:
      key : bytes/bytearray/memoryview
        The secret key to use in the symmetric cipher.

      IV : bytes/bytearray/memoryview
        The initialization vector to use for encryption or decryption.

        For encryption, the IV must be as long as the cipher block size.

        For decryption, it must be 2 bytes longer (it is actually the
        *encrypted* IV which was prefixed to the ciphertext).
    u
OpenPGP mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__uCrypto.Util.py3compatTa_copy_bytesluCrypto.RandomTaget_random_bytesTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_openpgpa__module__uOpenPGP mode.

    This mode is a variant of CFB, and it is only used in PGP and
    OpenPGP_ applications. If in doubt, use another mode.

    An Initialization Vector (*IV*) is required.

    Unlike CFB, the *encrypted* IV (not the IV itself) is
    transmitted to the receiver.

    The IV is a random data block. For legacy reasons, two of its bytes are
    duplicated to act as a checksum for the correctness of the key, which is now
    known to be insecure and is ignored. The encrypted IV is therefore 2 bytes
    longer than the clean IV.

    .. _OpenPGP: http://tools.ietf.org/html/rfc4880

    :undocumented: __init__
    a__qualname__a__init__uOpenPgpMode.__init__uOpenPgpMode.encryptuOpenPgpMode.decrypta__orig_bases__a_create_openpgp_cipheruCrypto\Cipher\_mode_openpgp.pyu<module Crypto.Cipher._mode_openpgp>Ta__class__Taselfafactoryakeyaivacipher_paramsaIV_cipherTafactoryakwargsaivaIVakeyweTaselfaciphertextTaselfaplaintextaresu.Crypto.Cipher._mode_siv$ablock_sizea_factorya_cipher_paramsTl l0l@uIncorrect key length (%d bytes)ais_bufferuWhen provided, the nonce must be bytes, bytearray or memoryviewuWhen provided, the nonce must be non-emptya_copy_bytesanoncela_mac_taga_S2VTaciphermodacipher_paramsa_kdfa_subkey_cipheranewaMODE_ECBLaupdateaencryptadecryptadigestaverifya_nextabytes_to_longg+aMODE_CTRainitial_valuecuCreate a new CTR cipher from V in SIV modeaupdateuupdate() can only be called immediately after initializationuProtect one associated data component

        For SIV, the associated data is a sequence (*vector*) of non-empty
        byte strings (*components*).

        This method consumes the next component. It must be called
        once for each of the components that constitue the associated data.

        Note that the components have clear boundaries, so that:

            >>> cipher.update(b"builtin")
            >>> cipher.update(b"securely")

        is not equivalent to:

            >>> cipher.update(b"built")
            >>> cipher.update(b"insecurely")

        If there is no associated data, this method must not be called.

        :Parameters:
          component : bytes/bytearray/memoryview
            The next associated data component.
        uencrypt() not allowed for SIV mode. Use encrypt_and_digest() instead.u
        For SIV, encryption and MAC authentication must take place at the same
        point. This method shall not be used.

        Use `encrypt_and_digest` instead.
        udecrypt() not allowed for SIV mode. Use decrypt_and_verify() instead.u
        For SIV, decryption and verification must take place at the same
        point. This method shall not be used.

        Use `decrypt_and_verify` instead.
        adigestudigest() cannot be called when decrypting or validating a messageaderiveuCompute the *binary* MAC tag.

        The caller invokes this function at the very end.

        This method returns the MAC that shall be sent to the receiver,
        together with the ciphertext.

        :Return: the MAC, as a byte string.
        uu%02xaborduCompute the *printable* MAC tag.

        This method is like `digest`.

        :Return: the MAC, as a hexadecimal string.
        averifyuverify() cannot be called when encrypting a messageaget_random_bytesTlaBLAKE2slTadigest_bitsakeyadatauMAC check faileduValidate the *binary* MAC tag.

        The caller invokes this function at the very end.

        This method checks if the decrypted message is indeed valid
        (that is, if the key is correct) and it has not been
        tampered with while in transit.

        :Parameters:
          received_mac_tag : bytes/bytearray/memoryview
            This is the *binary* MAC, as received from the sender.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        aunhexlifyuValidate the *printable* MAC tag.

        This method is like `verify`.

        :Parameters:
          hex_mac_tag : string
            This is the *printable* MAC, as received from the sender.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        aencryptuencrypt() can only be called after initialization or an update()a_create_ctr_cipherTaoutputuPerform encrypt() and digest() in one step.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
            a tuple with two items:

            - the ciphertext, as ``bytes``
            - the MAC tag, as ``bytes``

            The first item becomes ``None`` when the ``output`` parameter
            specified a location for the result.
        adecryptudecrypt() can only be called after initialization or an update()a_cipheruPerform decryption and verification in one step.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        You cannot reuse an object for encrypting
        or decrypting other data with the same key.

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            It can be of any length.
          mac_tag : bytes/bytearray/memoryview
            This is the *binary* MAC, as received from the sender.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return: the plaintext as ``bytes`` or ``None`` when the ``output``
            parameter specified a location for the result.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        akeyuMissing parameter: apopTanoncenaSivModeuCreate a new block cipher, configured in
    Synthetic Initializaton Vector (SIV) mode.

    :Parameters:

      factory : object
        A symmetric cipher module from `Crypto.Cipher`
        (like `Crypto.Cipher.AES`).

    :Keywords:

      key : bytes/bytearray/memoryview
        The secret key to use in the symmetric cipher.
        It must be 32, 48 or 64 bytes long.
        If AES is the chosen cipher, the variants *AES-128*,
        *AES-192* and or *AES-256* will be used internally.

      nonce : bytes/bytearray/memoryview
        For deterministic encryption, it is not present.

        Otherwise, it is a value that must never be reused
        for encrypting message under this key.

        There are no restrictions on its length,
        but it is recommended to use at least 16 bytes.
    u
Synthetic Initialization Vector (SIV) mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__abinasciiTahexlifyaunhexlifylahexlifyuCrypto.Util.py3compatTaborda_copy_bytesuCrypto.Util._raw_apiTais_bufferuCrypto.Util.numberTalong_to_bytesabytes_to_longalong_to_bytesuCrypto.Protocol.KDFTa_S2VuCrypto.HashTaBLAKE2suCrypto.RandomTaget_random_bytesTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_siva__module__uSynthetic Initialization Vector (SIV).

    This is an Authenticated Encryption with Associated Data (`AEAD`_) mode.
    It provides both confidentiality and authenticity.

    The header of the message may be left in the clear, if needed, and it will
    still be subject to authentication. The decryption step tells the receiver
    if the message comes from a source that really knowns the secret key.
    Additionally, decryption detects if any part of the message - including the
    header - has been modified or corrupted.

    Unlike other AEAD modes such as CCM, EAX or GCM, accidental reuse of a
    nonce is not catastrophic for the confidentiality of the message. The only
    effect is that an attacker can tell when the same plaintext (and same
    associated data) is protected with the same key.

    The length of the MAC is fixed to the block size of the underlying cipher.
    The key size is twice the length of the key of the underlying cipher.

    This mode is only available for AES ciphers.

    +--------------------+---------------+-------------------+
    |      Cipher        | SIV MAC size  |   SIV key length  |
    |                    |    (bytes)    |     (bytes)       |
    +====================+===============+===================+
    |    AES-128         |      16       |        32         |
    +--------------------+---------------+-------------------+
    |    AES-192         |      16       |        48         |
    +--------------------+---------------+-------------------+
    |    AES-256         |      16       |        64         |
    +--------------------+---------------+-------------------+

    See `RFC5297`_ and the `original paper`__.

    .. _RFC5297: https://tools.ietf.org/html/rfc5297
    .. _AEAD: http://blog.cryptographyengineering.com/2012/05/how-to-choose-authenticated-encryption.html
    .. __: http://www.cs.ucdavis.edu/~rogaway/papers/keywrap.pdf

    :undocumented: __init__
    a__qualname__a__init__uSivMode.__init__uSivMode._create_ctr_cipheruSivMode.updateuSivMode.encryptuSivMode.decryptuSivMode.digestahexdigestuSivMode.hexdigestuSivMode.verifyahexverifyuSivMode.hexverifyTnaencrypt_and_digestuSivMode.encrypt_and_digestadecrypt_and_verifyuSivMode.decrypt_and_verifya__orig_bases__a_create_siv_cipheruCrypto\Cipher\_mode_siv.pyu<module Crypto.Cipher._mode_siv>Ta__class__Taselfafactoryakeyanonceakwargsasubkey_sizeTaselfwvav_intwqTafactoryakwargsakeyweanonceTaselfaciphertextTaselfaciphertextamac_tagaoutputaplaintextTaselfTaselfaplaintextTaselfaplaintextaoutputacipherTaselfahex_mac_tagTaselfacomponentTaselfareceived_mac_tagasecretamac1amac2.Crypto.CipherYPakeya_modesapopTaadd_aes_modesFa_extra_modesamodesuMode not supportedTlll
lluToo many arguments for this modelanonceTllllaIVlluIV is not meaningful for the ECB modea__doc__a__file__apathadirnameajoinaenvironagetTaNUITKA_PACKAGE_Cryptou\not_existingaCipherTaNUITKA_PACKAGE_Crypto_Cipheru\not_existinga__path__a__spec__aoriginahas_locationasubmodule_search_locationsa__cached__aosuCrypto.Cipher._mode_ecbTa_create_ecb_ciphera_create_ecb_cipheruCrypto.Cipher._mode_cbcTa_create_cbc_ciphera_create_cbc_cipheruCrypto.Cipher._mode_cfbTa_create_cfb_ciphera_create_cfb_cipheruCrypto.Cipher._mode_ofbTa_create_ofb_ciphera_create_ofb_cipheruCrypto.Cipher._mode_ctrTa_create_ctr_ciphera_create_ctr_cipheruCrypto.Cipher._mode_openpgpTa_create_openpgp_ciphera_create_openpgp_cipheruCrypto.Cipher._mode_ccmTa_create_ccm_ciphera_create_ccm_cipheruCrypto.Cipher._mode_eaxTa_create_eax_ciphera_create_eax_cipheruCrypto.Cipher._mode_sivTa_create_siv_ciphera_create_siv_cipheruCrypto.Cipher._mode_gcmTa_create_gcm_ciphera_create_gcm_cipheruCrypto.Cipher._mode_ocbTa_create_ocb_ciphera_create_ocb_cipherlllllll
lla_create_cipheruCrypto\Cipher\__init__.pyu<module Crypto.Cipher>Tafactoryakeyamodeaargsakwargsamodesu.Crypto.Hash.BLAKE2stadigest_sizea_update_after_digesta_digest_doneTllll u1.3.6.1.4.1.1722.12.2.2.aoidaVoidPointera_raw_blake2s_libablake2s_initaaddress_ofac_uint8_ptrac_size_tuError %d while instantiating BLAKE2saSmartPointeragetablake2s_destroya_stateaupdateuYou can only call 'digest' or 'hexdigest' on this objectablake2s_updateuError %d while hashing BLAKE2s datauContinue hashing of a message by consuming the next chunk of data.

        Args:
            data (byte string/byte array/memoryview): The next chunk of the message being hashed.
        acreate_string_bufferTl ablake2s_digestuError %d while creating BLAKE2s digestaget_raw_bufferuReturn the **binary** (non-printable) digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xaborduReturn the **printable** digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        aget_random_bytesTlanewlTadigest_bitsakeyadatauMAC check faileduVerify that a given **binary** MAC (computed by another party)
        is valid.

        Args:
          mac_tag (byte string/byte array/memoryview): the expected MAC of the message.

        Raises:
            ValueError: if the MAC does not match. It means that the message
                has been tampered with or that the MAC key is incorrect.
        averifyaunhexlifyatobytesuVerify that a given **printable** MAC (computed by another party)
        is valid.

        Args:
            hex_mac_tag (string): the expected MAC of the message, as a hexadecimal string.

        Raises:
            ValueError: if the MAC does not match. It means that the message
                has been tampered with or that the MAC key is incorrect.
        adigest_bytesadigest_bitsakwargsuReturn a new instance of a BLAKE2s hash object.
        See :func:`new`.
        adataapopTaupdate_after_digestFTadigest_bytesnTadigest_bitsnuOnly one digest parameter must be providedTnnl lu'digest_bytes' not in range 1..32llu'digest_bits' not in range 8..256, with steps of 8TakeycuBLAKE2s key cannot exceed 32 bytesuUnknown parameters: aBLAKE2s_HashuCreate a new hash object.

    Args:
        data (byte string/byte array/memoryview):
            Optional. The very first chunk of the message to hash.
            It is equivalent to an early call to :meth:`BLAKE2s_Hash.update`.
        digest_bytes (integer):
            Optional. The size of the digest, in bytes (1 to 32). Default is 32.
        digest_bits (integer):
            Optional and alternative to ``digest_bytes``.
            The size of the digest, in bits (8 to 256, in steps of 8).
            Default is 256.
        key (byte string):
            Optional. The key to use to compute the MAC (1 to 64 bytes).
            If not specified, no key will be used.
        update_after_digest (boolean):
            Optional. By default, a hash object cannot be updated anymore after
            the digest is computed. When this flag is ``True``, such check
            is no longer enforced.

    Returns:
        A :class:`BLAKE2s_Hash` hash object
    a__doc__a__file__a__spec__aoriginahas_locationa__cached__abinasciiTaunhexlifyluCrypto.Util.py3compatTabordatobytesuCrypto.RandomTaget_random_bytesuCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointeracreate_string_bufferaget_raw_bufferac_size_tac_uint8_ptraload_pycryptodome_raw_libTuCrypto.Hash._BLAKE2su
                        int blake2s_init(void **state,
                                         const uint8_t *key,
                                         size_t key_size,
                                         size_t digest_size);
                        int blake2s_destroy(void *state);
                        int blake2s_update(void *state,
                                           const uint8_t *buf,
                                           size_t len);
                        int blake2s_digest(const void *state,
                                           uint8_t digest[32]);
                        int blake2s_copy(const void *src, void *dst);
                        TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.BLAKE2sa__module__uA BLAKE2s hash object.
    Do not instantiate directly. Use the :func:`new` function.

    :ivar oid: ASN.1 Object ID
    :vartype oid: string

    :ivar block_size: the size in bytes of the internal message block,
                      input to the compression function
    :vartype block_size: integer

    :ivar digest_size: the size in bytes of the resulting hash
    :vartype digest_size: integer
    a__qualname__ablock_sizea__init__uBLAKE2s_Hash.__init__uBLAKE2s_Hash.updateuBLAKE2s_Hash.digestahexdigestuBLAKE2s_Hash.hexdigestuBLAKE2s_Hash.verifyahexverifyuBLAKE2s_Hash.hexverifyuBLAKE2s_Hash.newa__orig_bases__uCrypto\Hash\BLAKE2s.pyu<module Crypto.Hash.BLAKE2s>Ta__class__Taselfadataakeyadigest_bytesaupdate_after_digestastatearesultTaselfabfraresultTaselfTaselfahex_mac_tagTakwargsadataaupdate_after_digestadigest_bytesadigest_bitsakeyTaselfakwargsTaselfadataaresultTaselfamac_tagasecretamac1amac2.Crypto.Hash.CMACabytes_to_longlalong_to_bytesadigest_sizea_copy_bytesa_keya_factorya_cipher_paramsablock_sizea_block_sizea_mac_taga_update_after_digestllla_max_sizellquCMAC requires a cipher with a block size of 8 or 16 bytes, not %ddanewaMODE_ECBa_ecbaencryptabordlla_shift_bytesa_k1a_k2aMODE_CBCa_cbca_cachea_cache_na_last_cta_last_pta_data_sizeaupdateuupdate() cannot be called after digest() or verify()amina_updateamsgabsuAuthenticate the next chunk of message.

        Args:
            data (byte string/byte array/memoryview): The next chunk of data
        lastrxoruUpdate a block aligned to the block boundarya__new__aCMACacopy:nnnuReturn a copy ("clone") of the CMAC object.

        The copy will have the same internal state as the original CMAC
        object.
        This can be used to efficiently compute the MAC tag of byte
        strings that share a common initial substring.

        :return: An :class:`CMAC`
        uMAC is unsafe for this messageduReturn the **binary** (non-printable) MAC tag of the message
        that has been authenticated so far.

        :return: The MAC tag, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xuReturn the **printable** MAC tag of the message authenticated so far.

        :return: The MAC tag, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        aget_random_bytesTlaBLAKE2slTadigest_bitsakeyadatauMAC check faileduVerify that a given **binary** MAC (computed by another party)
        is valid.

        Args:
          mac_tag (byte string/byte array/memoryview): the expected MAC of the message.

        Raises:
            ValueError: if the MAC does not match. It means that the message
                has been tampered with or that the MAC key is incorrect.
        averifyaunhexlifyatobytesuVerify that a given **printable** MAC (computed by another party)
        is valid.

        Args:
          hex_mac_tag (string): the expected MAC of the message, as a hexadecimal string.

        Raises:
            ValueError: if the MAC does not match. It means that the message
                has been tampered with or that the MAC key is incorrect.
        uciphermod must be specified (try AES)luMAC tag length must be at least 4 bytes longaciphermoduMAC tag length cannot be larger than a cipher block (%d) bytesuCreate a new MAC object.

    Args:
        key (byte string/byte array/memoryview):
            key for the CMAC object.
            The key must be valid for the underlying cipher algorithm.
            For instance, it must be 16 bytes long for AES-128.
        ciphermod (module):
            A cipher module from :mod:`Crypto.Cipher`.
            The cipher's block size has to be 128 bits,
            like :mod:`Crypto.Cipher.AES`, to reduce the probability
            of collisions.
        msg (byte string/byte array/memoryview):
            Optional. The very first chunk of the message to authenticate.
            It is equivalent to an early call to `CMAC.update`. Optional.
        cipher_params (dict):
            Optional. A set of parameters to use when instantiating a cipher
            object.
        mac_len (integer):
            Length of the MAC, in bytes.
            It must be at least 4 bytes long.
            The default (and recommended) length matches the size of a cipher block.
        update_after_digest (boolean):
            Optional. By default, a hash object cannot be updated anymore after
            the digest is computed. When this flag is ``True``, such check
            is no longer enforced.
    Returns:
        A :class:`CMAC` object
    a__doc__a__file__a__spec__aoriginahas_locationa__cached__abinasciiTaunhexlifyuCrypto.HashTaBLAKE2suCrypto.Util.strxorTastrxoruCrypto.Util.numberTalong_to_bytesabytes_to_longuCrypto.Util.py3compatTabordatobytesa_copy_bytesuCrypto.RandomTaget_random_bytesTlTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.CMACa__module__uA CMAC hash object.
    Do not instantiate directly. Use the :func:`new` function.

    :ivar digest_size: the size in bytes of the resulting MAC tag
    :vartype digest_size: integer
    a__qualname__a__init__uCMAC.__init__uCMAC.updateuCMAC._updateuCMAC.copyuCMAC.digestahexdigestuCMAC.hexdigestuCMAC.verifyahexverifyuCMAC.hexverifya__orig_bases__TnnnnFuCrypto\Hash\CMAC.pyu<module Crypto.Hash.CMAC>Ta__class__Taselfakeyamsgaciphermodacipher_paramsamac_lenaupdate_after_digestabsaconst_Rbazero_blockwLTabsaxor_lsbanumTaselfadata_blockabsactasecond_lastTaselfaobjTaselfabsaptapartialTaselfTaselfahex_mac_tagTakeyamsgaciphermodacipher_paramsamac_lenaupdate_after_digestTaselfamsgabsafilleraremainTaselfamac_tagasecretamac1amac2.Crypto.Hash.HMAC-duCrypto.HashTaMD5laMD5cadigest_sizea_digestmoda_hash2hmac_oidaoidTEKeyErrorEAttributeErroratobytesablock_sizedanewadigestuHash type incompatible to HMACastrxord6a_inneraupdated\a_outeruAuthenticate the next chunk of message.

        Args:
            data (byte string/byte array/memoryview): The next chunk of data
        a_pbkdf2_hmac_assistuCarry out the expensive inner loop for PBKDF2-HMACaHMACTcfake keyTadigestmodacopyuReturn a copy ("clone") of the HMAC object.

        The copy will have the same internal state as the original HMAC
        object.
        This can be used to efficiently compute the MAC tag of byte
        strings that share a common initial substring.

        :return: An :class:`HMAC`
        uReturn the **binary** (non-printable) MAC tag of the message
        authenticated so far.

        :return: The MAC tag digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        aget_random_bytesTlaBLAKE2slTadigest_bitsakeyadatauMAC check faileduVerify that a given **binary** MAC (computed by another party)
        is valid.

        Args:
          mac_tag (byte string/byte string/memoryview): the expected MAC of the message.

        Raises:
            ValueError: if the MAC does not match. It means that the message
                has been tampered with or that the MAC key is incorrect.
        uu%02xaborduReturn the **printable** MAC tag of the message authenticated so far.

        :return: The MAC tag, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        averifyaunhexlifyuVerify that a given **printable** MAC (computed by another party)
        is valid.

        Args:
            hex_mac_tag (string): the expected MAC of the message,
                as a hexadecimal string.

        Raises:
            ValueError: if the MAC does not match. It means that the message
                has been tampered with or that the MAC key is incorrect.
        uCreate a new MAC object.

    Args:
        key (bytes/bytearray/memoryview):
            key for the MAC object.
            It must be long enough to match the expected security level of the
            MAC.
        msg (bytes/bytearray/memoryview):
            Optional. The very first chunk of the message to authenticate.
            It is equivalent to an early call to :meth:`HMAC.update`.
        digestmod (module):
            The hash to use to implement the HMAC.
            Default is :mod:`Crypto.Hash.MD5`.

    Returns:
        An :class:`HMAC` object
    a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTabordatobytesabinasciiTaunhexlifyTaBLAKE2suCrypto.Util.strxorTastrxoruCrypto.RandomTaget_random_bytesa__all__Du1.3.14.3.2.26u2.16.840.1.101.3.4.2.4u2.16.840.1.101.3.4.2.1u2.16.840.1.101.3.4.2.2u2.16.840.1.101.3.4.2.3u2.16.840.1.101.3.4.2.5u2.16.840.1.101.3.4.2.6u2.16.840.1.101.3.4.2.7u2.16.840.1.101.3.4.2.8u2.16.840.1.101.3.4.2.9u2.16.840.1.101.3.4.2.10u1.2.840.113549.2.7u1.2.840.113549.2.8u1.2.840.113549.2.9u1.2.840.113549.2.10u1.2.840.113549.2.11u1.2.840.113549.2.12u1.2.840.113549.2.13u2.16.840.1.101.3.4.2.13u2.16.840.1.101.3.4.2.14u2.16.840.1.101.3.4.2.15u2.16.840.1.101.3.4.2.16utoo many values to unpack (expected 2)a_hmac2hash_oidTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.HMACa__module__uAn HMAC hash object.
    Do not instantiate directly. Use the :func:`new` function.

    :ivar digest_size: the size in bytes of the resulting MAC tag
    :vartype digest_size: integer

    :ivar oid: the ASN.1 object ID of the HMAC algorithm.
               Only present if the algorithm was officially assigned one.
    a__qualname__Tcna__init__uHMAC.__init__uHMAC.updateuHMAC._pbkdf2_hmac_assistuHMAC.copyuHMAC.digestuHMAC.verifyahexdigestuHMAC.hexdigestahexverifyuHMAC.hexverifya__orig_bases__uCrypto\Hash\HMAC.pyu<module Crypto.Hash.HMAC>Ta__class__TaselfakeyamsgadigestmodaMD5akey_0ahash_kakey_0_ipadakey_0_opadTaselfafirst_digestaiterationsaresultTaselfanew_hmacTaselfafrozen_outer_hashTaselfTaselfahex_mac_tagTakeyamsgadigestmodTaselfamsgTaselfamac_tagasecretamac1amac2.Crypto.Hash.MD5UWaVoidPointera_raw_md5_libaMD5_initaaddress_ofaValueErroruError %d while instantiating MD5aSmartPointeragetaMD5_destroya_stateaupdateaMD5_updateac_uint8_ptrac_size_talenuContinue hashing of a message by consuming the next chunk of data.

        Args:
            data (byte string/byte array/memoryview): The next chunk of the message being hashed.
        acreate_string_bufferadigest_sizeaMD5_digestaget_raw_bufferuReturn the **binary** (non-printable) digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xaborduReturn the **printable** digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        aMD5HashaMD5_copyuError %d while copying MD5uReturn a copy ("clone") of the hash object.

        The copy will have the same internal state as the original hash
        object.
        This can be used to efficiently compute the digests of strings that
        share a common initial substring.

        :return: A hash object of the same type
        uCreate a fresh SHA-1 hash object.anewuCreate a new hash object.

    :parameter data:
        Optional. The very first chunk of the message to hash.
        It is equivalent to an early call to :meth:`MD5Hash.update`.
    :type data: byte string/byte array/memoryview

    :Return: A :class:`MD5Hash` hash object
    laMD5_pbkdf2_hmac_assistuError %d with PBKDF2-HMAC assis for MD5uCompute the expensive inner loop in PBKDF-HMAC.a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTw*uCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointeracreate_string_bufferaget_raw_bufferac_size_tac_uint8_ptraload_pycryptodome_raw_libTuCrypto.Hash._MD5u
                        #define MD5_DIGEST_SIZE 16

                        int MD5_init(void **shaState);
                        int MD5_destroy(void *shaState);
                        int MD5_update(void *hs,
                                          const uint8_t *buf,
                                          size_t len);
                        int MD5_digest(const void *shaState,
                                          uint8_t digest[MD5_DIGEST_SIZE]);
                        int MD5_copy(const void *src, void *dst);

                        int MD5_pbkdf2_hmac_assist(const void *inner,
                                            const void *outer,
                                            const uint8_t first_digest[MD5_DIGEST_SIZE],
                                            uint8_t final_digest[MD5_DIGEST_SIZE],
                                            size_t iterations);
                        aobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.MD5a__module__uA MD5 hash object.
    Do not instantiate directly.
    Use the :func:`new` function.

    :ivar oid: ASN.1 Object ID
    :vartype oid: string

    :ivar block_size: the size in bytes of the internal message block,
                      input to the compression function
    :vartype block_size: integer

    :ivar digest_size: the size in bytes of the resulting hash
    :vartype digest_size: integer
    a__qualname__ll@ablock_sizeu1.2.840.113549.2.5aoidTna__init__uMD5Hash.__init__uMD5Hash.updateuMD5Hash.digestahexdigestuMD5Hash.hexdigestacopyuMD5Hash.copyuMD5Hash.newa__orig_bases__a_pbkdf2_hmac_assistuCrypto\Hash\MD5.pyu<module Crypto.Hash.MD5>Ta__class__TaselfadataastatearesultTainneraouterafirst_digestaiterationsabfraresultTaselfaclonearesultTaselfabfraresultTaselfTadataTaselfadataTaselfadataaresult.Crypto.Hash.SHA1sWaVoidPointera_raw_sha1_libaSHA1_initaaddress_ofaValueErroruError %d while instantiating SHA1aSmartPointeragetaSHA1_destroya_stateaupdateaSHA1_updateac_uint8_ptrac_size_talenuContinue hashing of a message by consuming the next chunk of data.

        Args:
            data (byte string/byte array/memoryview): The next chunk of the message being hashed.
        acreate_string_bufferadigest_sizeaSHA1_digestaget_raw_bufferuReturn the **binary** (non-printable) digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xaborduReturn the **printable** digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        aSHA1HashaSHA1_copyuError %d while copying SHA1uReturn a copy ("clone") of the hash object.

        The copy will have the same internal state as the original hash
        object.
        This can be used to efficiently compute the digests of strings that
        share a common initial substring.

        :return: A hash object of the same type
        uCreate a fresh SHA-1 hash object.anewuCreate a new hash object.

    :parameter data:
        Optional. The very first chunk of the message to hash.
        It is equivalent to an early call to :meth:`SHA1Hash.update`.
    :type data: byte string/byte array/memoryview

    :Return: A :class:`SHA1Hash` hash object
    laSHA1_pbkdf2_hmac_assistuError %d with PBKDF2-HMAC assis for SHA1uCompute the expensive inner loop in PBKDF-HMAC.a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTw*uCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointeracreate_string_bufferaget_raw_bufferac_size_tac_uint8_ptraload_pycryptodome_raw_libTuCrypto.Hash._SHA1u
                        #define SHA1_DIGEST_SIZE 20

                        int SHA1_init(void **shaState);
                        int SHA1_destroy(void *shaState);
                        int SHA1_update(void *hs,
                                          const uint8_t *buf,
                                          size_t len);
                        int SHA1_digest(const void *shaState,
                                          uint8_t digest[SHA1_DIGEST_SIZE]);
                        int SHA1_copy(const void *src, void *dst);

                        int SHA1_pbkdf2_hmac_assist(const void *inner,
                                            const void *outer,
                                            const uint8_t first_digest[SHA1_DIGEST_SIZE],
                                            uint8_t final_digest[SHA1_DIGEST_SIZE],
                                            size_t iterations);
                        aobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.SHA1a__module__uA SHA-1 hash object.
    Do not instantiate directly.
    Use the :func:`new` function.

    :ivar oid: ASN.1 Object ID
    :vartype oid: string

    :ivar block_size: the size in bytes of the internal message block,
                      input to the compression function
    :vartype block_size: integer

    :ivar digest_size: the size in bytes of the resulting hash
    :vartype digest_size: integer
    a__qualname__ll@ablock_sizeu1.3.14.3.2.26aoidTna__init__uSHA1Hash.__init__uSHA1Hash.updateuSHA1Hash.digestahexdigestuSHA1Hash.hexdigestacopyuSHA1Hash.copyuSHA1Hash.newa__orig_bases__a_pbkdf2_hmac_assistuCrypto\Hash\SHA1.pyu<module Crypto.Hash.SHA1>Ta__class__TaselfadataastatearesultTainneraouterafirst_digestaiterationsabfraresultTaselfaclonearesultTaselfabfraresultTaselfTadataTaselfadataTaselfadataaresult.Crypto.Hash.SHA224WaVoidPointera_raw_sha224_libaSHA224_initaaddress_ofuError %d while instantiating SHA224aSmartPointeragetaSHA224_destroya_stateaupdateaSHA224_updateac_uint8_ptrac_size_tuError %d while hashing data with SHA224uContinue hashing of a message by consuming the next chunk of data.

        Args:
            data (byte string/byte array/memoryview): The next chunk of the message being hashed.
        acreate_string_bufferadigest_sizeaSHA224_digestuError %d while making SHA224 digestaget_raw_bufferuReturn the **binary** (non-printable) digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xaborduReturn the **printable** digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        aSHA224HashaSHA224_copyuError %d while copying SHA224uReturn a copy ("clone") of the hash object.

        The copy will have the same internal state as the original hash
        object.
        This can be used to efficiently compute the digests of strings that
        share a common initial substring.

        :return: A hash object of the same type
        uCreate a fresh SHA-224 hash object.anewuCreate a new hash object.

    :parameter data:
        Optional. The very first chunk of the message to hash.
        It is equivalent to an early call to :meth:`SHA224Hash.update`.
    :type data: byte string/byte array/memoryview

    :Return: A :class:`SHA224Hash` hash object
    laSHA224_pbkdf2_hmac_assistuError %d with PBKDF2-HMAC assist for SHA224uCompute the expensive inner loop in PBKDF-HMAC.a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTaborduCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointeracreate_string_bufferaget_raw_bufferac_size_tac_uint8_ptraload_pycryptodome_raw_libTuCrypto.Hash._SHA224u
                        int SHA224_init(void **shaState);
                        int SHA224_destroy(void *shaState);
                        int SHA224_update(void *hs,
                                          const uint8_t *buf,
                                          size_t len);
                        int SHA224_digest(const void *shaState,
                                          uint8_t *digest,
                                          size_t digest_size);
                        int SHA224_copy(const void *src, void *dst);

                        int SHA224_pbkdf2_hmac_assist(const void *inner,
                                            const void *outer,
                                            const uint8_t *first_digest,
                                            uint8_t *final_digest,
                                            size_t iterations,
                                            size_t digest_size);
                        TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.SHA224a__module__uA SHA-224 hash object.
    Do not instantiate directly.
    Use the :func:`new` function.

    :ivar oid: ASN.1 Object ID
    :vartype oid: string

    :ivar block_size: the size in bytes of the internal message block,
                      input to the compression function
    :vartype block_size: integer

    :ivar digest_size: the size in bytes of the resulting hash
    :vartype digest_size: integer
    a__qualname__ll@ablock_sizeu2.16.840.1.101.3.4.2.4aoidTna__init__uSHA224Hash.__init__uSHA224Hash.updateuSHA224Hash.digestahexdigestuSHA224Hash.hexdigestacopyuSHA224Hash.copyuSHA224Hash.newa__orig_bases__a_pbkdf2_hmac_assistuCrypto\Hash\SHA224.pyu<module Crypto.Hash.SHA224>Ta__class__TaselfadataastatearesultTainneraouterafirst_digestaiterationsabfraresultTaselfaclonearesultTaselfabfraresultTaselfTadataTaselfadataTaselfadataaresult.Crypto.Hash.SHA256WaVoidPointera_raw_sha256_libaSHA256_initaaddress_ofuError %d while instantiating SHA256aSmartPointeragetaSHA256_destroya_stateaupdateaSHA256_updateac_uint8_ptrac_size_tuError %d while hashing data with SHA256uContinue hashing of a message by consuming the next chunk of data.

        Args:
            data (byte string/byte array/memoryview): The next chunk of the message being hashed.
        acreate_string_bufferadigest_sizeaSHA256_digestuError %d while making SHA256 digestaget_raw_bufferuReturn the **binary** (non-printable) digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xaborduReturn the **printable** digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        aSHA256HashaSHA256_copyuError %d while copying SHA256uReturn a copy ("clone") of the hash object.

        The copy will have the same internal state as the original hash
        object.
        This can be used to efficiently compute the digests of strings that
        share a common initial substring.

        :return: A hash object of the same type
        uCreate a fresh SHA-256 hash object.anewuCreate a new hash object.

    :parameter data:
        Optional. The very first chunk of the message to hash.
        It is equivalent to an early call to :meth:`SHA256Hash.update`.
    :type data: byte string/byte array/memoryview

    :Return: A :class:`SHA256Hash` hash object
    laSHA256_pbkdf2_hmac_assistuError %d with PBKDF2-HMAC assist for SHA256uCompute the expensive inner loop in PBKDF-HMAC.a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTaborduCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointeracreate_string_bufferaget_raw_bufferac_size_tac_uint8_ptraload_pycryptodome_raw_libTuCrypto.Hash._SHA256u
                        int SHA256_init(void **shaState);
                        int SHA256_destroy(void *shaState);
                        int SHA256_update(void *hs,
                                          const uint8_t *buf,
                                          size_t len);
                        int SHA256_digest(const void *shaState,
                                          uint8_t *digest,
                                          size_t digest_size);
                        int SHA256_copy(const void *src, void *dst);

                        int SHA256_pbkdf2_hmac_assist(const void *inner,
                                            const void *outer,
                                            const uint8_t *first_digest,
                                            uint8_t *final_digest,
                                            size_t iterations,
                                            size_t digest_size);
                        TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.SHA256a__module__uA SHA-256 hash object.
    Do not instantiate directly. Use the :func:`new` function.

    :ivar oid: ASN.1 Object ID
    :vartype oid: string

    :ivar block_size: the size in bytes of the internal message block,
                      input to the compression function
    :vartype block_size: integer

    :ivar digest_size: the size in bytes of the resulting hash
    :vartype digest_size: integer
    a__qualname__l l@ablock_sizeu2.16.840.1.101.3.4.2.1aoidTna__init__uSHA256Hash.__init__uSHA256Hash.updateuSHA256Hash.digestahexdigestuSHA256Hash.hexdigestacopyuSHA256Hash.copyuSHA256Hash.newa__orig_bases__a_pbkdf2_hmac_assistuCrypto\Hash\SHA256.pyu<module Crypto.Hash.SHA256>Ta__class__TaselfadataastatearesultTainneraouterafirst_digestaiterationsabfraresultTaselfaclonearesultTaselfabfraresultTaselfTadataTaselfadataTaselfadataaresult.Crypto.Hash.SHA384WaVoidPointera_raw_sha384_libaSHA384_initaaddress_ofuError %d while instantiating SHA384aSmartPointeragetaSHA384_destroya_stateaupdateaSHA384_updateac_uint8_ptrac_size_tuError %d while hashing data with SHA384uContinue hashing of a message by consuming the next chunk of data.

        Args:
            data (byte string/byte array/memoryview): The next chunk of the message being hashed.
        acreate_string_bufferadigest_sizeaSHA384_digestuError %d while making SHA384 digestaget_raw_bufferuReturn the **binary** (non-printable) digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xaborduReturn the **printable** digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        aSHA384HashaSHA384_copyuError %d while copying SHA384uReturn a copy ("clone") of the hash object.

        The copy will have the same internal state as the original hash
        object.
        This can be used to efficiently compute the digests of strings that
        share a common initial substring.

        :return: A hash object of the same type
        uCreate a fresh SHA-384 hash object.anewuCreate a new hash object.

    :parameter data:
        Optional. The very first chunk of the message to hash.
        It is equivalent to an early call to :meth:`SHA384Hash.update`.
    :type data: byte string/byte array/memoryview

    :Return: A :class:`SHA384Hash` hash object
    laSHA384_pbkdf2_hmac_assistuError %d with PBKDF2-HMAC assist for SHA384uCompute the expensive inner loop in PBKDF-HMAC.a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTaborduCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointeracreate_string_bufferaget_raw_bufferac_size_tac_uint8_ptraload_pycryptodome_raw_libTuCrypto.Hash._SHA384u
                        int SHA384_init(void **shaState);
                        int SHA384_destroy(void *shaState);
                        int SHA384_update(void *hs,
                                          const uint8_t *buf,
                                          size_t len);
                        int SHA384_digest(const void *shaState,
                                          uint8_t *digest,
                                          size_t digest_size);
                        int SHA384_copy(const void *src, void *dst);

                        int SHA384_pbkdf2_hmac_assist(const void *inner,
                                            const void *outer,
                                            const uint8_t *first_digest,
                                            uint8_t *final_digest,
                                            size_t iterations,
                                            size_t digest_size);
                        TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.SHA384a__module__uA SHA-384 hash object.
    Do not instantiate directly. Use the :func:`new` function.

    :ivar oid: ASN.1 Object ID
    :vartype oid: string

    :ivar block_size: the size in bytes of the internal message block,
                      input to the compression function
    :vartype block_size: integer

    :ivar digest_size: the size in bytes of the resulting hash
    :vartype digest_size: integer
    a__qualname__l0lablock_sizeu2.16.840.1.101.3.4.2.2aoidTna__init__uSHA384Hash.__init__uSHA384Hash.updateuSHA384Hash.digestahexdigestuSHA384Hash.hexdigestacopyuSHA384Hash.copyuSHA384Hash.newa__orig_bases__a_pbkdf2_hmac_assistuCrypto\Hash\SHA384.pyu<module Crypto.Hash.SHA384>Ta__class__TaselfadataastatearesultTainneraouterafirst_digestaiterationsabfraresultTaselfaclonearesultTaselfabfraresultTaselfTadataTaselfadataTaselfadataaresult.Crypto.Hash.SHA3_224`a_update_after_digesta_digest_donela_paddingaVoidPointera_raw_keccak_libakeccak_initaaddress_ofac_size_tadigest_sizelac_ubyteTluError %d while instantiating SHA-3/224aSmartPointeragetakeccak_destroya_stateaupdateuYou can only call 'digest' or 'hexdigest' on this objectakeccak_absorbac_uint8_ptruError %d while updating SHA-3/224uContinue hashing of a message by consuming the next chunk of data.

        Args:
            data (byte string/byte array/memoryview): The next chunk of the message being hashed.
        acreate_string_bufferakeccak_digestaget_raw_buffera_digest_valueuReturn the **binary** (non-printable) digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xaborduReturn the **printable** digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        anewakeccak_copyuError %d while copying SHA3-224uReturn a copy ("clone") of the hash object.

        The copy will have the same internal state as the original hash
        object.
        This can be used to efficiently compute the digests of strings that
        share a common initial substring.

        :return: A hash object of the same type
        uCreate a fresh SHA3-224 hash object.adataapopTaupdate_after_digestFuInitial data for hash specified twiceluUnknown parameters: aSHA3_224_HashuCreate a new hash object.

    Args:
        data (byte string/byte array/memoryview):
            The very first chunk of the message to hash.
            It is equivalent to an early call to :meth:`update`.
        update_after_digest (boolean):
            Whether :meth:`digest` can be followed by another :meth:`update`
            (default: ``False``).

    :Return: A :class:`SHA3_224_Hash` hash object
    a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTaborduCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointeracreate_string_bufferaget_raw_bufferac_size_tac_uint8_ptrac_ubyteaload_pycryptodome_raw_libuCrypto.Hash.keccakTa_raw_keccak_libTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.SHA3_224a__module__uA SHA3-224 hash object.
    Do not instantiate directly.
    Use the :func:`new` function.

    :ivar oid: ASN.1 Object ID
    :vartype oid: string

    :ivar digest_size: the size in bytes of the resulting hash
    :vartype digest_size: integer
    a__qualname__lu2.16.840.1.101.3.4.2.7aoidlablock_sizea__init__uSHA3_224_Hash.__init__uSHA3_224_Hash.updateuSHA3_224_Hash.digestahexdigestuSHA3_224_Hash.hexdigestacopyuSHA3_224_Hash.copyTnuSHA3_224_Hash.newa__orig_bases__uCrypto\Hash\SHA3_224.pyu<module Crypto.Hash.SHA3_224>Ta__class__Taselfadataaupdate_after_digestastatearesultTaselfaclonearesultTaselfabfraresultTaselfTaargsakwargsadataaupdate_after_digestTaselfadataTaselfadataaresult.Crypto.Hash.SHA3_256`a_update_after_digesta_digest_donela_paddingaVoidPointera_raw_keccak_libakeccak_initaaddress_ofac_size_tadigest_sizelac_ubyteTluError %d while instantiating SHA-3/256aSmartPointeragetakeccak_destroya_stateaupdateuYou can only call 'digest' or 'hexdigest' on this objectakeccak_absorbac_uint8_ptruError %d while updating SHA-3/256uContinue hashing of a message by consuming the next chunk of data.

        Args:
            data (byte string/byte array/memoryview): The next chunk of the message being hashed.
        acreate_string_bufferakeccak_digestaget_raw_buffera_digest_valueuReturn the **binary** (non-printable) digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xaborduReturn the **printable** digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        anewakeccak_copyuError %d while copying SHA3-256uReturn a copy ("clone") of the hash object.

        The copy will have the same internal state as the original hash
        object.
        This can be used to efficiently compute the digests of strings that
        share a common initial substring.

        :return: A hash object of the same type
        uCreate a fresh SHA3-256 hash object.adataapopTaupdate_after_digestFuInitial data for hash specified twiceluUnknown parameters: aSHA3_256_HashuCreate a new hash object.

    Args:
        data (byte string/byte array/memoryview):
            The very first chunk of the message to hash.
            It is equivalent to an early call to :meth:`update`.
        update_after_digest (boolean):
            Whether :meth:`digest` can be followed by another :meth:`update`
            (default: ``False``).

    :Return: A :class:`SHA3_256_Hash` hash object
    a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTaborduCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointeracreate_string_bufferaget_raw_bufferac_size_tac_uint8_ptrac_ubyteaload_pycryptodome_raw_libuCrypto.Hash.keccakTa_raw_keccak_libTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.SHA3_256a__module__uA SHA3-256 hash object.
    Do not instantiate directly.
    Use the :func:`new` function.

    :ivar oid: ASN.1 Object ID
    :vartype oid: string

    :ivar digest_size: the size in bytes of the resulting hash
    :vartype digest_size: integer
    a__qualname__l u2.16.840.1.101.3.4.2.8aoidlablock_sizea__init__uSHA3_256_Hash.__init__uSHA3_256_Hash.updateuSHA3_256_Hash.digestahexdigestuSHA3_256_Hash.hexdigestacopyuSHA3_256_Hash.copyTnuSHA3_256_Hash.newa__orig_bases__uCrypto\Hash\SHA3_256.pyu<module Crypto.Hash.SHA3_256>Ta__class__Taselfadataaupdate_after_digestastatearesultTaselfaclonearesultTaselfabfraresultTaselfTaargsakwargsadataaupdate_after_digestTaselfadataTaselfadataaresult.Crypto.Hash.SHA3_384aa_update_after_digesta_digest_donela_paddingaVoidPointera_raw_keccak_libakeccak_initaaddress_ofac_size_tadigest_sizelac_ubyteTluError %d while instantiating SHA-3/384aSmartPointeragetakeccak_destroya_stateaupdateuYou can only call 'digest' or 'hexdigest' on this objectakeccak_absorbac_uint8_ptruError %d while updating SHA-3/384uContinue hashing of a message by consuming the next chunk of data.

        Args:
            data (byte string/byte array/memoryview): The next chunk of the message being hashed.
        acreate_string_bufferakeccak_digestaget_raw_buffera_digest_valueuReturn the **binary** (non-printable) digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xaborduReturn the **printable** digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        anewakeccak_copyuError %d while copying SHA3-384uReturn a copy ("clone") of the hash object.

        The copy will have the same internal state as the original hash
        object.
        This can be used to efficiently compute the digests of strings that
        share a common initial substring.

        :return: A hash object of the same type
        uCreate a fresh SHA3-256 hash object.uCreate a fresh SHA3-384 hash object.adataapopTaupdate_after_digestFuInitial data for hash specified twiceluUnknown parameters: aSHA3_384_HashuCreate a new hash object.

    Args:
        data (byte string/byte array/memoryview):
            The very first chunk of the message to hash.
            It is equivalent to an early call to :meth:`update`.
        update_after_digest (boolean):
            Whether :meth:`digest` can be followed by another :meth:`update`
            (default: ``False``).

    :Return: A :class:`SHA3_384_Hash` hash object
    a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTaborduCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointeracreate_string_bufferaget_raw_bufferac_size_tac_uint8_ptrac_ubyteaload_pycryptodome_raw_libuCrypto.Hash.keccakTa_raw_keccak_libTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.SHA3_384a__module__uA SHA3-384 hash object.
    Do not instantiate directly.
    Use the :func:`new` function.

    :ivar oid: ASN.1 Object ID
    :vartype oid: string

    :ivar digest_size: the size in bytes of the resulting hash
    :vartype digest_size: integer
    a__qualname__l0u2.16.840.1.101.3.4.2.9aoidlhablock_sizea__init__uSHA3_384_Hash.__init__uSHA3_384_Hash.updateuSHA3_384_Hash.digestahexdigestuSHA3_384_Hash.hexdigestacopyuSHA3_384_Hash.copyTnuSHA3_384_Hash.newa__orig_bases__uCrypto\Hash\SHA3_384.pyu<module Crypto.Hash.SHA3_384>Ta__class__Taselfadataaupdate_after_digestastatearesultTaselfaclonearesultTaselfabfraresultTaselfTaargsakwargsadataaupdate_after_digestTaselfadataTaselfadataaresult.Crypto.Hash.SHA3_512`a_update_after_digesta_digest_donela_paddingaVoidPointera_raw_keccak_libakeccak_initaaddress_ofac_size_tadigest_sizelac_ubyteTluError %d while instantiating SHA-3/512aSmartPointeragetakeccak_destroya_stateaupdateuYou can only call 'digest' or 'hexdigest' on this objectakeccak_absorbac_uint8_ptruError %d while updating SHA-3/512uContinue hashing of a message by consuming the next chunk of data.

        Args:
            data (byte string/byte array/memoryview): The next chunk of the message being hashed.
        acreate_string_bufferakeccak_digestaget_raw_buffera_digest_valueuReturn the **binary** (non-printable) digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xaborduReturn the **printable** digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        anewakeccak_copyuError %d while copying SHA3-512uReturn a copy ("clone") of the hash object.

        The copy will have the same internal state as the original hash
        object.
        This can be used to efficiently compute the digests of strings that
        share a common initial substring.

        :return: A hash object of the same type
        uCreate a fresh SHA3-521 hash object.adataapopTaupdate_after_digestFuInitial data for hash specified twiceluUnknown parameters: aSHA3_512_HashuCreate a new hash object.

    Args:
        data (byte string/byte array/memoryview):
            The very first chunk of the message to hash.
            It is equivalent to an early call to :meth:`update`.
        update_after_digest (boolean):
            Whether :meth:`digest` can be followed by another :meth:`update`
            (default: ``False``).

    :Return: A :class:`SHA3_512_Hash` hash object
    a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTaborduCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointeracreate_string_bufferaget_raw_bufferac_size_tac_uint8_ptrac_ubyteaload_pycryptodome_raw_libuCrypto.Hash.keccakTa_raw_keccak_libTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.SHA3_512a__module__uA SHA3-512 hash object.
    Do not instantiate directly.
    Use the :func:`new` function.

    :ivar oid: ASN.1 Object ID
    :vartype oid: string

    :ivar digest_size: the size in bytes of the resulting hash
    :vartype digest_size: integer
    a__qualname__l@u2.16.840.1.101.3.4.2.10aoidlHablock_sizea__init__uSHA3_512_Hash.__init__uSHA3_512_Hash.updateuSHA3_512_Hash.digestahexdigestuSHA3_512_Hash.hexdigestacopyuSHA3_512_Hash.copyTnuSHA3_512_Hash.newa__orig_bases__uCrypto\Hash\SHA3_512.pyu<module Crypto.Hash.SHA3_512>Ta__class__Taselfadataaupdate_after_digestastatearesultTaselfaclonearesultTaselfabfraresultTaselfTaargsakwargsadataaupdate_after_digestTaselfadataTaselfadataaresult.Crypto.Hash.SHA512#`a_truncateu2.16.840.1.101.3.4.2.3aoidl@adigest_sizeu224u2.16.840.1.101.3.4.2.5lu256u2.16.840.1.101.3.4.2.6l uIncorrect truncation length. It must be '224' or '256'.aVoidPointera_raw_sha512_libaSHA512_initaaddress_ofac_size_tuError %d while instantiating SHA-512aSmartPointeragetaSHA512_destroya_stateaupdateaSHA512_updateac_uint8_ptruError %d while hashing data with SHA512uContinue hashing of a message by consuming the next chunk of data.

        Args:
            data (byte string/byte array/memoryview): The next chunk of the message being hashed.
        acreate_string_bufferaSHA512_digestuError %d while making SHA512 digestaget_raw_bufferuReturn the **binary** (non-printable) digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xaborduReturn the **printable** digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        aSHA512HashaSHA512_copyuError %d while copying SHA512uReturn a copy ("clone") of the hash object.

        The copy will have the same internal state as the original hash
        object.
        This can be used to efficiently compute the digests of strings that
        share a common initial substring.

        :return: A hash object of the same type
        uCreate a fresh SHA-512 hash object.uCreate a new hash object.

    Args:
      data (bytes/bytearray/memoryview):
        Optional. The very first chunk of the message to hash.
        It is equivalent to an early call to :meth:`SHA512Hash.update`.
      truncate (string):
        Optional. The desired length of the digest. It can be either "224" or
        "256". If not present, the digest is 512 bits long.
        Passing this parameter is **not** equivalent to simply truncating
        the output digest.

    :Return: A :class:`SHA512Hash` hash object
    laSHA512_pbkdf2_hmac_assistuError %d with PBKDF2-HMAC assist for SHA512uCompute the expensive inner loop in PBKDF-HMAC.a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTaborduCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointeracreate_string_bufferaget_raw_bufferac_size_tac_uint8_ptraload_pycryptodome_raw_libTuCrypto.Hash._SHA512u
                        int SHA512_init(void **shaState,
                                        size_t digest_size);
                        int SHA512_destroy(void *shaState);
                        int SHA512_update(void *hs,
                                          const uint8_t *buf,
                                          size_t len);
                        int SHA512_digest(const void *shaState,
                                          uint8_t *digest,
                                          size_t digest_size);
                        int SHA512_copy(const void *src, void *dst);

                        int SHA512_pbkdf2_hmac_assist(const void *inner,
                                            const void *outer,
                                            const uint8_t *first_digest,
                                            uint8_t *final_digest,
                                            size_t iterations,
                                            size_t digest_size);
                        TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.SHA512a__module__uA SHA-512 hash object (possibly in its truncated version SHA-512/224 or
    SHA-512/256.
    Do not instantiate directly. Use the :func:`new` function.

    :ivar oid: ASN.1 Object ID
    :vartype oid: string

    :ivar block_size: the size in bytes of the internal message block,
                      input to the compression function
    :vartype block_size: integer

    :ivar digest_size: the size in bytes of the resulting hash
    :vartype digest_size: integer
    a__qualname__lablock_sizea__init__uSHA512Hash.__init__uSHA512Hash.updateuSHA512Hash.digestahexdigestuSHA512Hash.hexdigestacopyuSHA512Hash.copyTnanewuSHA512Hash.newa__orig_bases__Tnna_pbkdf2_hmac_assistuCrypto\Hash\SHA512.pyu<module Crypto.Hash.SHA512>Ta__class__TaselfadataatruncateastatearesultTainneraouterafirst_digestaiterationsabfraresultTaselfaclonearesultTaselfabfraresultTaselfTadataatruncateTaselfadataTaselfadataaresult.Crypto.Hash<aupperTu1.3.14.3.2.26aSHA1uSHA-1uTaSHA1laSHA1lanewTu2.16.840.1.101.3.4.2.4aSHA224uSHA-224TaSHA224aSHA224Tu2.16.840.1.101.3.4.2.1aSHA256uSHA-256TaSHA256aSHA256Tu2.16.840.1.101.3.4.2.2aSHA384uSHA-384TaSHA384aSHA384Tu2.16.840.1.101.3.4.2.3aSHA512uSHA-512TaSHA512aSHA512Tu2.16.840.1.101.3.4.2.5uSHA512-224uSHA-512-224Tu224TatruncateTu2.16.840.1.101.3.4.2.6uSHA512-256uSHA-512-256Tu256Tu2.16.840.1.101.3.4.2.7uSHA3-224uSHA-3-224TaSHA3_224aSHA3_224Tu2.16.840.1.101.3.4.2.8uSHA3-256uSHA-3-256TaSHA3_256aSHA3_256Tu2.16.840.1.101.3.4.2.9uSHA3-384uSHA-3-384TaSHA3_384aSHA3_384Tu2.16.840.1.101.3.4.2.10uSHA3-512uSHA-3-512TaSHA3_512aSHA3_512uUnknown hash %suReturn a new hash instance, based on its name or
    on its ASN.1 Object IDa__doc__a__file__apathadirnameajoinaenvironagetTaNUITKA_PACKAGE_Cryptou\not_existingaHashTaNUITKA_PACKAGE_Crypto_Hashu\not_existinga__path__a__spec__aoriginahas_locationasubmodule_search_locationsa__cached__LaHMACaMD2aMD4aMD5aRIPEMD160aSHA1aSHA224aSHA256aSHA384aSHA512aSHA3_224aSHA3_256aSHA3_384aSHA3_512aCMACaPoly1305acSHAKE128acSHAKE256aKMAC128aKMAC256aTupleHash128aTupleHash256aKangarooTwelveaTurboSHAKE128aTurboSHAKE256a__all__uCrypto\Hash\__init__.pyu<module Crypto.Hash>T
anameaSHA1aSHA224aSHA256aSHA384aSHA512aSHA3_224aSHA3_256aSHA3_384aSHA3_512.Crypto.Hash.keccakh_adigest_sizea_update_after_digesta_digest_donela_paddingaVoidPointera_raw_keccak_libakeccak_initaaddress_ofac_size_tlac_ubyteTluError %d while instantiating keccakaSmartPointeragetakeccak_destroya_stateaupdateuYou can only call 'digest' or 'hexdigest' on this objectakeccak_absorbac_uint8_ptruError %d while updating keccakuContinue hashing of a message by consuming the next chunk of data.

        Args:
            data (byte string/byte array/memoryview): The next chunk of the message being hashed.
        acreate_string_bufferakeccak_digestuError %d while squeezing keccakaget_raw_bufferuReturn the **binary** (non-printable) digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xaborduReturn the **printable** digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        adigest_bytesadigest_bitsanewakwargsuCreate a fresh Keccak hash object.adataapopTaupdate_after_digestFTadigest_bytesnTadigest_bitsnuOnly one digest parameter must be providedTnnuDigest size (bits, bytes) not providedTll l0l@u'digest_bytes' must be: 28, 32, 48 or 64Tllllu'digest_bytes' must be: 224, 256, 384 or 512luUnknown parameters: aKeccak_HashuCreate a new hash object.

    Args:
        data (bytes/bytearray/memoryview):
            The very first chunk of the message to hash.
            It is equivalent to an early call to :meth:`Keccak_Hash.update`.
        digest_bytes (integer):
            The size of the digest, in bytes (28, 32, 48, 64).
        digest_bits (integer):
            The size of the digest, in bits (224, 256, 384, 512).
        update_after_digest (boolean):
            Whether :meth:`Keccak.digest` can be followed by another
            :meth:`Keccak.update` (default: ``False``).

    :Return: A :class:`Keccak_Hash` hash object
    a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTabordluCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointeracreate_string_bufferaget_raw_bufferac_size_tac_uint8_ptrac_ubyteaload_pycryptodome_raw_libTuCrypto.Hash._keccaku
                        int keccak_init(void **state,
                                        size_t capacity_bytes,
                                        uint8_t rounds);
                        int keccak_destroy(void *state);
                        int keccak_absorb(void *state,
                                          const uint8_t *in,
                                          size_t len);
                        int keccak_squeeze(const void *state,
                                           uint8_t *out,
                                           size_t len,
                                           uint8_t padding);
                        int keccak_digest(void *state,
                                          uint8_t *digest,
                                          size_t len,
                                          uint8_t padding);
                        int keccak_copy(const void *src, void *dst);
                        int keccak_reset(void *state);
                        TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.keccaka__module__uA Keccak hash object.
    Do not instantiate directly.
    Use the :func:`new` function.

    :ivar digest_size: the size in bytes of the resulting hash
    :vartype digest_size: integer
    a__qualname__a__init__uKeccak_Hash.__init__uKeccak_Hash.updateuKeccak_Hash.digestahexdigestuKeccak_Hash.hexdigestuKeccak_Hash.newa__orig_bases__uCrypto\Hash\keccak.pyu<module Crypto.Hash.keccak>Ta__class__Taselfadataadigest_bytesaupdate_after_digestastatearesultTaselfabfraresultTaselfTakwargsadataaupdate_after_digestadigest_bytesadigest_bitsTaselfakwargsTaselfadataaresult.Crypto.Protocol.KDF8aSHA1atobytesanewadigest_sizeuSelected hash algorithm has a too short digest (%d bytes).uSalt is not 8 bytes long (%d bytes instead).aiter_rangelapHashadigestuDerive one key from a password (or passphrase).

    This function performs key derivation according to an old version of
    the PKCS#5 standard (v1.5) or `RFC2898
    <https://www.ietf.org/rfc/rfc2898.txt>`_.

    Args:
     password (string):
        The secret password to generate the key from.
     salt (byte string):
        An 8 byte string to use for better protection from dictionary attacks.
        This value does not need to be kept secret, but it should be randomly
        chosen for each derivation.
     dkLen (integer):
        The length of the desired key. The default is 16 bytes, suitable for
        instance for :mod:`Crypto.Cipher.AES`.
     count (integer):
        The number of iterations to carry out. The recommendation is 1000 or
        more.
     hashAlgo (module):
        The hash algorithm to use, as a module or an object from the :mod:`Crypto.Hash` package.
        The digest length must be no shorter than ``dkLen``.
        The default algorithm is :mod:`Crypto.Hash.SHA1`.

    Return:
        A byte string of length ``dkLen`` that can be used as key.
    u'prf' and 'hmac_hash_module' are mutually exlusiveahmac_hash_modulea_pbkdf2_hmac_assistu<lambda>uPBKDF2.<locals>.<lambda>alinkuPBKDF2.<locals>.linkcakeyaprfapasswordasaltastructapacku>IwilareduceastrxoraHMACacopyaupdateacountuDerive one or more keys from a password (or passphrase).

    This function performs key derivation according to the PKCS#5 standard (v2.0).

    Args:
     password (string or byte string):
        The secret password to generate the key from.

        Strings will be encoded as ISO 8859-1 (also known as Latin-1),
        which does not allow any characters with codepoints > 255.
     salt (string or byte string):
        A (byte) string to use for better protection from dictionary attacks.
        This value does not need to be kept secret, but it should be randomly
        chosen for each derivation. It is recommended to use at least 16 bytes.

        Strings will be encoded as ISO 8859-1 (also known as Latin-1),
        which does not allow any characters with codepoints > 255.
     dkLen (integer):
        The cumulative length of the keys to produce.

        Due to a flaw in the PBKDF2 design, you should not request more bytes
        than the ``prf`` can output. For instance, ``dkLen`` should not exceed
        20 bytes in combination with ``HMAC-SHA1``.
     count (integer):
        The number of iterations to carry out. The higher the value, the slower
        and the more secure the function becomes.

        You should find the maximum number of iterations that keeps the
        key derivation still acceptable on the slowest hardware you must support.

        Although the default value is 1000, **it is recommended to use at least
        1000000 (1 million) iterations**.
     prf (callable):
        A pseudorandom function. It must be a function that returns a
        pseudorandom byte string from two parameters: a secret and a salt.
        The slower the algorithm, the more secure the derivation function.
        If not specified, **HMAC-SHA1** is used.
     hmac_hash_module (module):
        A module from ``Crypto.Hash`` implementing a Merkle-Damgard cryptographic
        hash, which PBKDF2 must use in combination with HMAC.
        This parameter is mutually exclusive with ``prf``.

    Return:
        A byte string of length ``dkLen`` that can be used as key material.
        If you want multiple keys, just break up this string into segments of the desired length.
    utoo many values to unpack (expected 2)lwsu<genexpr>uPBKDF2.<locals>.<genexpr>a_copy_bytesa_keya_ciphermoddablock_sizea_last_stringa_cachela_n_updatesa_cipher_paramsuInitialize the S2V PRF.

        :Parameters:
          key : byte string
            A secret that can be used as key for CMACs
            based on ciphers from ``ciphermod``.
          ciphermod : module
            A block cipher module from `Crypto.Cipher`.
          cipher_params : dictionary
            A set of extra parameters to use to create a cipher instance.
        a_S2VuCreate a new S2V PRF.

        :Parameters:
          key : byte string
            A secret that can be used as key for CMACs
            based on ciphers from ``ciphermod``.
          ciphermod : module
            A block cipher module from `Crypto.Cipher`.
        abytes_to_longabordllalong_to_bytesuToo many components passed to S2VaCMACTamsgaciphermodacipher_paramsa_doubleuPass the next component of the vector.

        The maximum number of components you can pass is equal to the block
        length of the cipher (in bits) minus 1.

        :Parameters:
          item : byte string
            The next component of the vector.
        :Raise TypeError: when the limit on the number of components has been reached.
        :nln:lnndb:nlnu"Derive a secret from the vector of components.

        :Return: a byte string, as long as the block length of the cipher.
        luToo much secret data to deriveTadigestmodatlenaprkwtlacontextwBwnahashmodaappendakey_lenuDerive one or more keys from a master secret using
    the HMAC-based KDF defined in RFC5869_.

    Args:
     master (byte string):
        The unguessable value used by the KDF to generate the other keys.
        It must be a high-entropy secret, though not necessarily uniform.
        It must not be a password.
     key_len (integer):
        The length in bytes of every derived key.
     salt (byte string):
        A non-secret, reusable value that strengthens the randomness
        extraction step.
        Ideally, it is as long as the digest size of the chosen hash.
        If empty, a string of zeroes in used.
     hashmod (module):
        A cryptographic hash algorithm from :mod:`Crypto.Hash`.
        :mod:`Crypto.Hash.SHA512` is a good choice.
     num_keys (integer):
        The number of keys to derive. Every key is :data:`key_len` bytes long.
        The maximum cumulative length of all keys is
        255 times the digest size.
     context (byte string):
        Optional identifier describing what the keys are used for.

    Return:
        A byte string or a tuple of byte strings.

    .. _RFC5869: http://tools.ietf.org/html/rfc5869
    abit_sizeuN must be a power of 2quN is too bigqup or r are too biguscrypt.<locals>.<lambda>aPBKDF2Taprfa_raw_scrypt_libascryptROMixa_raw_salsa20_libaSalsa20_8_corewracreate_string_bufferac_size_twNacoreuError %X while running scryptadata_outaget_raw_bufferuDerive one or more keys from a passphrase.

    Args:
     password (string):
        The secret pass phrase to generate the keys from.
     salt (string):
        A string to use for better protection from dictionary attacks.
        This value does not need to be kept secret,
        but it should be randomly chosen for each derivation.
        It is recommended to be at least 16 bytes long.
     key_len (integer):
        The length in bytes of each derived key.
     N (integer):
        CPU/Memory cost parameter. It must be a power of 2 and less
        than :math:`2^{32}`.
     r (integer):
        Block size parameter.
     p (integer):
        Parallelization parameter.
        It must be no greater than :math:`(2^{32}-1)/(4r)`.
     num_keys (integer):
        The number of keys to derive. Every key is :data:`key_len` bytes long.
        By default, only 1 key is generated.
        The maximum cumulative length of all keys is :math:`(2^{32}-1)*32`
        (that is, 128TB).

    A good choice of parameters *(N, r , p)* was suggested
    by Colin Percival in his `presentation in 2009`__:

    - *( 2, 8, 1 )* for interactive logins (100ms)
    - *( 2, 8, 1 )* for file encryption (5s)

    Return:
        A byte string or a tuple of byte strings.

    .. __: http://www.tarsnap.com/scrypt/scrypt-slides.pdf
    aSHA256:lnnazfillTlabitsabstrl:nlnaresultu./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789uatostrafindTlluIncorrect length:nln:nlnabchruCrypto.CipherTa_EKSBlowfisha_EKSBlowfishuThe password is too long. It must be 72 bytes at most.lubcrypt cost factor must be in the range 4..31aMODE_ECB;ll@lacipheraencryptactextuutf-8TluThe password contains the zero byteaget_random_bytesTlubcrypt salt must be 16 bytes longa_bcrypt_hashcOrpheanBeholderScryDoubtd$Tla_bcrypt_encodec$2auHash a password into a key, using the OpenBSD bcrypt protocol.

    Args:
      password (byte string or string):
        The secret password or pass phrase.
        It must be at most 72 bytes long.
        It must not contain the zero byte.
        Unicode strings will be encoded as UTF-8.
      cost (integer):
        The exponential factor that makes it slower to compute the hash.
        It must be in the range 4 to 31.
        A value of at least 12 is recommended.
      salt (byte string):
        Optional. Random byte string to thwarts dictionary and rainbow table
        attacks. It must be 16 bytes long.
        If not passed, a random value is generated.

    Return (byte string):
        The bcrypt hash

    Raises:
        ValueError: if password is longer than 72 bytes or if it contains the zero byte

   uIncorrect length of the bcrypt hash: %d bytes instead of 60:nlnc$2a$uUnsupported prefixareacompileTc\$2a\$([0-9][0-9])\$([A-Za-z0-9./]{22,22})([A-Za-z0-9./]{31,31})amatchuIncorrect bcrypt hash formatagroupTluIncorrect costa_bcrypt_decodeabcryptaBLAKE2slTadigest_bitsakeyadatauIncorrect bcrypt hashuVerify if the provided password matches the given bcrypt hash.

    Args:
      password (byte string or string):
        The secret password or pass phrase to test.
        It must be at most 72 bytes long.
        It must not contain the zero byte.
        Unicode strings will be encoded as UTF-8.
      bcrypt_hash (byte string, bytearray):
        The reference bcrypt hash the password needs to be checked against.

    Raises:
        ValueError: if the password does not match
    TduNull byte found in labeluNull byte found in contextadkalabelakey_len_encamasterquOverflow in SP800 108 counteruDerive one or more keys from a master secret using
    a pseudorandom function in Counter Mode, as specified in
    `NIST SP 800-108r1 <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-108r1.pdf>`_.

    Args:
     master (byte string):
        The secret value used by the KDF to derive the other keys.
        It must not be a password.
        The length on the secret must be consistent with the input expected by
        the :data:`prf` function.
     key_len (integer):
        The length in bytes of each derived key.
     prf (function):
        A pseudorandom function that takes two byte strings as parameters:
        the secret and an input. It returns another byte string.
     num_keys (integer):
        The number of keys to derive. Every key is :data:`key_len` bytes long.
        By default, only 1 key is derived.
     label (byte string):
        Optional description of the purpose of the derived keys.
        It must not contain zero bytes.
     context (byte string):
        Optional information pertaining to
        the protocol that uses the keys, such as the identity of the
        participants, nonces, session IDs, etc.
        It must not contain zero bytes.

    Return:
        - a byte string (if ``num_keys`` is not specified), or
        - a tuple of byte strings (if ``num_key`` is specified).
    a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTatobytesaborda_copy_bytesaiter_rangeatostrabchrabstruCrypto.HashTaSHA1aSHA256aHMACaCMACaBLAKE2suCrypto.Util.strxorTastrxoruCrypto.RandomTaget_random_bytesuCrypto.Util.numberTasizealong_to_bytesabytes_to_longasizeuCrypto.Util._raw_apiTaload_pycryptodome_raw_libacreate_string_bufferaget_raw_bufferac_size_taload_pycryptodome_raw_libTuCrypto.Cipher._Salsa20u
                    int Salsa20_8_core(const uint8_t *x, const uint8_t *y,
                                       uint8_t *out);
                    TuCrypto.Protocol._scryptu
                    typedef int (core_t)(const uint8_t [64], const uint8_t [64], uint8_t [64]);
                    int scryptROMix(const uint8_t *data_in, uint8_t *data_out,
                           size_t data_len, unsigned N, core_t *core);
                    TlnaPBKDF1TllnnTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Protocol.KDFa__module__uString-to-vector PRF as defined in `RFC5297`_.

    This class implements a pseudorandom function family
    based on CMAC that takes as input a vector of strings.

    .. _RFC5297: http://tools.ietf.org/html/rfc5297
    a__qualname__Tna__init__u_S2V.__init__astaticmethodu_S2V.newu_S2V._doubleu_S2V.updateaderiveu_S2V.derivea__orig_bases__TlnaHKDFascryptabcrypt_checkTncpaSP800_108_CounteruCrypto\Protocol\KDF.pyTa.0wjalinkwsTwpwsTwpwsahmac_hash_moduleTahmac_hash_moduleu<module Crypto.Protocol.KDF>Tamasterakey_lenasaltahashmodanum_keysacontextaoutput_lenahmacaprkwtwnatlenaderived_outputakolTapasswordasaltadkLenacountahashAlgoapHashadigestwiTapasswordasaltadkLenacountaprfahmac_hash_modulealinkakeywiwsabaseafirst_digestTamasterakey_lenaprfanum_keysalabelacontextakey_len_encaoutput_lenwiadkainfoakolTa__class__Taselfakeyaciphermodacipher_paramsT
adatawsabitswcaidxabits6amodulo4abits8aresultwgTadatawsabitswcabits_cabits6aresultwgaidxTapasswordacostasaltaconstantainverta_EKSBlowfishacipheractextw_TaselfabsadoubledTapasswordacostasaltactextacost_encasalt_encahash_encT
apasswordabcrypt_hashwpwracostasaltabcrypt_hash2asecretamac1amac2TaselfafinalapaddedamacTwsaprfapasswordTapasswordaprfTakeyaciphermodTapasswordasaltakey_lenwNwrwpanum_keysaprf_hmac_sha256astage_1ascryptROMixacoreadata_outaflowaidxabuffer_outaresultadkakolTaselfaitemamac.Crypto.ProtocolHa__doc__a__file__apathadirnameajoinaenvironagetTaNUITKA_PACKAGE_Cryptou\not_existingaProtocolTaNUITKA_PACKAGE_Crypto_Protocolu\not_existinga__path__a__spec__aoriginahas_locationasubmodule_search_locationsa__cached__aKDFaSecretSharingaDHa__all__uCrypto\Protocol\__init__.pyu<module Crypto.Protocol>u.Crypto.RandomI3aurandomuReturn a random byte string of the desired size.a_UrandomRNGuReturn a file-like object that outputs cryptographically random bytes.a__doc__a__file__apathadirnameajoinaenvironagetTaNUITKA_PACKAGE_Cryptou\not_existingaRandomTaNUITKA_PACKAGE_Crypto_Randomu\not_existinga__path__a__spec__aoriginahas_locationasubmodule_search_locationsa__cached__anewaget_random_bytesa__all__lTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Randoma__module__a__qualname__areadu_UrandomRNG.readuMethod provided for backward compatibility only.aflushu_UrandomRNG.flushareinitu_UrandomRNG.reinitacloseu_UrandomRNG.closea__orig_bases__aatforkuCrypto\Random\__init__.pyu<module Crypto.Random>Ta__class__TaselfTaargsakwargsTaselfwnu.Crypto.Util._cpu_featuresa_raw_cpuid_libahave_aes_niahave_clmula__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util._raw_apiTaload_pycryptodome_raw_liblaload_pycryptodome_raw_libTuCrypto.Util._cpuid_cu
                                           int have_aes_ni(void);
                                           int have_clmul(void);
                                           uCrypto\Util\_cpu_features.pyu<module Crypto.Util._cpu_features>u.Crypto.Util._file_systemilaCryptouOnly available for modules under 'Crypto':lnnasplitaabspatha__file__utoo many values to unpack (expected 2)ajoinu..uReturn the complete file name for the module

    dir_comps : list of string
        The list of directory names in the PyCryptodome package.
        The first element must be "Crypto".

    filename : string
        The filename (inclusing extension) in the target directory.
    a__doc__a__spec__aoriginahas_locationa__cached__aosapycryptodome_filenameuCrypto\Util\_file_system.pyu<module Crypto.Util._file_system>Tadir_compsafilenameautil_libw_aroot_libu.Crypto.Util._raw_api
affiaRTLD_DEEPBINDaosagetenvTaPYCRYPTODOME_DISABLE_DEEPBINDadlopenacdefuLoad a shared library and return a handle to it.

        @name,  either an absolute path or the name of a library
                in the system search path.

        @cdecl, the C function declarations.
        uConvert a Python integer to unsigned longuConvert a Python integer to size_tamaxanewuuint8_t[]:nnnuSize must be specified once onlyaresultuAllocate the given amount of bytes (initially set to 0)astringuConvert a C string into a Python byte sequenceabufferuConvert a C buffer into a Python byte sequencea_buffer_typeacastauint8_t_typeafrom_bufferabyte_stringa_ArrayuObject type %s cannot be passed to C codeTuvoid *[1]a_pplaVoidPointer_cffilactypesac_ubyteacached_architectureaplatformaarchitectureutoo many values to unpack (expected 2)w.astartswithTaWinafind_libraryuCannot load library '%s'aCDLLavaluearawa_py_objecta_Py_buffera_PyObject_GetBufferabyrefa_PyBUF_SIMPLEalenafrom_addressabufa_PyBuffer_Releaseac_void_pa_paVoidPointer_ctypesa_raw_pointera_destructorasplitTw.:nlnlaextension_suffixesabasenameapycryptodome_filenameadir_compsapathaisfileaattemptsaappenduNot found '%s'aload_libacdecluCannot load '%s': %safilenameuCannot load native module '%s': %su, uLoad a shared library and return a handle to it.

    @name,  the name of the library expressed as a PyCryptodome module,
            for instance Crypto.Cipher._raw_cbc.

    @cdecl, the C function declarations.
    TObytesObytearrayOmemoryviewuReturn True if object x supports the buffer interfaceareadonlya__doc__a__file__a__spec__aoriginahas_locationa__cached__aabcasysuCrypto.Util.py3compatTabyte_stringuCrypto.Util._file_systemTapycryptodome_filenameamachineryaEXTENSION_SUFFIXESTObytearrayOmemoryviewTOobjecta__prepare__a_VoidPointera__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Util._raw_apia__module__a__qualname__aabstractmethoduReturn the memory location we point toagetu_VoidPointer.getuReturn a raw pointer to this pointeraaddress_ofu_VoidPointer.address_ofa__orig_bases__aflagsaoptimizeluCFFI with optimize=2 fails due to pycparser bug.acffiTaFFIaFFIaNULLanull_pointeratypeofTuconst uint8_t*Tuuint8_t[1]a__bases__ac_ulongac_ulonglongac_uintac_size_tTnacreate_string_bufferaget_c_stringaget_raw_bufferac_uint8_ptruModel a newly allocated pointer to voida__init__uVoidPointer_cffi.__init__uVoidPointer_cffi.getuVoidPointer_cffi.address_ofaVoidPointerabackenductypes.utilTafind_libraryaArrayac_ssize_ta_c_ssize_tapythonapiaPyObject_GetBufferaPyBuffer_Releaseapy_objectaPOINTERa_c_ssize_paStructureaobjaitemsizeac_intandimaformatac_char_pashapeastridesasuboffsetsainternala_fields_uVoidPointer_ctypes.__init__uVoidPointer_ctypes.getuVoidPointer_ctypes.address_ofaSmartPointeruClass to hold a non-managed piece of memoryuSmartPointer.__init__uSmartPointer.getareleaseuSmartPointer.releasea__del__uSmartPointer.__del__aload_pycryptodome_raw_libais_bufferais_writeable_bufferuCrypto\Util\_raw_api.pyu<module Crypto.Util._raw_api>Ta__class__TaselfTaselfaraw_pointeradestructorTwxTwcTadataTadataaobjabufabuffer_typeTainit_or_sizeasizearesultTac_stringTabufTanameacdeclalibTanameacdeclaplatformabitsalinkageafull_nameT
anameacdeclasplitadir_compsabasenameaattemptsaextafilenameafull_nameaexpTaselfarpu.Crypto.UtiluMiscellaneous modules

Contains useful modules that don't belong into any of the
other Crypto.* subpackages.

========================    =============================================
Module                      Description
========================    =============================================
`Crypto.Util.number`        Number-theoretic functions (primality testing, etc.)
`Crypto.Util.Counter`       Fast counter functions for CTR cipher modes.
`Crypto.Util.RFC1751`       Converts between 128-bit keys and human-readable
                            strings of words.
`Crypto.Util.asn1`          Minimal support for ASN.1 DER encoding
`Crypto.Util.Padding`       Set of functions for adding and removing padding.
========================    =============================================

:undocumented: _galois, _number_new, cpuid, py3compat, _raw_api
a__doc__a__file__apathadirnameajoinaenvironagetTaNUITKA_PACKAGE_Cryptou\not_existingaUtilTaNUITKA_PACKAGE_Crypto_Utilu\not_existinga__path__a__spec__aoriginahas_locationasubmodule_search_locationsa__cached__LaRFC1751anumberastrxoraasn1aCounteraPaddinga__all__uCrypto\Util\__init__.pyu<module Crypto.Util>u.Crypto.Util.numberluNon positive valuesutoo many values to unpack (expected 2)luReturn ceil(n/d), that is, the smallest integer r such that r*d >= nuSize in bits only available for non-negative numbersabit_lengthuReturns the size of the number N in bits.aRandomaget_random_bytesllTlastructapackwBabytes_to_longuReturn a random number at most N bits long.

    If :data:`randfunc` is omitted, then :meth:`Random.get_random_bytes` is used.

    .. deprecated:: 3.0
        This function is for internal use only and may be renamed or removed in
        the future. Use :func:`Crypto.Random.random.getrandbits` instead.
    asizeagetRandomIntegeravalueabitsarandfuncuReturn a random number *n* so that *a <= n < b*.

    If :data:`randfunc` is omitted, then :meth:`Random.get_random_bytes` is used.

    .. deprecated:: 3.0
        This function is for internal use only and may be renamed or removed in
        the future. Use :func:`Crypto.Random.random.randrange` instead.
    luReturn a random number with exactly N-bits,
    i.e. a random number between 2**(N-1) and (2**N)-1.

    If :data:`randfunc` is omitted, then :meth:`Random.get_random_bytes` is used.

    .. deprecated:: 3.0
        This function is for internal use only and may be renamed or removed in
        the future.
    uModulus cannot be zerouModulus cannot be negativeTllav3au3av1au1uNo inverse value can be computedwvuThe inverse of :data:`u` *mod* :data:`v`.uN must be larger than 1agetRandomNBitIntegerwNaisPrimeTarandfuncuReturn a random N-bit prime number.

    N must be an integer larger than 1.
    If randfunc is omitted, then :meth:`Random.get_random_bytes` is used.
    wnwmwbaiter_rangeaminagetRandomRangewaatestedaappendapowwzu_rabinMillerTest(n:long, rounds:int, randfunc:callable):int
    Tests if n is prime.
    Returns 0 when n is definitely composite.
    Returns 1 when n is probably prime.
    Returns 2 when n is definitely prime.

    If randfunc is omitted, then Random.new().read is used.

    This function is for internal use only and may be renamed or removed in
    the future.
    a_fastmathagetStrongPrimealongllubits must be multiple of 128 and > 512amathaceilalogTllg+YqkBlg+#Tllleasieve_basewyafielda_rabinMillerTestarabin_miller_roundswparesultuCouln't find prime in field. Developer: Increase field_sizeainversewXweaGCDaincrementu
    Return a random strong *N*-bit prime number.
    In this context, *p* is a strong prime if *p-1* and *p+1* have at
    least one large prime factor.

    Args:
        N (integer): the exact length of the strong prime.
          It must be a multiple of 128 and > 512.
        e (integer): if provided, the returned prime (minus 1)
          will be coprime to *e* and thus suitable for RSA where
          *e* is the public exponent.
        false_positive_prob (float):
          The statistical probability for the result not to be actually a
          prime. It defaults to 10\ :sup:`-6`.
          Note that the real probability of a false-positive is far less. This is
          just the mathematically provable limit.
        randfunc (callable):
          A function that takes a parameter *N* and that returns
          a random byte string of such length.
          If omitted, :func:`Crypto.Random.get_random_bytes` is used.
    Return:
        The new strong prime.

    .. deprecated:: 3.0
        This function is for internal use only and may be renamed or removed in
        the future.
    uTest if a number *N* is a prime.

    Args:
        false_positive_prob (float):
          The statistical probability for the result not to be actually a
          prime. It defaults to 10\ :sup:`-6`.
          Note that the real probability of a false-positive is far less.
          This is just the mathematically provable limit.
        randfunc (callable):
          A function that takes a parameter *N* and that returns
          a random byte string of such length.
          If omitted, :func:`Crypto.Random.get_random_bytes` is used.

    Return:
        `True` is the input is indeed prime.
    uValues must be non-negativeabsrainsertu>Qg+l@lu>Iql u>BldcalstripTduConvert a positive integer to a byte string using big endian encoding.

    If :data:`blocksize` is absent or zero, the byte string will
    be of minimal length.

    Otherwise, the length of the byte string is guaranteed to be a multiple
    of :data:`blocksize`. If necessary, zeroes (``\x00``) are added at the left.

    .. note::
        In Python 3, if you are sure that :data:`n` can fit into
        :data:`blocksize` bytes, you can simply use the native method instead::

            >>> n.to_bytes(blocksize, 'big')

        For instance::

            >>> n = 80
            >>> n.to_bytes(2, 'big')
            b'\x00P'

        However, and unlike this ``long_to_bytes()`` function,
        an ``OverflowError`` exception is raised if :data:`n` does not fit.
    aunpackaaccwsvConvert a byte string to a long integer (big endian).

    In Python 3.2+, use the native method instead::

        >>> int.from_bytes(s, 'big')

    For instance::

        >>> int.from_bytes(b'P', 'big')
        80

    This is (essentially) the inverse of :func:`long_to_bytes`.
    awarningsawarnTulong2str() has been replaced by long_to_bytes()along_to_bytesTustr2long() has been replaced by bytes_to_long()a__doc__a__file__a__spec__aoriginahas_locationa__cached__asysaCryptoTaRandomuCrypto.Util.py3compatTaiter_rangeaceil_divTnagcdagetPrimeTlf>nTf>nTlalong2strastr2longTNllllll
llllll%l)l+l/l5l;l=lClGlIlOlSlYlalelglklmlqlllllllllllllllllllllllllll
lllll%l3l7l9l=lKlQl[l]lalglolul{llllllllllllllllllllllllll#l-l3l9l;lAlKlQlWlYl_lelilklwlllllllllllllllllllllllll)l+l5l7l;l=lGlUlYl[l_lmlqlslwllllllllllllllllllllllll%l'l-l?lClElIlOlUl]lclillllllllllllllllllllllllll'l)l/lQlWl]lelwllllllllllllllllllllll
llll#l+l/l=lAlGlIlMlSlUl[lelyllllllllllllllllllllll'l7lElKlOlQlUlWlalmlslyllllllllllllllllllll!l#l'l)l3l?lAlQlSlYl]l_lilqllllllllllllllllllll#l%l+l/l5lClIlMlOlUlYl_lklqlwllllllllllllllll
l
l!
l1
l9
l=
lI
lW
la
lc
lg
lo
lu
l{
l
l
l
l
l
l
l
l
l
l
l
l
l
l
l
l
l
l
l
l
lllll#l)l-l?lGlQlWl]lelol{lllllllllllllllllll%l/l1lAl[l_lalmlslwlllllllllllllllll
l
l
l
l
l!
l+
l-
l=
l?
lO
lU
li
ly
l
l
l
l
l
l
l
l
l
l
l
l
l
l
l
l
l
l
l
l
llll!l'l/l5l;lKlWlYl]lklqlul}lllllllllllllllll
ll%l)l1lClGlMlOlSlYl[lglkllllllllllllllllllll!l%l+l9l=l?lQlilslyl{llllllllllllllllllll'l-l9lElGlYl_lclilolllllllllllllllll
lll#l)l+l1l7lAlGlSl_lqlslyl}llllllllllllll
ll'l-l7lClElIlOlWl]lglilml{llllllllllllllllllll!l/l3l;lElMlYlklolqlulllllllllllllllll%l)l+l7l=lAlClIl_lelglkl}lllllllllllllllllllll%l3l9l=lElOlUlilmlolulllllllllllllllllllll#l'l3lAl]lclwl{llllllllllllllllllll5l7l;lClIlMlUlglqlwl}llllllllllllllllllllll1l3lElIlQl[lylllllllllllllllllll!l#l-l/l5l?lMlQlilkl{l}llllllllllllllllll#l%l/l1l7l;lAlGlOlUlYlelklsllllllllllllllll'l+l-l3l=lElKlOlUlslllllllllllllll!l#l5l9l?lAlKlSl]lclilqlul{l}lllllllllllllllllllll%l+l/l=lIlMlOlmlqlllllllllllllllll
lll9lIlKlQlglul{llllllllllllllll l l l' l) l- l3 lG lM lQ l_ lc le li lw l} l l l l l l l l l l l l l l
!l!l5!lA!lI!lO!lY!l[!l_!ls!l}!l!l!l!l!l!l!l!l!l!l!l!l!l!l!l!l!l"l"l"l"l!"l%"l+"l1"l9"lK"lO"lc"lg"ls"lu"l"l"l"l"l"l"l"l"l"l"l"l"l"l"l#l#l#l'#l)#l/#l3#l5#lE#lQ#lS#lY#lc#lk#l#l#l#l#l#l#l#l#l#l#l#l#l#l#l#l$l$l$l$l)$l=$lA$lC$lM$l_$lg$lk$ly$l}$l$l$l$l$l$l$l$l$l$l$l$l$l$l$l$l$l$l%l%l%l%l'%l1%l=%lC%lK%lO%ls%l%l%l%l%l%l%l%l%l%l%l%l%l%l%l%l&l&l&l&l'&l)&l5&l;&l?&lK&lS&lY&le&li&lo&l{&l&l&l&l&l&l&l&l&l&l&l&l&l&l&l'l'l5'l7'lM'lS'lU'l_'lk'lm'ls'lw'l'l'l'l'l'l'l'l'l'l'l'l'l'l(l(l
(l(l(l(l!(l1(l=(l?(lI(lQ(l[(l](la(lg(lu(l(l(l(l(l(l(l(l(l(l(l(l(l)l)l)l!)l#)l?)lG)l])le)li)lo)lu)l)l)l)l)l)l)l)l)l)l)l)l)l)l)l)l*l*l*l%*l/*lO*lU*l_*le*lk*lm*ls*l*l*l*l*l*l*l*l*l*l*l*l*l*l*l+l'+l1+l3+l=+l?+lK+lO+lU+li+lm+lo+l{+l+l+l+l+l+l+l+l+l+l+l+l+l+l,l,l,l#,l/,l5,l9,lA,lW,lY,li,lw,l,l,l,l,l,l,l,l,l,l,l,l,l,l,l,l-l-l-l;-lC-lI-lM-la-le-lq-l-l-l-l-l-l-l-l-l-l-l.l.l.l
.l.l.l%.l-.l3.l7.l9.l?.lW.l[.lo.ly.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l/l/l/l/l'/l)/lA/lE/lK/lM/lQ/lW/lo/lu/l}/l/l/l/l/l/l/l/l/l/l/l/l/l/l/l0l
0l#0l)0l70l;0lU0lY0l[0lg0lq0ly0l}0l0l0l0l0l0l0l0l0l0l0l0l0l0l0l0l0l1l1l1l!1l'1l-1l91lC1lE1lK1l]1la1lg1lm1ls1l1l1l1l1l1l1l1l1l1l1l1l1l1l2l2l2l2l)2l52lY2l]2lc2lk2lo2lu2lw2l{2l2l2l2l2l2l2l2l2l2l2l2l2l2l2l2l3l%3l+3l/3l53lA3lG3l[3l_3lg3lk3ls3ly3l3l3l3l3l3l3l3l3l3l3l3l3l4l4l4l4l4l74lE4lU4lW4lc4li4lm4l4l4l4l4l4l4l4l4l4l4l4l4l4l5l5l5l-5l35l;5lA5lQ5le5lo5lq5lw5l{5l}5l5l5l5l5l5l5l5l5l5l5l5l5l5l5l6l6l6l#6l16l56l76l;6lM6lO6lS6lY6la6lk6lm6l6l6l6l6l6l6l6l6l6l6l6l7l7l7l7l?7lE7lI7lO7l]7la7lu7l7l7l7l7l7l7l7l7l7l7l7l8l8l!8l38l58lA8lG8lK8lS8lW8l_8le8lo8lq8l}8l8l8l8l8l8l8l8l8l8l8l8l8l8l9l9l#9l%9l)9l/9l=9lA9lM9l[9lk9ly9l}9l9l9l9l9l9l9l9l9l9l9l9l9l9l9l9l9l9l:l:l:l:l':l+:l1:lK:lQ:l[:lc:lg:lm:ly:l:l:l:l:l:l:l:l:l:l:l:l;l;l;l!;l#;l-;l9;lE;lS;lY;l_;lq;l{;l;l;l;l;l;l;l;l;l;l;l;l;l;l;l;l;l;l<l
<l<l<l<l)<l5<lC<lO<lS<l[<le<lk<lq<l<l<l<l<l<l<l<l<l<l<l<l<l=l
=l=l=l=l!=l-=l3=l7=l?=lC=lo=ls=lu=ly=l{=l=l=l=l=l=l=l=l=l=l=l=l=l>l>l>l>l>l#>l)>l/>l3>lA>lW>lc>le>lw>l>l>l>l>l>l>l>l>l>l>l>l>l>l>l>l?l
?l7?l;?l=?lA?lY?l_?le?lg?ly?l}?l?l?l?l?l?l?l?l?l?l?l?l@l!@l%@l+@l1@l?@lC@lE@l]@la@lg@lm@l@l@l@l@l@l@l@l@l@l@l@l@lAlAlAlAl!Al3Al5Al;Al?AlYAleAlkAlwAl{AlAlAlAlAlAlAlAlAlAlAlBlBlBlBl#Bl)Bl/BlCBlSBlUBl[BlaBlsBl}BlBlBlBlBlBlBlBlBlBlBlBlBlBlClClCl%Cl'Cl3Cl7Cl9ClOClWCliClClClClClClClClClClClClClClClClClDlDlDl#Dl)Dl;Dl?DlEDlKDlQDlSDlYDleDloDlDlDlDlDlDlDlDlDlDlDlDlDlDlElElEl+El1ElAElIElSElUElaElwEl}ElElElElElElElElElElElElElFlFlFlFl%Fl'Fl3Fl9Fl=FlCFlEFl]FlyFl{FlFlFlFlFlFlFlFlFlFlFlFlFlFlFlFlGlGlGl#Gl)Gl/Gl5Gl9GlKGlMGlQGl]GloGlqGl}GlGlGlGlGlGlGlGlGlGlGlGlGlGlHlHlHlHlHlHl1Hl=HlGHlUHlYHl[HlkHlmHlyHlHlHlHlHlHlHlHlHlIl
IlIlIl+Il7Il=IlEIlUIlcIliIlmIlsIlIlIlIlIlIlIlIlIlJlJlJl#Jl9JlAJlEJlWJl]JlkJl}JlJlJlJlJlJlJlJlJlJlJlJlKlKl
KlKlKl%Kl1Kl;KlCKlIKlYKleKlmKlwKlKlKlKlKlKlKlKlKlKlKlKlKlKlKlKlLlLl
LlLlLlLl!Ll-Ll3LlKLlULlWLlaLlgLlsLlyLlLlLlLlLlLlLlLlLlLlLlMlMlMl'Ml)Ml/Ml3MlAMlQMlYMleMlkMlMlMlMlMlMlMlMlMlMlMlMlMlMlMlNlNlNlNlNl+Nl5Nl7Nl=NlONlSNl_NlgNlyNlNlNlNlNlNlNlNlNlNlNlNlNlNlNlNlOlOlOl%Ol-Ol?OlIOlcOlgOlmOluOl{OlOlOlOlOlOlOlOlOlOlOlOlOlOlOlPlPlPl)Pl5Pl?PlEPlGPlSPlqPlwPlPlPlPlPlPlPlPlPlPlPlPlQlQl
QlQlQl#Ql%Ql5QlGQlIQlqQlyQlQlQlQlQlQlQlQlQlQlQlQlQlQlQlRlRlRlRlRlRl'RlCRlERlKRlaRlmRlsRlRlRlRlRlRlRlRlRlRlRlRlRlRlRlRlSlSl#SlASlESlGSlKSl]SlcSlSlSlSlSlSlSlSlSlSlSlSlSlSlSlSlSl
TlTlTlTl5Tl7Tl;TlATlITlSTlUTl_TlaTlkTlmTlqTlTlTlTlTlTlTlTlTlTlTlTlTlUl
UlUl'Ul+Ul9Ul=UlOUlQUl[UlcUlgUloUlyUlUlUlUlUlUlUlUlUlUlUlUlVlVlVlVl#Vl/Vl3Vl9Vl?VlKVlMVl]Vl_VlkVlqVluVlVlVlVlVlVlVlVlVlVlVlVlWlWlWlWlWlWl#WlGWlMWl_WlaWlmWlwWl}WlWlWlWlWlWlWlWlWlWlWlXl
XlXlXl'Xl+Xl-XlUXl[Xl]XlmXloXlsXl{XlXlXlXlXlXlXlXlXlXlXlXlXlXlXlXlYlYlYl!YlEYlKYlMYlWYl]YluYl{YlYlYlYlYlYlYlYlYlYlYlYlYlYlYlZl
ZlZlZlZlZl)Zl/Zl;ZlMZl[ZlgZlwZlZlZlZlZlZlZlZlZlZlZlZlZlZl[l[l[l[l%[l+[l=[lI[lK[lg[ly[l[l[l[l[l[l[l[l[l[l[l\l\l\l\l\l)\l/\l3\l9\lG\lK\lM\lQ\lo\lu\lw\l}\l\l\l\l\l\l\l\l\l\l\l\l\l]l]l]l]l]l1]l=]lA]lG]lO]lU]l[]le]lg]lm]ly]l]l]l]l]l]l]l]l]l]l]l]l]l]l^l
^l^l^l!^l'^l+^l-^l1^l9^lE^lI^lW^li^ls^lu^l^l^l^l^l^l^l^l^l^l_l_l'_l3_l5_l;_lG_lW_l]_lc_le_lw_l{_l_l_l_l_l_l_l_l_l_l_l_l`l#`l/`l7`lS`l_`le`lk`ls`ly`l`l`l`l`l`l`l`l`l`l`lalalalal-al9alKalUalWal[aloalyalalalalalalalalalalalalalblblbl!bl'bl;blAblKblQblSbl_bleblblblblblblblblblblblblblblblcl
clclcl/clAclCclOcl_clgclmclqclwcl}clclclclclclclclclcldldldldl!dl'dl+dl9dlCdlIdlOdl]dlgdludldldldldldldldldldldldldldlelel!el/el9el?elKelMelSelWel_elqel}elelelelelelelelelelelelelflflfl)fl1fl;flAflGflMfl[flaflsfl}flflflflflflflflflflflflflflglglglgl'gl1gl7gl?glEglQgl[gloglyglglglglglglglglglglhlhlhlhl-hl9hl;hl?hlEhlKhlMhlWhlYhl]hlchlihlkhlqhlhlhlhlhlhlhlhlhlhlhlhlhlilil
ilil)il/ilCilGilIilOileilkilqilililililililililililililililjl+jl7jl=jlKjlgjlijlujl{jljljljljljljljljljlklklkl#kl'kl-kl9klAklWklYkl_kluklklklklklklklklklklklklllll)ll+ll1ll5llUllYll[ll_llellgllsllwll}llllllllllllllllllllllllllllll
mlml%ml'ml+ml1ml9ml?mlOml]mlamlsml{mlmlmlmlmlmlmlmlmlmlmlmlmlnlnlnl)nl3nl;nlEnlunlwnl{nlnlnlnlnlnlnlnlnlnlnlnlnl
olololol/ol=olMolSolaoleolyol}olololololololololololololololololololololplplpl'pl3pl9plOplQplWplcpluplyplplplplplplplplplplplplplplqlql!ql3qlQqlYql]ql_qlcqliqlqlqlqlqlqlqlqlqlqlqlqlqlqlrlrlrlrl%rl/rl;rlCrlUrlgrlqrlwrlrlrlrlrlrlrlrlrlrlrlrlrlrlrlrlsl
sl!sl+sl=slWsl[slaslslslslslslslslslslslslslslsltltl-tl9tl?tlAtl]tlktl{tltltltltltltltltltltltltlulul%ul;ul=ulMul_ulkulwulululululululululululululululululvlvl!vl-vl3vl=vl?vlUvlcvlivlovlsvlvlvlvlvlvlvlvlvlvlwlwlwlwl!wl-wl5wlAwlKwlYwl]wl_wlqwlwlwlwlwlwlwlwlwlwlwlwlwlwlxl%xl+xl5xl=xlSxlYxlaxlmxlwxlyxlxlxlxlxlxlxlxlxlxlxlxlxlxlylyl%yl+yl9yl?ylKylWyl]ylgyliylsylylylylylylylylylylylylylylylylzlzlzlzlzl#zl'zl-zlKzlWzlYzl_zlezlizl}zlzlzlzlzlzlzlzlzl{l{l{l{l+{l5{l7{l;{lO{lU{l_{lq{lw{l{l{l{l{l{l{l{l{l{l{l{l{l{l|l|l|l1|l7|lI|lg|li|ls|l|l|l|l|l|l|l|l|l|l}l}l}l}l3}l9}l;}l?}lE}lM}lS}lY}lc}lu}lw}l}l}l}l}l}l}l}l}l}l}l}l}l~l~l)~l+~l/~l5~lA~lC~lG~lU~la~lg~lk~lq~ls~ly~l}~l~l~l~l~l~l~l~l~l~l~l~l~l~llll1l3l9l=lClKl[lalclmlylllllllllllllll!l#l?lAlGlKlelwlllllllllllllllll
lll/l1l;lClSlYl_l}lllllllllllllll%l1l3l?lClElIlOlalol{llllllllllllllll!l)l-l3l5l?lAlMlQlSlWl]lelilollllllllllllllll#l%l;lAlGlOlalelwlllllllllllll
lKlOlQl]lclmlol{llllllllllllllllll!l/l9l?lAlMlclul}llllllllllllllllll+l/l5lGlYl[lklqlwlllllllllllllllll!l7l=lClQlalgl{lllllllllllllll#l'l-l9lElMlQlWlcllllllllllllllll#l5lAlIlOl[l_lmlwlylllllllllllllll
ll!lWl]lllllllllllllllll'l9l;lGlSl]lol{lllllllllllllllll
l#l)l7lAl[l_lqlylllllllllllllllll%lQlclilslulyllllllllllllllllll#l-l?lElKlSlYlelilqllllllllllllllll
ll#l%l1l7l;lAlClOlSlmlslllllllllllllll'l3l=lElOlQlalgl{llllllllllllllll!l/lAlGlWlklqlul}llllllllllllllllllllll;l=lClUlslllllllllllllll?lElKlOlclglilml{lllllllllll!l'l-l5l9lKlWl]l_lullllllllllllllll/l1l5l;l=lellllllllllllll
lll%l+l3l7l9lClIlQl[l]lolllllllllllllllll)l/l;lAlQlklollllllllllllllll
lll)l1l;l=lAlGlIlSl}llllllllllllllllll%lKlOlUlWlalulllllllllllllll'l/l5lElQlYlclolwlllllllllllllllll#l+l/l5lIlMl_lelglllllllllllllllll'l-l1l=lUl[lallllllllllll#l'l-l3l;lGlQlSl_lolllllllllllll#l/l7l;lClSlalmlslwl}lllllllllllllll
l!l3l9l?lOlWl[lalulyllllllllllllllllllll)l/l5lAlSlul}llllllllllllll#l)l/l1lClGlMlklyl}llllllllllllllllll!l+l1lIlQlUlslyl{lllllllllllllllllll!l#l'l;lMlWlYlclilullllllllllllllll)l+l5l;lClSl[lalmlwllllllllllllllllllll
l%l=lIlKlQl]lslllllllllllllllllll#l)l-lElMlWlYlelklollllllllllllllll)l+l7l;lUl_lml}lllllllllllll1l7l9lCllllllllllllllll5l9l;lGlMlWlYl]lklqlllllllllllllll
lllMl[lqlslllllllllllllllllll'l7l9lElOlWl[lalcllllllllllllllllll?lElSl]l_lellllllllllllllll#l+lIlMlOlYlalglklqllllllllllllllll'l+l3lClOlWl]lmlulllllllllllllll?lAlGlKlQlSlil{l}lllllllllllllllll1lAlMl[lelslylllllllllllllll-l?lIl[lclilml{llllllllllllllll'l-l?lElwl}lllllllllllll
lll5l=lClIl[lelglklwlllllllllllll
ll-l?lKlglilolslyllllllllllllllll)l/l3l9lGlWlYl_lclolllllllllllllll
lll)l5lGlUlmllllllllllllll!l'l+l-l9lUlglullllllllllllllllll/l9l;lGlQlclllllllllllllllll
ll%l)l+lAlSlUl_lalelyl}lllllllllllllll'l-l=lClKlOl[lalilmlllllllllllll#l3l;lAlEl]lolwllllllllllll
llll5lAlOlYl_lalglklqllllllllllllllll!l%l'l[l]lolulyllllllllllllllllll3l9lMl]l_lklql{llllllllllllllllll)l/l1l7l;lGlelml}lllllllllllllllll+l3l7lElIl[lslyl{lllllllllllllll!l/l?lKlMlSl]lwl{l}lllllllllllllllll%lGlIlOlelglqlllllllllllllllllll-l3l7lUlWlalolslllllllllllllllllAlGlQl_lklolulwllllllllllll#l5lAlOlUlYlellllllllllllll
lll-l1l9lWlclglslulllllllllllllll'l)l9l?lSlWlkllllllllllllllllllllll/l7l=lAlSl_lklyl}llllllllllllllll%l7l9lKlUl[lilslulllllllllllllllll)l5l;lSlYlclelqlllllllllllll
lll#l+lAlClMlYlalllllllllllll%l1l=l?lIlQlWl[lclgllllllllllllllll!l/lGlMlQlel{l}lllllllllllllllll7l;lMlUl_lalelmlyl}llllllllllllllll!l3l=lKlOlilollllllllllllll-l/lAlWlYl]lilklqlwl}llllllllllll
llll5l;lGlYlalelylllllllllllllllll!l+lClKlUlilul{llllllllllll'l/l3l;lKlYl_lclillllllllllllllllll
lll#l1l5l7lIlYl_lelglwllllllllllllll-l1lClUl]lal{llllllllllllllll!l'l?lElMlWlkl{lllllllllllll#l%l)l+l/l7lMlUlglsllllllllllll%l3l9lClElOlQlWlmlolslylllllllllllllllllll#l)l?lQlYl]l_lqlwl{l}lllllllllllll#l%l1l;lClUlglklsllllllllllll
l'l1l9l?lIlQlalolul{lllllllllllllllllll#l5l9lSlWl_lilol}lllllllllllllllll)l;l=lAlMlOlYl[lalmlwl}llllllllllllllll+l3l7l=lKlUl[lglilslllllllllllllllll'l-l5lElSlql{llllllllllll%l)l1l5lClOlYlalmlqlwllllllllllllllllll+l-l=lClWl[lulylllllllllllllll#l'l)l9l;lMlQlWl_lclilulwl}lllllllllllll#l+l1l;lGlIlSlUlmlqllllllllllll!l%l7l?lElKlWlglmlullllllllllll!l)l9l?lSlWlclolullllllllllllllllll
lll/l=lGlIlSlUlalglklllllllllllllllll1l3l7l=lKlOlQlilulyllllllllllllllll-l3l;lKlQl_lclil{lllllllllll/l5lClMl_lmlql}lllllllllllllllll1l9l?l[lalclollllllllllllll!l)lMlQl]lilol{llllllllllllllll/l7l=lAlUlYl[lelklyllllllllllllllll!lIlOlclglsl{lllllllllll'l/lElMlclklqllllllllllllllll+l/l5lClGlOlglklqlwlyllllllllllllllllll!l7l=lUlul{llllllllllllll#l'l3l;lAlWl_lelilwlllllllllllllllllAlYl[l_lglslwllllllllll
ll!l%l+lElKlUlclullllllllllllllll!l)l5lGlQlclkllllllllllllllll
l5l7lSl[lalglyllllllllllll-l1lClOlQlUlclilslyllllllllllllllllll!l'l-l5lGlYlclelolqlwl{lllllllllllllllllll%l1l7l;lAlOl_lalmlqlwlllllllll
ll!l%l?lClQl[lml{llllllllllllll-l/l?lGlMlul}lllllllllll)l7lAlClOlYlalelmlslyllllllllll
lll+l1lQlUlglmlol{lllllllllllllll'l/lAlKlMlWl_lclilul{lllllllllllll
ll+l/lIlMl[lelqllllllllllllllllll+l-l3l?lIlQl]lalolslylllllllllllllll#l'l-l/l3l;lKlYlkllllllllllllllll#l)l7l;l=lYlqlyl}llllllll!l'l+l7l9lElIlOlclmlllllllllllllllll!l)l9lElSl]l{lllllllllllllll#l%l/l=lClIlglklslllllllllllllllll1l9lClElQlUlalmlslulllllllllllllll)l?lGlQlSl]lclelilwl}llllllllllllllllll#l/lCl_lsl}llllllllllllllll
ll+l3l=lWl[l]lclglulylllllllllll
l
l
l-
l3
lA
lK
lo
lq
lu
l{
l
l
l
l
l
l
l
l
ll%l/lUl[l_lalyl}llllllllllllllll3l=lKlOl[lglilyllllllllllll
l
l
l!
l#
l'
l-
l5
l?
lS
lc
l
l
l
l
l
l
l
l
l
l
l
lllll+lGlIlMlSlelqlwllllllllllll
lll3l7l?lQlWl[lalilslulyl{lllllll-l;lAlMlilkllllllllllllllll)l+l5lGlglmlqlslyllllllllllllll
ll!l%l'l7l9l?lOlUl]lalilllllllllllllll'l3l9l;lQlWlYlelklllllllllllllllll5l=lIlalqlllllllllllllllll%l'l-l9lClElOlUlWlclolllllllllllllll)lAlElQlYl]l_lwl}llllllllllllllllll
lll/l1l7l;lOlglql}llllllllll
llll!l'l=lQlalmlllllllllllllllllll#l/l3l9l?lSl_lklolullllllllllllllll#l%l;l=lMlOlUl_lslylllllllll
lll!l-l1l7lUlclglollllllllllllllllll#l;l?l]lqlwllllllllllllllll
ll%l1l5l;lMlOlSlelglwllllllllll+l=lKlWl]lolslllllllllllllll-l3l9lKlQlYlclolul}lllllllllllllll l l+ l7 l[ l_ lw ly l l l l l l l l l l l l!l!!l%!l+!l?!lC!lW!l]!lm!ls!lu!l!l!l!l!l!l!l!l!l!l!l!l!l!l!l"l'"l/"l5"l9"lG"lM"lS"lq"lu"l{"l"l"l"l"l"l"l"l"l"l"l"l#l
#l#l#l##l7#lA#lG#lM#l[#le#lq#ls#l#l#l#l#l#l#l#l#l#l#l#l$l$l$l$l-$lE$lK$lO$l[$li$lm$lu$ly$l$l$l$l$l$l$l$l$l$l%l%l%l%l%l!%lG%lK%le%l}%l%l%l%l%l%l%l%l%l%l%l%l%l%l&l
&l&l+&l;&lA&lI&lS&lY&lg&lq&l}&l&l&l&l&l&l&l&l&l&l'l'l
'l'l'l!'l%'l3'l9'l?'l['la'lc'lm'ly'l'l'l'l'l'l'l'l'l'l'l'l'l'l(l(l(l(l-(l9(lM(l](lk(l(l(l(l(l(l(l(l(l(l(l(l(l(l)l/)l1)l;)lC)lG)l[)la)ls)l})l)l)l)l)l)l)l)l)l)l)l)l*l*l-*l7*lO*lQ*l[*lc*ls*l*l*l*l*l*l*l*l*l*l*l*l*l*l*l+l#+l5+l;+l?+lW+li+lk+l{+l+l+l+l+l+l+l+l+l+l+l,l,l,l,l%,l/,lG,lI,lS,lk,lq,lw,l,l,l,l,l,l,l,l,l,l,l,l
-l-l%-l--lQ-lU-la-lo-ls-l-l-l-l-l-l-l-l-l-l-l-l-l-l.l.l.l#.l'.l/.l9.lA.lG.li.lk.lw.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l/l/l/l/l+/l1/l5/lI/lO/l[/lq/lw/ly/l/l/l/l/l/l/l/l/l/l/l/l/l/l/l0l0l'0l+0lE0lK0li0lm0l0l0l0l0l0l0l0l0l0l0l0l0l1l)1l91l;1lM1lS1lW1l]1lc1lo1lq1l{1l1l1l1l1l1l1l1l1l1l1l2l2l2lA2l[2le2lg2l2l2l2l2l2l2l2l2l2l2l2l2l2l2l3l3l3l33l93l=3lc3li3ls3ly3l3l3l3l3l3l3l3l3l3l3l3l4l4l4l'4l)4l-4l54lG4lQ4l]4l4l4l4l4l4l4l4l4l4l5l5l#5l+5l/5l15l75lM5lS5lY5la5l}5l5l5l5l5l5l5l5l5l5l5l5l5l5l6l6l!6l%6l'6l36l?6lC6lI6l[6ly6l6l6l6l6l6l6l6l6l6l6l6l7l7l7l7l)7l57lG7lK7lM7lQ7lS7l7l7l7l7l7l7l7l7l7l7l7l7l7l7l8l8l8l8l#8lC8lG8l_8le8lk8ls8l}8l8l8l8l8l8l8l8l8l
9l9l9l9l'9l-9l19l?9lO9lQ9l]9lg9li9lo9l{9l9l9l9l9l9l9l9l9l9l9l9l:l:l-:l?:lA:lW:lY:li:lk:l:l:l:l:l:l:l:l:l:l:l:l;l;l;l;l%;l);l+;l/;l=;lI;la;lk;lm;ly;l;l;l;l;l;l;l;l;l;l;l;l<l
<l<l<l<l!<l%<l9<lC<l]<li<lu<ly<l{<l<l<l<l<l<l<l<l<l<l<l<l<l<l=l=l=l=l-=l/=l3=lG=lQ=lW=l=l=l=l=l=l=l=l=l=l=l=l=l=l>l
>l>l1>l7>le>lm>lw>l}>l>l>l>l>l>l>l>l>l>l>l>l>l?l?l
?l?l%?l'?l+?l??lI?lU?la?li?lm?l?l?l?l?l?l?l?l?l?l?l@l@l@l@l!@l/@l3@l5@lS@lW@lY@l]@le@lo@lu@lw@l@l@l@l@l@l@l@l@l@lAl
AlAlAl)Al+Al/Al7Al=AlAAlUAl[AlgAl}AlAlAlAlAlAlAlAlAlAlBlBl%Bl'Bl3Bl7Bl=BlCBlKBlaBlcBluBlBlBlBlBlBlBlBlBlBlBlBlBlCl!Cl#Cl'Cl)ClEClGClKCl]ClcCliCloCl{Cl}ClClClClClClClClClDl%Dl5Dl;DlADlODlgDlsDlwDlDlDlDlDlDlDlDlDlElElElElElEl!El+El9ElCElEElIElcEloElElElElElElElElElElElElElElElFlFlFl)FlQFleFliFlkFl{FlFlFlFlFlFlFlFlFlFlFlFlGlGlGl1Gl=GlAGlOGleGlyGlGlGlGlGlGlGlGlGlGlGlHlHlHl+Hl1HlOHlUHl[Hl]HlcHlyHlHlHlHlHlHlHlHlHlHlHlHlHlHlIlIlIl'IlKIlSIlYIl]Il_Il{Il}IlIlIlIlIlIlIlIlIlIlIlIlIlIlJlJlJlJl)Jl+Jl5JlGJlOJlmJlJlJlJlJlJlJlJlJlJlJlJlJlKlKlKl3Kl9KlIKlKKl[KlyKl{KlKlKlKlKlKlKlKlKlKlKlLlLl#Ll-Ll9LlELlYLl_LlcLleLloLluLlLlLlLlLlLlLlLlLlLlLlLlLlLlMl1Ml7MlAMlSMlUMlqMlsMlyMlMlMlMlMlMlMlMlMlMlMlNl
NlNlNl-NlCNlINl]NlaNlgNlsNluNl{NlNlNlNlNlNlNlNlNlNlNlNlOl!Ol9Ol;OlEOlGOlMOlSOlWOl]OlOlOlOlOlOlOlOlOlPlPl
Pl5Pl=PlCPl_PlaPlePlsPlyPlPlPlPlPlPlPlPlPlPlPlPlPlPlPlQlQlQlQl'Ql3QlEQlOQlQQlUQlaQlcQlmQluQlQlQlQlQlQlQlQlQlQlQlQlRlRlRl!Rl-Rl3Rl;RlGRlcRleRlRlRlRlRlRlRlRlRlRlRlRlSl5Sl;SlCSlISlMSlUSlSlSlSlSlSlSlSlSlSlSlSlSlTlTlTl+Tl?TlCTlOTlQTl]TlmTloTlTlTlTlTlTlTlTlTlTlTlTlTlUlUlUlUl)Ul?UlWUlkUloUl}UlUlUlUlUlUlUlUlUlUlUlUlUlUlVlVlVlVl#Vl%Vl=VlGVlMVlOVlYVl[VlaVlwVlVlVlVlVlVlVlVlVlVlVlVlVlVlVlWlWl-Wl=WlEWlIWlOWlgWlmWl{WlWlWlWlWlWlWlWlWlWlWlWlXlXlXl5XlAXliXlqXlXlXlXlXlXlXlXlXlYlYlYlYl;YlMYl[YlgYlkYlYlYlYlYlYlYlYlYl
ZlZlZl!ZlCZlKZlQZlUZlWZl[ZliZlZlZlZlZlZlZlZlZlZlZlZlZlZlZl[l[l[l#[l)[l3[lA[lG[lW[li[lw[l[l[l[l[l[l[l[l[l[l[l[l[l[l[l
\l\l\l\l#\l1\lA\le\ls\ly\l}\l\l\l\l\l\l\l\l\l\l\l]l]l%]l+]l1]l7]lE]lI]lW]lc]li]ls]l]l]l]l]l]l]l]l]l]l]l]l]l]l]l^l^l^l!^l5^l9^l;^lE^lG^lQ^lY^l^l^l^l^l^l^l^l^l^l^l^l^l_l#_l)_l+_l5_l=_lC_lS_lg_lk_ly_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l_l`l`l%`l3`l=`lK`lO`lU`lW`l[`li`ls`l`l`l`l`l`l`l`l`l`lalalalal!al#al'alEalGalealialqalalalalalalalalalalalalblblbl#bl5bl7blIblOblUblkbl}blblblblblblblblblblclclclcl%cl3clCcl[claclmcluclclclclclclclclclclcldldldldldldl/dl9dl?dl]dledlkdlqdludldldldldldldldldldldldlelelelel)el=elAelCelGeleelkelyelelelelelelelelelelelfl+fl7fl?flUfliflmfl{flflflflflflflflflflflglgl#gl'gl/gl5gl9gl?glAgl]glcgliglglglglglglglglglglgl
hlhlhlhl+hl;hl=hlChlIhlMhlShl[hlmhlhlhlhlhlhlhlhlhlhlhlhlhlhlhlhlhlilil+il-il3il?ilIilWil[ilililililililililililililililjljljljl#jl-jl3jlAjlQjlYjl_jlkjlujlwjljljljljljljljljljljljljljl
klklklkl;klAklIklwkl}klklklklklklklklklklklklklklllll-ll7ll9llCllEllIllOllallcllgll{llllllllllllllllllllllml'ml)ml/ml3ml5ml9ml?mlSmlYmlqmlumlwml{mlmlmlmlmlmlmlnlnlnl+nlAnlCnl[nlqnlsnlnlnlnlnlnlnlnlnlnlnlnlnlnlolololol-ol7ol9olQolaolioloololololololololololololplpl-pl5plAplSplcpleplqplwpl{plplplplplplplplplplplplplpl
qlql1qlAqlCqlMqlOqlSql_qlaqlmqlwqlqlqlqlqlqlqlqlqlqlrlrlrl3rl9rl=rlErlIrl[rlcrlgrlurlyrlrlrlrlrlrlrlrlrlrlrlslslsl!sl-sl3slWsl_slksloslqslusl}slslslslslslslslslslslslsltltltltl#tl)tl/tl7tlOtlUtl_tlktltltltltltltltltltltltltltltlul'ul+ul3ul=ulIulQul]ulmulsulululululululululululululvlvl'vl-vl/vl9vl;vlEvlKvlqvl}vlvlvlvlvlvlvlvlvlvlvlvlvlvlwl
wlwl+wl5wl;wlOwlawlwlwlwlwlwlwlwlwlwlwlwlxlxl
xlxl!xl%xlCxlIxlKxlQxlaxlyxlxlxlxlxlxlxlxlxlxlxlxlxlylyl)yl-ylEylKylMylYylylylylylylylylylylylylylzlzlzlzlzl5zl7zl;zlOzlSzlYzl}zlzlzlzlzlzlzlzlzlzlzlzlzlzl{l1{l9{lO{l]{lg{l{l{l{l{l{l{l{l{l{l{l{l|l|l|l/|lW|lY|l]|lc|le|lk|lu|l|l|l|l|l|l|l|l|l|l|l}l
}l}l}l#}l)}l+}l/}lG}lI}lM}lq}ls}l}l}l}l}l}l}l}l}l~l%~l1~l3~l7~l9~lC~lE~lO~lW~l[~l~l~l~l~l~l~l~l~l~l~l~l~l~ll!l5lKlQl_lllllllllll
llll+lAlIlSlUlglklsl}llllllllllllll
l%l=lClOlQlglmllllllllllllll!l3l5l9lGlMlQlSl]l_lolql{llllllllllllllll%l/l;l=lAlClMlelmlwllllllllllll'l+l1l?lElIlQlglolllllllllllllll'l;lMlSl_lil{l}lllllllllllllllll%l)l=lClSlYlylllllllllll
l!l7l9lIlWl]lalolullllllllllllll'l)l3l;lAl_lklulllllllllllllll
l)l=lAlUl[l_l}llllllllllll+l1l?lClIlOl]lul{llllllllllllllll'l)l5l?lMlSlWlYlellllllllllllllll#l+l5lIl[lelklql}lllllllllllllllll1l=lElWl[lilmlslullllllllllllll!l)l3lElKlYlclolql}lllllllllllllllll%l/l5l7l;lIlUlYlalklmlsllllllllllll!l%l3l=lQlalclgl{llllllllllllllllll-lilklqllllllllllllll)l7lGlYl_lllllllllllllll1l?lElyl{llllllllllllll!l/l;lWlil}llllllllllllllllll+lYlklyllllllllllllll!l+l-l7l9l=lClIlUlalolul{llllllllllllll'l)l/l3lYl_lilulwllllllllllllll+lAlOlYl_lelglqlllllllllllllll
lluCrypto\Util\number.pyu<module Crypto.Util.number>Twnaroundsarandfuncan_1wbwmatestedwiwawzacompositewrTwsaaccaunpackalengthaextrawiTwnwdwrwqTwNarandfuncanumberTwNarandfuncwSaodd_bitsarand_bitsavalueTwNarandfuncavalueTwawbarandfuncarange_abitsavalueTwNweafalse_positive_probarandfuncarabin_miller_roundswxalower_boundaupper_boundwXwpwiwyafieldaprimeaoffsetwjaresultacompositeatmpatmp1atmp2wRaincrementais_possible_primeTwuwvau3av3au1av1wqTwNafalse_positive_probarandfuncwparoundsTwnablocksizeTwnablocksizearesultapackabsrabresultatarget_lenTwNTwsu.Crypto.Util.py3compat,aencodeTulatin-1ulatin-1atobytesadecodeuReturn an immutable copy of a sequence (byte string, byte array, memoryview)
    in a certain interval [start:seq]uCompatibility code for handling string/bytes changes from Python 2.x to Py3k

In Python 2.x, strings (of type ''str'') contain binary data, including encoded
Unicode text (e.g. UTF-8).  The separate type ''unicode'' holds Unicode text.
Unicode literals are specified via the u'...' prefix.  Indexing or slicing
either type always produces a string of the same type as the original.
Data read from a file is always of '''str'' type.

In Python 3.x, strings (type ''str'') may only contain Unicode text. The u'...'
prefix and the ''unicode'' type are now redundant.  A new type (called
''bytes'') has to be used for binary data (including any particular
''encoding'' of a string).  The b'...' prefix allows one to specify a binary
literal.  Indexing or slicing a string produces another string.  Slicing a byte
string produces another byte string, but the indexing operation produces an
integer.  Data read from a file is of '''str'' type if the file was opened in
text mode, or of ''bytes'' type otherwise.

Since PyCrypto aims at supporting both Python 2.x and 3.x, the following helper
functions are used to keep the rest of the library as independent as possible
from the actual Python version.

In general, the code should always deal with binary strings, and use integers
instead of 1-byte character strings.

b(s)
    Take a text string literal (with no prefix or with u'...' prefix) and
    make a byte string.
bchr(c)
    Take an integer and make a 1-character byte string.
bord(c)
    Take the result of indexing on a byte string and make an integer.
tobytes(s)
    Take a text string, a byte string, or a sequence of character taken from
    a byte string and make a byte string.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__asysaabclwbabchrabstrabordatostrabyte_stringaconcat_buffersaBytesIOaStringIOqamaxintaiter_rangeais_native_intais_stringais_bytesTaABCaABCaFileNotFoundErrora_copy_bytesuCrypto\Util\py3compat.pyu<module Crypto.Util.py3compat>TastartaendaseqTwsTwawbTwxTwsaencodingTabsu.Crypto.Util.strxor%uOnly byte strings of equal length can be xoredacreate_string_bufferais_writeable_bufferuoutput must be a bytearray or a writeable memoryviewuoutput must have the same length as the input  (%d bytes)a_raw_strxorastrxorac_uint8_ptrac_size_taoutputaget_raw_bufferuFrom two byte strings of equal length,
    create a third one which is the byte-by-byte XOR of the two.

    Args:
      term1 (bytes/bytearray/memoryview):
        The first byte string to XOR.
      term2 (bytes/bytearray/memoryview):
        The second byte string to XOR.
      output (bytearray/memoryview):
        The location where the result will be written to.
        It must have the same length as ``term1`` and ``term2``.
        If ``None``, the result is returned.
    :Return:
        If ``output`` is ``None``, a new byte string with the result.
        Otherwise ``None``.

    .. note::
        ``term1`` and ``term2`` must have the same length.
    lluc must be in range(256)astrxor_catermuFrom a byte string, create a second one of equal length
    where each byte is XOR-red with the same value.

    Args:
      term(bytes/bytearray/memoryview):
        The byte string to XOR.
      c (int):
        Every byte in the string will be XOR-ed with this value.
        It must be between 0 and 255 (included).
      output (None or bytearray/memoryview):
        The location where the result will be written to.
        It must have the same length as ``term``.
        If ``None``, the result is returned.

    Return:
        If ``output`` is ``None``, a new ``bytes`` string with the result.
        Otherwise ``None``.
    uVery fast XOR - check conditions!a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util._raw_apiTaload_pycryptodome_raw_libac_size_tacreate_string_bufferaget_raw_bufferac_uint8_ptrais_writeable_bufferaload_pycryptodome_raw_libTuCrypto.Util._strxoru
                    void strxor(const uint8_t *in1,
                                const uint8_t *in2,
                                uint8_t *out, size_t len);
                    void strxor_c(const uint8_t *in,
                                  uint8_t c,
                                  uint8_t *out,
                                  size_t len);
                    Tna_strxor_directuCrypto\Util\strxor.pyu<module Crypto.Util.strxor>Taterm1aterm2aresultTaterm1aterm2aoutputaresultTatermwcaoutputaresultu.Cryptoa__doc__a__file__apathadirnameaenvironagetTaNUITKA_PACKAGE_Cryptou\not_existinga__path__a__spec__aoriginahas_locationasubmodule_search_locationsa__cached__uCrypto\__init__.pyu<module Crypto>u.__main__#1a__mro_entries__abasesa__iter__a__getitem__u%s argument after * must be an iterable, not %sa__name__TMMu()u objectakeysu%s argument after ** must be a mapping, not %sacalledastar_arg_dictaargsakwu%s got multiple values for keyword argument '%s'lla__doc__a__file__a__cached__a__annotations__aargparseactypesabase64apickleawintypesuCrypto.RandomTaget_random_bytesaget_random_bytesuCrypto.CipherTaChaCha20aChaCha20ab64decodeTcIHV6Suvxv3Dp8wx0UHohSmX9GjMsChExHNMbOZgl28w=akeyTcYSd+ix9ZEjKiFgNSanonceanewTakeyanonceacipheraloadsadecryptTcJ1DwxWPZIvbduuowYTdGRY5uvZdg12qFO81uoaDofwFafkpvxNad1zppupeckhdCOcWTY31BoeiusBvOE+wo646bJbEIAhCfbF832FNJ8KSLbYt9dH7DYQdPedx5l1hEo3a/t9S40sCNKBxfc76QXDtywId54wSaYOII7UJeL39fm15D48UOh+6iqlqf9Rvv4LINIMXEsP1TFZ+L8dRyJBV2nhjz15KX+GyoMyPrbHl1/FBYqXrSiRddGFKsTQuoVQg6MBzAsvYWJyR1g54F26i/z5RjdtsriVpbzBLPLZPDdF9GpoCpkeDGx8JwkXgbyIwKF6s/hgwNcIhlvKLyyd0c96iXUoHPnxSss9stilRwtjDXuR6Ra/lMgAvbh5CALfJfkbn7/yBFuULf06buoUg3shZBEsLCh7YpNV+2rovaPQN/4yeoffdXh5aZeRlFm4zj9iB1AMc0Sah45ObClcVu1TNBJwIhnm8J3pFSfT2V98Meat0uN2lI8/uEljIKGXmYVLkfHJP/zXD38KjsokFo9y3via1+ijmLfISDJvuorz7J4N4geW9YLjRc0u+owAb3LvRGWOGtRscHxm5CkDUi0NmJ8+jF9R43JIHh39PeFmDR3KFUWKBnGPTXH/2188SZQBC66UdyQnQJOgaz6d05Go9sgNKiirjrdxVgittwVNOZ7DWMvh0F7HdgiHzLdcBWXUd3xrNNaUC354FpHg6yxAc3n/bG1pr3LY3PncG4yczesErwcgD8E/G5MFsVSaWjjr7G+f3RSNb/IpQ2N5Pxo3VoUoWSDd7/cwJeOHgbgplzA2sp1w6bap6fKkMolA2YSVgFa/S2jp+bh/aqs/Ul+qdE0N0ARmWT2FTc9qGZ8zDpkluhaxlG9T7ZlojAunig4Avu40hKXMC6WsQrnpj+TBpZdwCR9CXrwauuNcpKmBwEwifce0L2839p4yrtnnT05ph9bTcNo2N56TPFrssHBsO7ngJMZLhd8OkJfmuAumhVUV5ghvmPESK7k0IOcJ2rbOaOKBuCebw+Ctyq+LWSQLgpctbinCLTyUmifsn/hUWJvF72N/VTla9pleeR9hVpqVgocRRpG3xC/zzpwyuGol1hfe9UVNO+utjWwinETizKN6DiST1RgPWKPlRGoQ7RGyQNO07N9+Wf+XeE8vbxd39aqfLPakpmWfd1udpOC0fjZiNlp0kyNFR9SmBRNv6HJrzGfUgxJHGoCUl7pOUdYiwQV/eXFLZ6qDTmyGL37nmrU7VCrIDwAV8fGTzZpcqT7xIhUMljU5KjqSE9BxmFawfhggsPQhsiaUtYyFluMkRDS5rOuGaqjVF1e5NYL3nVRJ/2JDTXPxrJIJPlw7v1iZGtvqKKYgik9Qg3c5jaO6q+dZPj6bGN1eSqVbwafSAU/bjIEUJD7cjkkB+Lp3FAtZbaJVhRHEAFWm8S7MjCbg6xpEh9YeSM/9dIJGZKzROt0YeBUnorzVPQNYKrUfKP1nAZOJnjwTOGXCK3H8BRD2yqFy0ROqMnrqRubWiM6ZLqSpS1U7W26NHe/nCTO4DMlUF9Pz9MkS6Zf48/DURhMckx83NTi2rkpdcArMMN64fEm/AyXxtmSsxFdayFVwqfcwMRL8UjWbXkYEzo+ZRaJPqzyezMWkXoJ1iZq8vH70BX6JnC6zeNojJjWPNXNUnuP4WrSbzSsZ3kdf/gTLBQyg0xfTUsoLXuvU1aHXt3FthkUhAVfnMQAvNYSvrHwpXgXFkbC17xC71z8Bql/BobctpYm9ZAQJpd3SFrd5TRCzZ3S5lELjdFAV3S3zojXkHUSnmyAMlebjfeWxVswk4cQ3UOyOBpsEdg5VcTXhCKLIIqsbSdzhumt9u5FbGPJ3lvfrhqN87qunQg+KycZXm3eVzaoTRXjURTu3Zv5pfhvsADESpZ77Ih75H+FgbjAfVnHOvMPadrWL8fVNbjRZalJe0TEOhlmY3bJzovWTmxKfs4qNXKc/r4KtdG21jHHFE64IRNt9Co3tiYg/3WR7iU+XFy+UklY6xRTgbY4SGfNsneqWnnrtl/T23cf4FXpsYBI+yvvYOTns3BDZREHH+AztI1vtlPe1O74C38wBzUsIbzT2syr+zghYFwVUAwNvhtCO9PGJFlasmRtcWSzCV/NEli/rk0XxInSXQXcU6A6m87lbtji8tR7kqILvBtqhT/VG7Sz/xZUZg05WUvo/2XR8lM6zfljC2nNXRyC+IyYyv0aaickKOmqUdrjJ+WITcd10NK1cxqS6ZeW15X/77w1uOYQLrKcyqHMElMOcJ7Nl+VOSfW3xxFVdikzJXc27S3Rc6e71H/RUtLAWaWJ0W+RVugGggBnPVRaXJFG05Wx7Mola0Is5VYRL5PYDjKGo17wh91dSrbkZcTZ3zqLCxNa5hNPyAqwHxs1SVZZ3hFSi01lAu2D7X+dysW9ZS7Bk53idYtJz9ywuQJaxN+aPWFU4cjXe6RgvPwc0u0j6bpgJFoVCYdfqjwMXGFeQmwDoBOm/BRsi8WWdyRTaTFNnJa/IAXKo/2WFGJcyv/Kkfsg1RLosL4c/Ssc4wMMA01uik2ALODPpwZ5Xn+YiP75DirSJBVQzvcxJZ6nnhVncq5ytO18K/IxuqMjDcgJbjH9XD5UtDEKz+EbMY0eiHeEg8YAOnL+KCamB7c/aK0tjKWZ7pdsmmjbfxlLH/zVjND9nRB198HqVW0wBB22U/Zuqb7hXfzbST/HHzmBpWi4Aq+0Y+xiTmpcvUtbAVD63otcj5WQuH7gO59Za5UHoHwaw4nh4zXhyUZ3w2gqfWG316hMXknSo4dsnNG+4dX4kx4WyWGpG7KXBg697UqVDolOTIUs4zFwgnx9fm7bxiNcHRTUq+mifaVs0e50O9emv32NfgqsFQE++1bP4UDHvVv47UtiMPfRz3Mcjr0VdHpFvz4JnwdiS9dMumceGPd9RHbFF2U+1ib8jXAkSqYEgXk4VfWIzhZbCnvwquF8xuEK+PKn9BSlS9PuEoP+39G6yRF/eLoXCd9mZsTwjqhogEL97CkK8Af1/RZCfxnLn977Qzi4XSPEwjrFu4tzQCP/uyQBFCE5+8tZ+FyNAGj1rcPmMgXh4ksz8VD9vaTVx5fz8K0mNYLftjm/g3W99WlFk3Mx/bBDs5uedGt6H+aEve8hp9hkT5FoaJu5bq+oRl112ihT/MyBK1mRf21aDBEdHPD/nTqKf3DaErgcp3jLhI3ZqZmbdoG6flsl2VkRVbK82bvIPjzG3TiXlt0hs//LJRAex+ct3HTolPh2vH0ALihoBlUXo8e+QWAatwtlntV6/TJ6OtfAM56gzrvXhBB2c8ZeUjmOcxq4BcaOSz4eOUshbmI15mAmGM0JU4k8138I7CCVOi4UOKrXJ/bxVLTsxug832fhVC1fRERApj0fBsCIMABHWqiwVjhRH8Xtjma1ebK6GETHdpuGV8CUHhS3U6PI/0DfnQkKnX7e2Rf7bwX9SnVx5YS9dN63aGEcqYmRpURbH4bITDwfZ+EjWIyQq4K9OCrOni4xkOOMXy0dhnmCIE8MLX54p1orhMMGC9YCP4jaMgqHyVYKtsltZRGVCG5zp42TW595HZhxS+zw30aEorDvlSDxTXt+DxsDW4Pwxscw8nagVYh6h7MwRPf0cDCsj2gLPoHIQmcIdlKibnTdY5crJ2ZyW5zELOmOb+zhpp3f3JlHAOGF8leYO9PK0M/91FomNENyZ9MPMjrVjwP+Yfe3VImrc9oTlNkLZyZtxa8tOY2eUVZbA7QQPc44gR640a4/NPNQPbbGIuBCMZd3vOHbiowAaWzP3jNXv5/RQ7ZzXbQ/ArOtiMf3Wle0X1S1ZusX9kLbT5A0EDRIfAsJ2MKHa3i7J/RIC+So5mfW9fWH1C8rcue0tiP7QpBDWZtkuwjgnj+MgHswS2XuGhypSZwfav/1Sjj0C/2QlVV9YAIH4PNu+8lTvuTFvR46ZKtOGslw7jSuQsXuk/1grVlyvkydCKgbTQO2YPPctjf14UKWEHW4K7W9kIheS6msmwJMaoIoflLK380xxU/jBAsninKgPbxfz6yw2EYXkhdStA0hk0tN8U/0JWiKgDmkSW4F0yNZ3qxegL3PnBrk+d0fXfnJSaapKImb0iGR6VBuhjhZ1utJDH0l0qSynqHQYkhiX10hCZYybZElv//3i/585JOgEaVa3UYFCBe8MFNE81p+iaxhCVuPmJq8jIThLWMSwvePlOgyOQheg2ZcuKAf6DLyw1/O2LnLsm1uDQto/gU9aJgwOI+lZX5SGW/GTL6JHPhGzxFDtXrFfO5QPdZGD8iLlK5zRZHlgEUvOtBiIAgIvJLDtbVg7CSIedIxHZ1Pyv+AjXIMRLua2zkcKhyhQc0LYd3mESU9j2oayl7mvzvvnBUcmInv4u8CJWX8FCAwJEfFlxYaO8jbMf/PncsxRf8QEA9w91rdIfkntZAjZF1V+jWFl6SYY9kcyXJyFKTHnG3rAH4qAKjxKPJrWgphAGvpA7DqFZR3ntNR8wtVEthY+H+5/ferNfSGz/TjNhj8gxaapXN9d99WCCPr13n/O1qntXn/3RQKUT3pRJ+rnrljrqhZ2CY+zd9yy3FvQ8iixWY407KBNAYw6dQIz5/oosnhfN63e8jKXfLgBvxiht9lMHEl6E99yXmcYa/AkCjBF5nSkczSn/7Ch73gVAeHftFmcOtVzK+66LtWlH5wws8F55hJ2uMt7/54uMvL8N7C7HnJPfg0r9JJSqeGku1H3D/XShXh4ffp2a6i4/TMhQThAl8oooUoGwt7XvUDfl2eq6FUmljEu3T0V7eJTd6RzzjblR8VisNh1eVlIRy+9hkiNYBOG2Ga4k6xPev03/uFd+/uPAehDHxTVVbdEjIkEpUfzJ//frP/sdylbasFrLeryzFGLIXbRaMnpO+vp21kQXno59one+WDJHL6A7FMwQbSBCqJ1/JFcOD7QJyvJMU6gn4qXG9AcKw7tmsN56AsGQAgs4SeLwITiy/yzkLLMYQORfn+n2kO5L4zjb2b9Cf/Qdu9Dw4CXcWDMioKU86YFdnwzyI2n+0YJIVdM8gsYzRjIVsEvbEZryV2r3r6jb2IgAZXZ/Sr5qKrFaIdpKu3EowrArFJSrj50/iNw1U7tdU2eNYG97AVy0pz8ldTBhs2KXqZF0MKO/xVO42SEZdbWvOc1NdPFOWjPVBX7u6U3B29kv/oBCmOEXbFAY0WQ8DYdmr0p+e00o1Z6fylq0LfOXxuM0tG/SxZQ+8EwitDe4thScmwcKVgc6/ERH1rTEc+dLBRUI41GxsveXZM+lTkyT6poe6lTkvufWOHX8ovMokHXNzs49hiX8cMb0l1tDISlwkTNpJfziJAYd6sfdDuh/9U79tktF9cVF/2+LBvud8ke7rOdWIZmw11v7JEATJlxPtW6y3kpq0DoYfi7JK9kD3lVbTqvpVifLn+kSz9IgWetCSBMKZbzKkFPwJW6GqgEIZaVpAH5Xknu72Mf6X2Aqy9CVgNKjxmiuBbGuFUdjOswsTHHqMY6w4ksgIZV/0Az4XY4u0ya/tKuym61JP4r26siH14ni1NXj2U1wOtaPcu4ulFmtu/6Dn29/aYWHIe0REWGWClfILSqHyjODhDnLkKF5dFOWgl74w5jJL/Qmub7DmGz/I675xPjeJ89mTlKLUXMxGUbk4BuK+LITK/UMVVlMxDY6O5R3GAWQCsAp4puYfp+CEAgoYcIq+TWB8L3EvkaITQlINA1K7913nL9DlxzvCoW6C/ugDKrVNtsmBkky0It1iTDXbmIevVzpznPpAhXgcA2JCdPDiOsBsD5emarqp9mugnvvbtE3A/lvWsyCbIr1fa7txsyOtDbL5Ze2S7PDoCbmBrdCnUtLXxCCdGBx+X7tR7NA+zmW98c9mF+FZghRRh4nhPKNQ5iBvujzCU6sO2wNIJ+GXIWjECGf7XQmT8AbjbBVUtp8pOhT7YWqvba02dHSkjozL+LwzyMht09b/tUPOC9AdJtguD7bZVSvvgZNdJ3+jnBzhECZtFmfkC9cikn+oIQDJyI/fm7xIQAh/scMmqEHRMCgAd4M9AybRrxCyOtd8B88ehueJaZysdgI9VFiEJ7QR5+K2HVZNcMFMISzVmTZJtnBI53Z5DSoYeM0JrkXlXKpxhr8Q8VvtNMV7sLNa4ECtiePz2gJcH/8nWSWhY8IIuRI1ZYvifbBB50zC4gu46vlqyDVmwvy0K8ppcIgc7IWS84Jlq3ox+86jJ2Dc18l9k0sGtdirDTA1A6cnXB9dqZxVnXNa0Kt/vCiGGymHFfCqyfGsjC2+Uw7wRhroyYiyDII+c9jQNID8Fm0LPzC6SPmFqrsY5PI8lgPJ44xraOdUHFAmPrFZvGtK9MLoZp2zsXtnqsXbR/lHNbHBgnSg+fFP3dHU0YZOzgEElk0uKPRa2R1dJ/xvGP+BFFUZ/D5r8d5vpCx46igY0V4M9zSG1dDs2MLcjDRWc6BGS0Ksh8Lm3G9drmr3fiHN+1RFMyosWPHztw83GOWMiadR67FOOrRCEU5S6bKeM11KRjR7nQSrJMzE6ObmeLVMzTOb4ejlWQPFUJw9mIkKsY5T9pP51ZyHDISfBYY20TIdOlyVAM9/o8OugNF1vc6/QWMrxkJts0yx49EttbPZ3XgUsc+I+ET/ASJtZTa0yPYuKJtLBQhPWr7K2m749sHgkbpxndYw03OgIt3hfmDtE1v31q4hmiXdivK9raI439L9uh2yTA7Ud/K+kMpJpe1qs9SmWKrvYPN9PU/2bGo9UuGHvPnvnYGOi3SmaJtgJ5CRnJ94CmB6AtWhT77apl5NyLgzR/sX6J/+/g6MvLe49uncd3AGsaRyRTLq+XsioRhdz8iN090BpTqOWu2ftgrsngcYTPQ1YlhrbL0C7/4KuELBLTfriFs+muPzROrW9MfeNbwxzG7WnVvcq9G7HaYbP1hk53TOKu7gu7rpJ112h9gKlVh84K1Aux60qKV1CjixLUr7gp6Ufo1eagOYOujjGgEsdIgmXzgRmk3cwwQm+UuUjwCGHwcA5ZnQjfiKPILD8T/UHYESlGZtzb2XclK0D9k6NgYY8NSEifkpjUomAhmek7tpTTKAIbcqkhktrxZO3fjwWLZsZxCOwZKEKYUqzfiu0qgaT0CsQ2ukntFLey8tT/RJTxIxve+92Zj/TQ3lsInLm2eFFkGDn39Ilt0kWQtsIvL1SRWaxXLdMDnz5u4UP59Iqn9JXYU8nZvKd3ONR2UeBS8LlluMzi8oRbGj3iTGc7yq9mEU/K5cWYxg4fEeQtoCys/X27AABtoigS4tK1JaP/m26Be9pNoXb8x2vIPlQTPYduvp9KWqPDt14sk1+QRHal6JYqy7eQaztA02xoBEU1xETpZpP7unn9nSo+H23JcAsCDI+3aWNy5zVRs+tPJtMUm5ZCZNuJwm0ciZgQLHC/v9hw6oUb64reRgIZTObBZ+nOyaBtrcjfcoDwvkynHehRzErzP7JS0y2VRltdPIDsUG0MivS1py3zHxt7jHNUqMFdHdn/4WjqSSn/MxHppEQhp3mny0kdgpcSBQumId9yT0/KhdQTvRql99DXvgB1cL0a0QM06kBXKU4bdX3kpCkUElD8wzYcqTHZiS19iu0bbG8xicE+EAciQskLEFE1KBr3grJAVSYEVHChuRghibikqFXURECEm/ld+3db3b85SuH7ygibmzSWhjh79iIKBlKL0MaaxGJlX7AagJ9/7KogETNP4Et10dP9BuUtuAnkFqNn9sV5BNnNXaMV9u9Rd0IiTWWR2MXsGgdfcnd5Xfv46ldgckJ+oBdKEAYs89NvFxPeprvB2jnwwKCQo8hO0l6ULfb5NIWBoJm5hSZuVgSmk5k1pYOu6v5RvRkqpXKbVz2x6Sj+Jn5f4TkZK4OrnQxTBFtaJoAJDD/IxtShKZR6HZlt7i951a+TPRV2DBKWtJCiGgo/gFrufwq1PbbhDorkajI7RYFHftE3eFU9DNqBMdqy6vqIdn0nM/NriYxgvo6K63PozUC8mLqTGeALd3+rjVkOaIsr/ty1W7F2saIg8xgRyQ+GxlxyowOHjS+vMZ5c/3PRuVn3hu6LJ8EbGCJ7AtFeVmJsrM8KmfFYKf/O0upT0ABYdbVMqlwqMLznoIxslyfP2zTQNtYnpq/iPqJJfja6QKLL3vASHXxgcw2hZ6j3Af2Dv8lxYgxcXF5hK8Mk7zB3E2iSgYdGi3qv6IsQPiOlateDmJa1dYXtGPrR0DGxljREfWN49wrs6HxzAOiiYmMyViw0Alg3lWkGi3+VcjNBekB/9EILZVdEa0oaTQvPXY0qNXXQF7LM7YNN5kiYD0OfdZ1Y7zB5aBlY73TUr8lBiDtqUfesoBvMzpxDlCZcit+Tsrx4Ornhdz/zYGf9ojmtfyOd4FI5LBVgoIQsS8Tr1HXymap95MNsz92w==aplaintextu<string>aexecuPWlA.pyu<module>.
