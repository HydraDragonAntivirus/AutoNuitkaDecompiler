.Crypto.Cipher.AES^apopTause_aesnitTakeyuMissing 'key' parameterakey_sizeuIncorrect AES key length (%d bytes)a_raw_aesni_libaAESNI_start_operationaAESNI_stop_operationa_raw_aes_libaAES_start_operationaAES_stop_operationaVoidPointerac_uint8_ptrac_size_taaddress_ofuError %X while instantiating the AES cipheraSmartPointeragetuThis method instantiates and returns a handle to a low-level
    base cipher. It will absorb named parameters in the process.uPoly1305 with AES requires a 32-byte keyaget_random_bytesTluPoly1305 with AES requires a 16-byte nonceanew:nlnaMODE_ECBaencryptanonce:lnnuDerive a tuple (r, s, nonce) for a Poly1305 MAC.

    If nonce is ``None``, a new 16-byte nonce is generated.
    aadd_aes_modesa_create_cipheramodulesuCrypto.Cipher.AESuCreate a new AES cipher.

    :param key:
        The secret key to use in the symmetric cipher.

        It must be 16, 24 or 32 bytes long (respectively for *AES-128*,
        *AES-192* or *AES-256*).

        For ``MODE_SIV`` only, it doubles to 32, 48, or 64 bytes.
    :type key: bytes/bytearray/memoryview

    :param mode:
        The chaining mode to use for encryption or decryption.
        If in doubt, use ``MODE_EAX``.
    :type mode: One of the supported ``MODE_*`` constants

    :Keyword Arguments:
        *   **iv** (*bytes*, *bytearray*, *memoryview*) --
            (Only applicable for ``MODE_CBC``, ``MODE_CFB``, ``MODE_OFB``,
            and ``MODE_OPENPGP`` modes).

            The initialization vector to use for encryption or decryption.

            For ``MODE_CBC``, ``MODE_CFB``, and ``MODE_OFB`` it must be 16 bytes long.

            For ``MODE_OPENPGP`` mode only,
            it must be 16 bytes long for encryption
            and 18 bytes for decryption (in the latter case, it is
            actually the *encrypted* IV which was prefixed to the ciphertext).

            If not provided, a random byte string is generated (you must then
            read its value with the :attr:`iv` attribute).

        *   **nonce** (*bytes*, *bytearray*, *memoryview*) --
            (Only applicable for ``MODE_CCM``, ``MODE_EAX``, ``MODE_GCM``,
            ``MODE_SIV``, ``MODE_OCB``, and ``MODE_CTR``).

            A value that must never be reused for any other encryption done
            with this key (except possibly for ``MODE_SIV``, see below).

            For ``MODE_EAX``, ``MODE_GCM`` and ``MODE_SIV`` there are no
            restrictions on its length (recommended: **16** bytes).

            For ``MODE_CCM``, its length must be in the range **[7..13]**.
            Bear in mind that with CCM there is a trade-off between nonce
            length and maximum message size. Recommendation: **11** bytes.

            For ``MODE_OCB``, its length must be in the range **[1..15]**
            (recommended: **15**).

            For ``MODE_CTR``, its length must be in the range **[0..15]**
            (recommended: **8**).

            For ``MODE_SIV``, the nonce is optional, if it is not specified,
            then no nonce is being used, which renders the encryption
            deterministic.

            If not provided, for modes other than ``MODE_SIV```, a random
            byte string of the recommended length is used (you must then
            read its value with the :attr:`nonce` attribute).

        *   **segment_size** (*integer*) --
            (Only ``MODE_CFB``).The number of **bits** the plaintext and ciphertext
            are segmented in. It must be a multiple of 8.
            If not specified, it will be assumed to be 8.

        *   **mac_len** : (*integer*) --
            (Only ``MODE_EAX``, ``MODE_GCM``, ``MODE_OCB``, ``MODE_CCM``)
            Length of the authentication tag, in bytes.

            It must be even and in the range **[4..16]**.
            The recommended value (and the default, if not specified) is **16**.

        *   **msg_len** : (*integer*) --
            (Only ``MODE_CCM``). Length of the message to (de)cipher.
            If not specified, ``encrypt`` must be called with the entire message.
            Similarly, ``decrypt`` can only be called once.

        *   **assoc_len** : (*integer*) --
            (Only ``MODE_CCM``). Length of the associated data.
            If not specified, all associated data is buffered internally,
            which may represent a problem for very large messages.

        *   **initial_value** : (*integer* or *bytes/bytearray/memoryview*) --
            (Only ``MODE_CTR``).
            The initial value for the counter. If not present, the cipher will
            start counting from 0. The value is incremented by one for each block.
            The counter number is encoded in big endian mode.

        *   **counter** : (*object*) --
            Instance of ``Crypto.Util.Counter``, which allows full customization
            of the counter block. This parameter is incompatible to both ``nonce``
            and ``initial_value``.

        *   **use_aesni** : (*boolean*) --
            Use Intel AES-NI hardware extensions (default: use if available).

    :Return: an AES object, of the applicable mode.
    u
Module's constants for the modes of operation supported with AES:

:var MODE_ECB: :ref:`Electronic Code Book (ECB) <ecb_mode>`
:var MODE_CBC: :ref:`Cipher-Block Chaining (CBC) <cbc_mode>`
:var MODE_CFB: :ref:`Cipher FeedBack (CFB) <cfb_mode>`
:var MODE_OFB: :ref:`Output FeedBack (OFB) <ofb_mode>`
:var MODE_CTR: :ref:`CounTer Mode (CTR) <ctr_mode>`
:var MODE_OPENPGP:  :ref:`OpenPGP Mode <openpgp_mode>`
:var MODE_CCM: :ref:`Counter with CBC-MAC (CCM) Mode <ccm_mode>`
:var MODE_EAX: :ref:`EAX Mode <eax_mode>`
:var MODE_GCM: :ref:`Galois Counter Mode (GCM) <gcm_mode>`
:var MODE_SIV: :ref:`Syntethic Initialization Vector (SIV) <siv_mode>`
:var MODE_OCB: :ref:`Offset Code Book (OCB) <ocb_mode>`
a__doc__a__file__a__spec__aoriginahas_locationa__cached__asysuCrypto.CipherTa_create_cipherluCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointerac_size_tac_uint8_ptraload_pycryptodome_raw_libuCrypto.UtilTa_cpu_featuresa_cpu_featuresuCrypto.RandomTaget_random_bytesu
        int AES_start_operation(const uint8_t key[],
                                size_t key_len,
                                void **pResult);
        int AES_encrypt(const void *state,
                        const uint8_t *in,
                        uint8_t *out,
                        size_t data_len);
        int AES_decrypt(const void *state,
                        const uint8_t *in,
                        uint8_t *out,
                        size_t data_len);
        int AES_stop_operation(void *state);
        a_cprotouCrypto.Cipher._raw_aesahave_aes_niuCrypto.Cipher._raw_aesniareplaceTaAESaAESNIa_create_base_ciphera_derive_Poly1305_key_pairllaMODE_CBClaMODE_CFBlaMODE_OFBlaMODE_CTRlaMODE_OPENPGPlaMODE_CCMlaMODE_EAXl
aMODE_SIVlaMODE_GCMlaMODE_OCBlablock_sizeTlll uCrypto\Cipher\AES.pyu<module Crypto.Cipher.AES>Tadict_parametersause_aesniakeyastart_operationastop_operationacipheraresultTakeyanoncewsTakeyamodeaargsakwargsu.Crypto.Cipher._EKSBlowfish"5apopTakeyTasaltTacostuMissing EKSBlowfish parameter: Tainverttakey_sizeuIncorrect EKSBlowfish key length (%d bytes)a_raw_blowfish_libaEKSBlowfish_start_operationaEKSBlowfish_stop_operationaVoidPointerac_uint8_ptrac_size_tac_uintaaddress_ofuError %X while instantiating the EKSBlowfish cipheraSmartPointeragetuThis method instantiates and returns a smart pointer to
    a low-level base cipher. It will absorb named parameters in
    the process.asaltacostainverta_create_cipheramodulesuCrypto.Cipher._EKSBlowfishuCreate a new EKSBlowfish cipher

    Args:

      key (bytes, bytearray, memoryview):
        The secret key to use in the symmetric cipher.
        Its length can vary from 0 to 72 bytes.

      mode (one of the supported ``MODE_*`` constants):
        The chaining mode to use for encryption or decryption.

      salt (bytes, bytearray, memoryview):
        The salt that bcrypt uses to thwart rainbow table attacks

      cost (integer):
        The complexity factor in bcrypt

      invert (bool):
        If ``False``, in the inner loop use ``ExpandKey`` first over the salt
        and then over the key, as defined in
        the `original bcrypt specification <https://www.usenix.org/legacy/events/usenix99/provos/provos_html/node4.html>`_.
        If ``True``, reverse the order, as in the first implementation of
        `bcrypt` in OpenBSD.

    :Return: an EKSBlowfish object
    a__doc__a__file__a__spec__aoriginahas_locationa__cached__asysuCrypto.CipherTa_create_cipherluCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointerac_size_tac_uint8_ptrac_uintaload_pycryptodome_raw_libTuCrypto.Cipher._raw_eksblowfishu
        int EKSBlowfish_start_operation(const uint8_t key[],
                                        size_t key_len,
                                        const uint8_t salt[16],
                                        size_t salt_len,
                                        unsigned cost,
                                        unsigned invert,
                                        void **pResult);
        int EKSBlowfish_encrypt(const void *state,
                                const uint8_t *in,
                                uint8_t *out,
                                size_t data_len);
        int EKSBlowfish_decrypt(const void *state,
                                const uint8_t *in,
                                uint8_t *out,
                                size_t data_len);
        int EKSBlowfish_stop_operation(void *state);
        a_create_base_cipheranewlaMODE_ECBlablock_size;llIluCrypto\Cipher\_EKSBlowfish.pyu<module Crypto.Cipher._EKSBlowfish>T
adict_parametersakeyasaltacostweainvertastart_operationastop_operationavoid_paresultTakeyamodeasaltacostainvertakwargsu.Crypto.Cipher._mode_cbcZaVoidPointera_statearaw_cbc_libaCBC_start_operationagetac_uint8_ptrac_size_taaddress_ofuError %d while instantiating the CBC modeaSmartPointeraCBC_stop_operationareleaseablock_sizea_copy_bytesaivaIVaencryptadecrypta_nextuCreate a new block cipher, configured in CBC mode.

        :Parameters:
          block_cipher : C pointer
            A smart pointer to the low-level block cipher instance.

          iv : bytes/bytearray/memoryview
            The initialization vector to use for encryption or decryption.
            It is as long as the cipher block.

            **The IV must be unpredictable**. Ideally it is picked randomly.

            Reusing the *IV* for encryptions performed with the same key
            compromises confidentiality.
        uencrypt() cannot be called after decrypt()acreate_string_bufferais_writeable_bufferuoutput must be a bytearray or a writeable memoryviewuoutput must have the same length as the input  (%d bytes)aCBC_encryptaplaintextluData must be padded to %d byte boundary in CBC modeuError %d while encrypting in CBC modeaget_raw_bufferuEncrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have encrypted a message
        you cannot encrypt (or decrypt) another message using the same
        object.

        The data to encrypt can be broken up in two or
        more pieces and `encrypt` can be called multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        That also means that you cannot reuse an object for encrypting
        or decrypting other data with the same key.

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
            Its lenght must be multiple of the cipher block size.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
          If ``output`` is ``None``, the ciphertext is returned as ``bytes``.
          Otherwise, ``None``.
        udecrypt() cannot be called after encrypt()aCBC_decryptaciphertextuError %d while decrypting in CBC modeuDecrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        The data to decrypt can be broken up in two or
        more pieces and `decrypt` can be called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            Its length must be multiple of the cipher block size.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return:
          If ``output`` is ``None``, the plaintext is returned as ``bytes``.
          Otherwise, ``None``.
        a_create_base_cipherapopTaIVnTaivnTnnaget_random_bytesuYou must either use 'iv' or 'IV', not bothuIncorrect IV length (it must be %d bytes long)uUnknown parameters for CBC: %saCbcModeuInstantiate a cipher object that performs CBC encryption/decryption.

    :Parameters:
      factory : module
        The underlying block cipher, a module from ``Crypto.Cipher``.

    :Keywords:
      iv : bytes/bytearray/memoryview
        The IV to use for CBC.

      IV : bytes/bytearray/memoryview
        Alias for ``iv``.

    Any other keyword will be passed to the underlying block cipher.
    See the relevant documentation for details (at least ``key`` will need
    to be present).
    u
Ciphertext Block Chaining (CBC) mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__uCrypto.Util.py3compatTa_copy_bytesluCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeracreate_string_bufferaget_raw_bufferaSmartPointerac_size_tac_uint8_ptrais_writeable_bufferaload_pycryptodome_raw_libuCrypto.RandomTaget_random_bytesTuCrypto.Cipher._raw_cbcu
                int CBC_start_operation(void *cipher,
                                        const uint8_t iv[],
                                        size_t iv_len,
                                        void **pResult);
                int CBC_encrypt(void *cbcState,
                                const uint8_t *in,
                                uint8_t *out,
                                size_t data_len);
                int CBC_decrypt(void *cbcState,
                                const uint8_t *in,
                                uint8_t *out,
                                size_t data_len);
                int CBC_stop_operation(void *state);
                TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_cbca__module__u*Cipher-Block Chaining (CBC)*.

    Each of the ciphertext blocks depends on the current
    and all previous plaintext blocks.

    An Initialization Vector (*IV*) is required.

    See `NIST SP800-38A`_ , Section 6.2 .

    .. _`NIST SP800-38A` : http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf

    :undocumented: __init__
    a__qualname__a__init__uCbcMode.__init__TnuCbcMode.encryptuCbcMode.decrypta__orig_bases__a_create_cbc_cipheruCrypto\Cipher\_mode_cbc.pyu<module Crypto.Cipher._mode_cbc>Ta__class__Taselfablock_cipheraivaresultTafactoryakwargsacipher_stateaivaIVTaselfaciphertextaoutputaplaintextaresultTaselfaplaintextaoutputaciphertextaresultu.Crypto.Cipher._mode_ccm1aEnumuCrypto.Cipher._mode_ccmablock_sizea_copy_bytesanoncea_factorya_keya_mac_lena_msg_lena_assoc_lena_cipher_paramsa_mac_tagluCCM mode is only available for ciphers that operate on 128 bits blocksTllll
llluParameter 'mac_len' must be even and in the range 4..16 (not %d)uLength of parameter 'nonce' must be in the range 7..13 bytesanewaMODE_CBCDaivba_macaMacStatusaNOT_STARTEDa_mac_statusa_taupdateaencryptadecryptadigestaverifya_nextla_cumul_assoc_lena_cumul_msg_lena_cacheaMODE_CTRastructapackwBa_cipherTba_s_0a_start_macl@llalong_to_bytesclgclcainsertlaPROCESSING_AUTH_DATAa_updateduupdate() can only be called immediately after initializationuAssociated data is too longuProtect associated data

        If there is any associated data, the caller has to invoke
        this function one or more times, before using
        ``decrypt`` or ``encrypt``.

        By *associated data* it is meant any data (e.g. packet headers) that
        will not be encrypted and will be transmitted in the clear.
        However, the receiver is still able to detect any modification to it.
        In CCM, the *associated data* is also called
        *additional authenticated data* (AAD).

        If there is no associated data, this method must not be called.

        The caller may split associated data in segments of any size, and
        invoke this method multiple times, each time with the next segment.

        :Parameters:
          assoc_data : bytes/bytearray/memoryview
            A piece of associated data. There are no restrictions on its size.
        ais_writeable_bufferaappendaassoc_data_ptamin:qnnuUpdate the MAC with associated data or plaintext
           (without FSM checks)uencrypt() can only be called after initialization or an update()uAssociated data is too shortuMessage is too longa_pad_cache_and_updateaPROCESSING_PLAINTEXTTaoutputuEncrypt data with the key set at initialization.

        A cipher object is stateful: once you have encrypted a message
        you cannot encrypt (or decrypt) another message using the same
        object.

        This method can be called only **once** if ``msg_len`` was
        not passed at initialization.

        If ``msg_len`` was given, the data to encrypt can be broken
        up in two or more pieces and `encrypt` can be called
        multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
          If ``output`` is ``None``, the ciphertext as ``bytes``.
          Otherwise, ``None``.
        udecrypt() can only be called after initialization or an update()uDecrypt data with the key set at initialization.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        This method can be called only **once** if ``msg_len`` was
        not passed at initialization.

        If ``msg_len`` was given, the data to decrypt can be
        broken up in two or more pieces and `decrypt` can be
        called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return:
          If ``output`` is ``None``, the plaintext as ``bytes``.
          Otherwise, ``None``.
        udigest() cannot be called when decrypting or validating a messagea_digestuCompute the *binary* MAC tag.

        The caller invokes this function at the very end.

        This method returns the MAC that shall be sent to the receiver,
        together with the ciphertext.

        :Return: the MAC, as a byte string.
        uMessage is too shortastrxoruu%02xaborduCompute the *printable* MAC tag.

        This method is like `digest`.

        :Return: the MAC, as a hexadecimal string.
        uverify() cannot be called when encrypting a messageaget_random_bytesTlaBLAKE2slTadigest_bitsakeyadatauMAC check faileduValidate the *binary* MAC tag.

        The caller invokes this function at the very end.

        This method checks if the decrypted message is indeed valid
        (that is, if the key is correct) and it has not been
        tampered with while in transit.

        :Parameters:
          received_mac_tag : bytes/bytearray/memoryview
            This is the *binary* MAC, as received from the sender.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        aunhexlifyuValidate the *printable* MAC tag.

        This method is like `verify`.

        :Parameters:
          hex_mac_tag : string
            This is the *printable* MAC, as received from the sender.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        uPerform encrypt() and digest() in one step.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
            a tuple with two items:

            - the ciphertext, as ``bytes``
            - the MAC tag, as ``bytes``

            The first item becomes ``None`` when the ``output`` parameter
            specified a location for the result.
        uPerform decrypt() and verify() in one step.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
          received_mac_tag : bytes/bytearray/memoryview
            This is the *binary* MAC, as received from the sender.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return: the plaintext as ``bytes`` or ``None`` when the ``output``
            parameter specified a location for the result.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        akeyuMissing parameter: apopTanoncenTlamac_lenTamsg_lennTaassoc_lennaCcmModeuCreate a new block cipher, configured in CCM mode.

    :Parameters:
      factory : module
        A symmetric cipher module from `Crypto.Cipher` (like
        `Crypto.Cipher.AES`).

    :Keywords:
      key : bytes/bytearray/memoryview
        The secret key to use in the symmetric cipher.

      nonce : bytes/bytearray/memoryview
        A value that must never be reused for any other encryption.

        Its length must be in the range ``[7..13]``.
        11 or 12 bytes are reasonable values in general. Bear in
        mind that with CCM there is a trade-off between nonce length and
        maximum message size.

        If not specified, a 11 byte long random string is used.

      mac_len : integer
        Length of the MAC, in bytes. It must be even and in
        the range ``[4..16]``. The default is 16.

      msg_len : integer
        Length of the message to (de)cipher.
        If not specified, ``encrypt`` or ``decrypt`` may only be called once.

      assoc_len : integer
        Length of the associated data.
        If not specified, all data is internally buffered.
    u
Counter with CBC-MAC (CCM) mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__abinasciiTaunhexlifyuCrypto.Util.py3compatTabyte_stringaborda_copy_bytesabyte_stringuCrypto.Util._raw_apiTais_writeable_bufferuCrypto.Util.strxorTastrxoruCrypto.Util.numberTalong_to_bytesuCrypto.HashTaBLAKE2suCrypto.RandomTaget_random_bytesaenumTlllTaNOT_STARTEDaPROCESSING_AUTH_DATAaPROCESSING_PLAINTEXTTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>a__module__uCounter with CBC-MAC (CCM).

    This is an Authenticated Encryption with Associated Data (`AEAD`_) mode.
    It provides both confidentiality and authenticity.

    The header of the message may be left in the clear, if needed, and it will
    still be subject to authentication. The decryption step tells the receiver
    if the message comes from a source that really knowns the secret key.
    Additionally, decryption detects if any part of the message - including the
    header - has been modified or corrupted.

    This mode requires a nonce. The nonce shall never repeat for two
    different messages encrypted with the same key, but it does not need
    to be random.
    Note that there is a trade-off between the size of the nonce and the
    maximum size of a single message you can encrypt.

    It is important to use a large nonce if the key is reused across several
    messages and the nonce is chosen randomly.

    It is acceptable to us a short nonce if the key is only used a few times or
    if the nonce is taken from a counter.

    The following table shows the trade-off when the nonce is chosen at
    random. The column on the left shows how many messages it takes
    for the keystream to repeat **on average**. In practice, you will want to
    stop using the key way before that.

    +--------------------+---------------+-------------------+
    | Avg. # of messages |    nonce      |     Max. message  |
    | before keystream   |    size       |     size          |
    | repeats            |    (bytes)    |     (bytes)       |
    +====================+===============+===================+
    |       2^52         |      13       |        64K        |
    +--------------------+---------------+-------------------+
    |       2^48         |      12       |        16M        |
    +--------------------+---------------+-------------------+
    |       2^44         |      11       |         4G        |
    +--------------------+---------------+-------------------+
    |       2^40         |      10       |         1T        |
    +--------------------+---------------+-------------------+
    |       2^36         |       9       |        64P        |
    +--------------------+---------------+-------------------+
    |       2^32         |       8       |        16E        |
    +--------------------+---------------+-------------------+

    This mode is only available for ciphers that operate on 128 bits blocks
    (e.g. AES but not TDES).

    See `NIST SP800-38C`_ or RFC3610_.

    .. _`NIST SP800-38C`: http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C.pdf
    .. _RFC3610: https://tools.ietf.org/html/rfc3610
    .. _AEAD: http://blog.cryptographyengineering.com/2012/05/how-to-choose-authenticated-encryption.html

    :undocumented: __init__
    a__qualname__a__init__uCcmMode.__init__uCcmMode._start_macuCcmMode._pad_cache_and_updateuCcmMode.updateTcuCcmMode._updateTnuCcmMode.encryptuCcmMode.decryptuCcmMode.digestuCcmMode._digestahexdigestuCcmMode.hexdigestuCcmMode.verifyahexverifyuCcmMode.hexverifyaencrypt_and_digestuCcmMode.encrypt_and_digestadecrypt_and_verifyuCcmMode.decrypt_and_verifya__orig_bases__a_create_ccm_cipheruCrypto\Cipher\_mode_ccm.pyu<module Crypto.Cipher._mode_ccm>Ta__class__Taselfafactoryakeyanonceamac_lenamsg_lenaassoc_lenacipher_paramswqTafactoryakwargsakeyweanonceamac_lenamsg_lenaassoc_lenacipher_paramsTaselfTaselfalen_cacheTaselfwqaflagsab_0aassoc_len_encodedaenc_sizeafirst_data_to_macTaselfaassoc_data_ptafilleraupdate_lenTaselfaciphertextaoutputaplaintextTaselfaciphertextareceived_mac_tagaoutputaplaintextTaselfaplaintextaoutputTaenumsTaselfahex_mac_tagTaselfaassoc_dataTaselfareceived_mac_tagasecretamac1amac2.Crypto.Cipher._mode_cfbe\aVoidPointera_statearaw_cfb_libaCFB_start_operationagetac_uint8_ptrac_size_taaddress_ofuError %d while instantiating the CFB modeaSmartPointeraCFB_stop_operationareleaseablock_sizea_copy_bytesaivaIVaencryptadecrypta_nextuCreate a new block cipher, configured in CFB mode.

        :Parameters:
          block_cipher : C pointer
            A smart pointer to the low-level block cipher instance.

          iv : bytes/bytearray/memoryview
            The initialization vector to use for encryption or decryption.
            It is as long as the cipher block.

            **The IV must be unpredictable**. Ideally it is picked randomly.

            Reusing the *IV* for encryptions performed with the same key
            compromises confidentiality.

          segment_size : integer
            The number of bytes the plaintext and ciphertext are segmented in.
        uencrypt() cannot be called after decrypt()acreate_string_bufferais_writeable_bufferuoutput must be a bytearray or a writeable memoryviewuoutput must have the same length as the input  (%d bytes)aCFB_encryptaplaintextuError %d while encrypting in CFB modeaget_raw_bufferuEncrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have encrypted a message
        you cannot encrypt (or decrypt) another message using the same
        object.

        The data to encrypt can be broken up in two or
        more pieces and `encrypt` can be called multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
          If ``output`` is ``None``, the ciphertext is returned as ``bytes``.
          Otherwise, ``None``.
        udecrypt() cannot be called after encrypt()aCFB_decryptaciphertextuError %d while decrypting in CFB modeuDecrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        The data to decrypt can be broken up in two or
        more pieces and `decrypt` can be called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return:
          If ``output`` is ``None``, the plaintext is returned as ``bytes``.
          Otherwise, ``None``.
        a_create_base_cipherapopTaIVnTaivnTnnaget_random_bytesuYou must either use 'iv' or 'IV', not bothuIncorrect IV length (it must be %d bytes long)Tasegment_sizellutoo many values to unpack (expected 2)lu'segment_size' must be positive and multiple of 8 bitsuUnknown parameters for CFB: %saCfbModeuInstantiate a cipher object that performs CFB encryption/decryption.

    :Parameters:
      factory : module
        The underlying block cipher, a module from ``Crypto.Cipher``.

    :Keywords:
      iv : bytes/bytearray/memoryview
        The IV to use for CFB.

      IV : bytes/bytearray/memoryview
        Alias for ``iv``.

      segment_size : integer
        The number of bit the plaintext and ciphertext are segmented in.
        If not present, the default is 8.

    Any other keyword will be passed to the underlying block cipher.
    See the relevant documentation for details (at least ``key`` will need
    to be present).
    u
Counter Feedback (CFB) mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__uCrypto.Util.py3compatTa_copy_bytesuCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeracreate_string_bufferaget_raw_bufferaSmartPointerac_size_tac_uint8_ptrais_writeable_bufferaload_pycryptodome_raw_libuCrypto.RandomTaget_random_bytesTuCrypto.Cipher._raw_cfbu
                    int CFB_start_operation(void *cipher,
                                            const uint8_t iv[],
                                            size_t iv_len,
                                            size_t segment_len, /* In bytes */
                                            void **pResult);
                    int CFB_encrypt(void *cfbState,
                                    const uint8_t *in,
                                    uint8_t *out,
                                    size_t data_len);
                    int CFB_decrypt(void *cfbState,
                                    const uint8_t *in,
                                    uint8_t *out,
                                    size_t data_len);
                    int CFB_stop_operation(void *state);TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_cfba__module__u*Cipher FeedBack (CFB)*.

    This mode is similar to CFB, but it transforms
    the underlying block cipher into a stream cipher.

    Plaintext and ciphertext are processed in *segments*
    of **s** bits. The mode is therefore sometimes
    labelled **s**-bit CFB.

    An Initialization Vector (*IV*) is required.

    See `NIST SP800-38A`_ , Section 6.3.

    .. _`NIST SP800-38A` : http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf

    :undocumented: __init__
    a__qualname__a__init__uCfbMode.__init__TnuCfbMode.encryptuCfbMode.decrypta__orig_bases__a_create_cfb_cipheruCrypto\Cipher\_mode_cfb.pyu<module Crypto.Cipher._mode_cfb>Ta__class__Taselfablock_cipheraivasegment_sizearesultTafactoryakwargsacipher_stateaivaIVasegment_size_bytesaremTaselfaciphertextaoutputaplaintextaresultTaselfaplaintextaoutputaciphertextaresultu.Crypto.Cipher._mode_ctr#ua_copy_bytesanonceaVoidPointera_statearaw_ctr_libaCTR_start_operationagetac_uint8_ptrac_size_taaddress_ofuError %X while instantiating the CTR modeaSmartPointeraCTR_stop_operationareleaseablock_sizeaencryptadecrypta_nextuCreate a new block cipher, configured in CTR mode.

        :Parameters:
          block_cipher : C pointer
            A smart pointer to the low-level block cipher instance.

          initial_counter_block : bytes/bytearray/memoryview
            The initial plaintext to use to generate the key stream.

            It is as large as the cipher block, and it embeds
            the initial value of the counter.

            This value must not be reused.
            It shall contain a nonce or a random component.
            Reusing the *initial counter block* for encryptions
            performed with the same key compromises confidentiality.

          prefix_len : integer
            The amount of bytes at the beginning of the counter block
            that never change.

          counter_len : integer
            The length in bytes of the counter embedded in the counter
            block.

          little_endian : boolean
            True if the counter in the counter block is an integer encoded
            in little endian mode. If False, it is big endian.
        uencrypt() cannot be called after decrypt()acreate_string_bufferais_writeable_bufferuoutput must be a bytearray or a writeable memoryviewuoutput must have the same length as the input  (%d bytes)aCTR_encryptaplaintextluThe counter has wrapped around in CTR modeuError %X while encrypting in CTR modeaget_raw_bufferuEncrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have encrypted a message
        you cannot encrypt (or decrypt) another message using the same
        object.

        The data to encrypt can be broken up in two or
        more pieces and `encrypt` can be called multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
          If ``output`` is ``None``, the ciphertext is returned as ``bytes``.
          Otherwise, ``None``.
        udecrypt() cannot be called after encrypt()aCTR_decryptaciphertextuError %X while decrypting in CTR modeuDecrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        The data to decrypt can be broken up in two or
        more pieces and `decrypt` can be called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return:
          If ``output`` is ``None``, the plaintext is returned as ``bytes``.
          Otherwise, ``None``.
        a_create_base_cipherapopTacounternTanoncenTainitial_valuenuInvalid parameters for CTR mode: %sTnnu'counter' and 'nonce'/'initial_value' are mutually exclusiveluImpossible to create a safe nonce for short block sizesaget_random_bytesluNonce is too longlais_native_intlluInitial counter value is too largealong_to_bytesuIncorrect length for counter byte string (%d bytes, expected %d)aCtrModeacounter_lenaprefixasuffixainitial_valuealittle_endianuIncorrect counter object (use Crypto.Util.Counter.new)awordsastructapackwBldamaxareversecuSize of the counter block (%d bytes) must match block size (%d)uInstantiate a cipher object that performs CTR encryption/decryption.

    :Parameters:
      factory : module
        The underlying block cipher, a module from ``Crypto.Cipher``.

    :Keywords:
      nonce : bytes/bytearray/memoryview
        The fixed part at the beginning of the counter block - the rest is
        the counter number that gets increased when processing the next block.
        The nonce must be such that no two messages are encrypted under the
        same key and the same nonce.

        The nonce must be shorter than the block size (it can have
        zero length; the counter is then as long as the block).

        If this parameter is not present, a random nonce will be created with
        length equal to half the block size. No random nonce shorter than
        64 bits will be created though - you must really think through all
        security consequences of using such a short block size.

      initial_value : posive integer or bytes/bytearray/memoryview
        The initial value for the counter. If not present, the cipher will
        start counting from 0. The value is incremented by one for each block.
        The counter number is encoded in big endian mode.

      counter : object
        Instance of ``Crypto.Util.Counter``, which allows full customization
        of the counter block. This parameter is incompatible to both ``nonce``
        and ``initial_value``.

    Any other keyword will be passed to the underlying block cipher.
    See the relevant documentation for details (at least ``key`` will need
    to be present).
    u
Counter (CTR) mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__uCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeracreate_string_bufferaget_raw_bufferaSmartPointerac_size_tac_uint8_ptrais_writeable_bufferaload_pycryptodome_raw_libuCrypto.RandomTaget_random_bytesuCrypto.Util.py3compatTa_copy_bytesais_native_intuCrypto.Util.numberTalong_to_bytesTuCrypto.Cipher._raw_ctru
                    int CTR_start_operation(void *cipher,
                                            uint8_t   initialCounterBlock[],
                                            size_t    initialCounterBlock_len,
                                            size_t    prefix_len,
                                            unsigned  counter_len,
                                            unsigned  littleEndian,
                                            void **pResult);
                    int CTR_encrypt(void *ctrState,
                                    const uint8_t *in,
                                    uint8_t *out,
                                    size_t data_len);
                    int CTR_decrypt(void *ctrState,
                                    const uint8_t *in,
                                    uint8_t *out,
                                    size_t data_len);
                    int CTR_stop_operation(void *ctrState);TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_ctra__module__u*CounTeR (CTR)* mode.

    This mode is very similar to ECB, in that
    encryption of one block is done independently of all other blocks.

    Unlike ECB, the block *position* contributes to the encryption
    and no information leaks about symbol frequency.

    Each message block is associated to a *counter* which
    must be unique across all messages that get encrypted
    with the same key (not just within the same message).
    The counter is as big as the block size.

    Counters can be generated in several ways. The most
    straightword one is to choose an *initial counter block*
    (which can be made public, similarly to the *IV* for the
    other modes) and increment its lowest **m** bits by one
    (modulo *2^m*) for each block. In most cases, **m** is
    chosen to be half the block size.

    See `NIST SP800-38A`_, Section 6.5 (for the mode) and
    Appendix B (for how to manage the *initial counter block*).

    .. _`NIST SP800-38A` : http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf

    :undocumented: __init__
    a__qualname__a__init__uCtrMode.__init__TnuCtrMode.encryptuCtrMode.decrypta__orig_bases__a_create_ctr_cipheruCrypto\Cipher\_mode_ctr.pyu<module Crypto.Cipher._mode_ctr>Ta__class__Taselfablock_cipherainitial_counter_blockaprefix_lenacounter_lenalittle_endianaresultT
afactoryakwargsacipher_stateacounteranonceainitial_valueacounter_lenainitial_counter_blocka_counteraprefixasuffixalittle_endianawordsTaselfaciphertextaoutputaplaintextaresultTaselfaplaintextaoutputaciphertextaresultu.Crypto.Cipher._mode_eax*%ablock_sizea_copy_bytesanoncea_mac_lena_mac_tagaupdateaencryptadecryptadigestaverifya_nextluParameter 'mac_len' must not be larger than %duNonce cannot be empty in EAX modeais_bufferunonce must be bytes, bytearray or memoryview;lllaCMACanewakeydaselflastructapackwBafactoryacipher_paramsTaciphermodacipher_paramsa_omacla_signerabytes_to_longaMODE_CTRainitial_valueca_cipheruEAX cipher modeuupdate() can only be called immediately after initializationuProtect associated data

        If there is any associated data, the caller has to invoke
        this function one or more times, before using
        ``decrypt`` or ``encrypt``.

        By *associated data* it is meant any data (e.g. packet headers) that
        will not be encrypted and will be transmitted in the clear.
        However, the receiver is still able to detect any modification to it.

        If there is no associated data, this method must not be called.

        The caller may split associated data in segments of any size, and
        invoke this method multiple times, each time with the next segment.

        :Parameters:
          assoc_data : bytes/bytearray/memoryview
            A piece of associated data. There are no restrictions on its size.
        uencrypt() can only be called after initialization or an update()TaoutputluEncrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have encrypted a message
        you cannot encrypt (or decrypt) another message using the same
        object.

        The data to encrypt can be broken up in two or
        more pieces and `encrypt` can be called multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
          If ``output`` is ``None``, the ciphertext as ``bytes``.
          Otherwise, ``None``.
        udecrypt() can only be called after initialization or an update()uDecrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        The data to decrypt can be broken up in two or
        more pieces and `decrypt` can be called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return:
          If ``output`` is ``None``, the plaintext as ``bytes``.
          Otherwise, ``None``.
        udigest() cannot be called when decrypting or validating a messageastrxorataguCompute the *binary* MAC tag.

        The caller invokes this function at the very end.

        This method returns the MAC that shall be sent to the receiver,
        together with the ciphertext.

        :Return: the MAC, as a byte string.
        uu%02xaborduCompute the *printable* MAC tag.

        This method is like `digest`.

        :Return: the MAC, as a hexadecimal string.
        uverify() cannot be called when encrypting a messageaget_random_bytesTlaBLAKE2slTadigest_bitsakeyadatauMAC check faileduValidate the *binary* MAC tag.

        The caller invokes this function at the very end.

        This method checks if the decrypted message is indeed valid
        (that is, if the key is correct) and it has not been
        tampered with while in transit.

        :Parameters:
          received_mac_tag : bytes/bytearray/memoryview
            This is the *binary* MAC, as received from the sender.
        :Raises MacMismatchError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        aunhexlifyuValidate the *printable* MAC tag.

        This method is like `verify`.

        :Parameters:
          hex_mac_tag : string
            This is the *printable* MAC, as received from the sender.
        :Raises MacMismatchError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        uPerform encrypt() and digest() in one step.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
            a tuple with two items:

            - the ciphertext, as ``bytes``
            - the MAC tag, as ``bytes``

            The first item becomes ``None`` when the ``output`` parameter
            specified a location for the result.
        uPerform decrypt() and verify() in one step.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
          received_mac_tag : bytes/bytearray/memoryview
            This is the *binary* MAC, as received from the sender.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return: the plaintext as ``bytes`` or ``None`` when the ``output``
            parameter specified a location for the result.
        :Raises MacMismatchError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        apopTanoncenamac_lenuMissing parameter: aEaxModeuCreate a new block cipher, configured in EAX mode.

    :Parameters:
      factory : module
        A symmetric cipher module from `Crypto.Cipher` (like
        `Crypto.Cipher.AES`).

    :Keywords:
      key : bytes/bytearray/memoryview
        The secret key to use in the symmetric cipher.

      nonce : bytes/bytearray/memoryview
        A value that must never be reused for any other encryption.
        There are no restrictions on its length, but it is recommended to use
        at least 16 bytes.

        The nonce shall never repeat for two different messages encrypted with
        the same key, but it does not need to be random.

        If not specified, a 16 byte long random string is used.

      mac_len : integer
        Length of the MAC, in bytes. It must be no larger than the cipher
        block bytes (which is the default).
    u
EAX mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__abinasciiTaunhexlifyuCrypto.Util.py3compatTabyte_stringaborda_copy_bytesabyte_stringuCrypto.Util._raw_apiTais_bufferuCrypto.Util.strxorTastrxoruCrypto.Util.numberTalong_to_bytesabytes_to_longalong_to_bytesuCrypto.HashTaCMACaBLAKE2suCrypto.RandomTaget_random_bytesTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_eaxa__module__u*EAX* mode.

    This is an Authenticated Encryption with Associated Data
    (`AEAD`_) mode. It provides both confidentiality and authenticity.

    The header of the message may be left in the clear, if needed,
    and it will still be subject to authentication.

    The decryption step tells the receiver if the message comes
    from a source that really knowns the secret key.
    Additionally, decryption detects if any part of the message -
    including the header - has been modified or corrupted.

    This mode requires a *nonce*.

    This mode is only available for ciphers that operate on 64 or
    128 bits blocks.

    There are no official standards defining EAX.
    The implementation is based on `a proposal`__ that
    was presented to NIST.

    .. _AEAD: http://blog.cryptographyengineering.com/2012/05/how-to-choose-authenticated-encryption.html
    .. __: http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/eax/eax-spec.pdf

    :undocumented: __init__
    a__qualname__a__init__uEaxMode.__init__uEaxMode.updateTnuEaxMode.encryptuEaxMode.decryptuEaxMode.digestahexdigestuEaxMode.hexdigestuEaxMode.verifyahexverifyuEaxMode.hexverifyaencrypt_and_digestuEaxMode.encrypt_and_digestadecrypt_and_verifyuEaxMode.decrypt_and_verifya__orig_bases__a_create_eax_cipheruCrypto\Cipher\_mode_eax.pyu<module Crypto.Cipher._mode_eax>Ta__class__Taselfafactoryakeyanonceamac_lenacipher_paramsacounter_intTafactoryakwargsakeyanonceamac_lenweTaselfaciphertextaoutputTaselfaciphertextareceived_mac_tagaoutputaptTaselfatagwiTaselfaplaintextaoutputactTaselfaplaintextaoutputTaselfTaselfahex_mac_tagTaselfaassoc_dataTaselfareceived_mac_tagatagwiasecretamac1amac2.Crypto.Cipher._mode_ecbIablock_sizeaVoidPointera_statearaw_ecb_libaECB_start_operationagetaaddress_ofuError %d while instantiating the ECB modeaSmartPointeraECB_stop_operationareleaseuCreate a new block cipher, configured in ECB mode.

        :Parameters:
          block_cipher : C pointer
            A smart pointer to the low-level block cipher instance.
        acreate_string_bufferais_writeable_bufferuoutput must be a bytearray or a writeable memoryviewuoutput must have the same length as the input  (%d bytes)aECB_encryptac_uint8_ptraplaintextac_size_tluData must be aligned to block boundary in ECB modeuError %d while encrypting in ECB modeaget_raw_bufferuEncrypt data with the key set at initialization.

        The data to encrypt can be broken up in two or
        more pieces and `encrypt` can be called multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
            The length must be multiple of the cipher block length.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
          If ``output`` is ``None``, the ciphertext is returned as ``bytes``.
          Otherwise, ``None``.
        aECB_decryptaciphertextuError %d while decrypting in ECB modeuDecrypt data with the key set at initialization.

        The data to decrypt can be broken up in two or
        more pieces and `decrypt` can be called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            The length must be multiple of the cipher block length.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return:
          If ``output`` is ``None``, the plaintext is returned as ``bytes``.
          Otherwise, ``None``.
        a_create_base_cipheruUnknown parameters for ECB: %saEcbModeuInstantiate a cipher object that performs ECB encryption/decryption.

    :Parameters:
      factory : module
        The underlying block cipher, a module from ``Crypto.Cipher``.

    All keywords are passed to the underlying block cipher.
    See the relevant documentation for details (at least ``key`` will need
    to be presentu
Electronic Code Book (ECB) mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__uCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeracreate_string_bufferaget_raw_bufferaSmartPointerac_size_tac_uint8_ptrais_writeable_bufferlaload_pycryptodome_raw_libTuCrypto.Cipher._raw_ecbu
                    int ECB_start_operation(void *cipher,
                                            void **pResult);
                    int ECB_encrypt(void *ecbState,
                                    const uint8_t *in,
                                    uint8_t *out,
                                    size_t data_len);
                    int ECB_decrypt(void *ecbState,
                                    const uint8_t *in,
                                    uint8_t *out,
                                    size_t data_len);
                    int ECB_stop_operation(void *state);
                    TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_ecba__module__u*Electronic Code Book (ECB)*.

    This is the simplest encryption mode. Each of the plaintext blocks
    is directly encrypted into a ciphertext block, independently of
    any other block.

    This mode is dangerous because it exposes frequency of symbols
    in your plaintext. Other modes (e.g. *CBC*) should be used instead.

    See `NIST SP800-38A`_ , Section 6.1.

    .. _`NIST SP800-38A` : http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf

    :undocumented: __init__
    a__qualname__a__init__uEcbMode.__init__TnaencryptuEcbMode.encryptadecryptuEcbMode.decrypta__orig_bases__a_create_ecb_cipheruCrypto\Cipher\_mode_ecb.pyu<module Crypto.Cipher._mode_ecb>Ta__class__Taselfablock_cipheraresultTafactoryakwargsacipher_stateTaselfaciphertextaoutputaplaintextaresultTaselfaplaintextaoutputaciphertextaresultu.Crypto.Cipher._mode_gcm.acollectionsTanamedtuplelanamedtupleTa_GHash_ImpTaghashaghash_expandaghash_destroyTaghashaghash_expandaghash_destroyw_apostfixa_ghash_api_templateareplaceTu%imp%aportableaload_pycryptodome_raw_libuCrypto.Hash._ghash_portablea_build_implaportablea_cpu_featuresahave_clmulTu%imp%aclmuluCrypto.Hash._ghash_clmulaclmuluReturn None if CLMUL implementation is not availableaghash_caVoidPointera_exp_keyaghash_expandac_uint8_ptraaddress_ofuError %d while expanding the GHASH keyaSmartPointeragetaghash_destroyacreate_string_bufferTla_last_ylaghashac_size_tuError %d while updating GHASHaget_raw_bufferaEnumuCrypto.Cipher._mode_gcmablock_sizeuGCM mode is only available for ciphers that operate on 128 bits blocksuNonce cannot be emptyais_bufferuNonce must be bytes, bytearray or memoryviewguNonce exceeds maximum lengtha_copy_bytesanoncea_factorya_keya_taga_mac_lenluParameter 'mac_len' must be in the range 4..16aupdateaencryptadecryptadigestaverifya_nexta_no_more_assoc_dataa_auth_lena_msg_lenanewaMODE_ECBTbbdalong_to_bytesla_GHASH:nlnabytes_to_longlgaMODE_CTRainitial_valuea_ciphera_signerca_tag_ciphera_cacheaMacStatusaPROCESSING_AUTH_DATAa_statusuupdate() can only be called immediately after initializationa_updateuAdditional Authenticated Data exceeds maximum lengthuProtect associated data

        If there is any associated data, the caller has to invoke
        this function one or more times, before using
        ``decrypt`` or ``encrypt``.

        By *associated data* it is meant any data (e.g. packet headers) that
        will not be encrypted and will be transmitted in the clear.
        However, the receiver is still able to detect any modification to it.
        In GCM, the *associated data* is also called
        *additional authenticated data* (AAD).

        If there is no associated data, this method must not be called.

        The caller may split associated data in segments of any size, and
        invoke this method multiple times, each time with the next segment.

        :Parameters:
          assoc_data : bytes/bytearray/memoryview
            A piece of associated data. There are no restrictions on its size.
        aminuencrypt() can only be called after initialization or an update()Taoutputa_pad_cache_and_updateaPROCESSING_CIPHERTEXTguPlaintext exceeds maximum lengthuEncrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have encrypted a message
        you cannot encrypt (or decrypt) another message using the same
        object.

        The data to encrypt can be broken up in two or
        more pieces and `encrypt` can be called multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
          If ``output`` is ``None``, the ciphertext as ``bytes``.
          Otherwise, ``None``.
        udecrypt() can only be called after initialization or an update()uDecrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        The data to decrypt can be broken up in two or
        more pieces and `decrypt` can be called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return:
          If ``output`` is ``None``, the plaintext as ``bytes``.
          Otherwise, ``None``.
        udigest() cannot be called when decrypting or validating a messagea_compute_macuCompute the *binary* MAC tag in an AEAD mode.

        The caller invokes this function at the very end.

        This method returns the MAC that shall be sent to the receiver,
        together with the ciphertext.

        :Return: the MAC, as a byte string.
        uCompute MAC without any FSM checks.uu%02xaborduCompute the *printable* MAC tag.

        This method is like `digest`.

        :Return: the MAC, as a hexadecimal string.
        uverify() cannot be called when encrypting a messageaget_random_bytesaBLAKE2slTadigest_bitsakeyadatauMAC check faileduValidate the *binary* MAC tag.

        The caller invokes this function at the very end.

        This method checks if the decrypted message is indeed valid
        (that is, if the key is correct) and it has not been
        tampered with while in transit.

        :Parameters:
          received_mac_tag : bytes/bytearray/memoryview
            This is the *binary* MAC, as received from the sender.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        aunhexlifyuValidate the *printable* MAC tag.

        This method is like `verify`.

        :Parameters:
          hex_mac_tag : string
            This is the *printable* MAC, as received from the sender.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        uPerform encrypt() and digest() in one step.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
            a tuple with two items:

            - the ciphertext, as ``bytes``
            - the MAC tag, as ``bytes``

            The first item becomes ``None`` when the ``output`` parameter
            specified a location for the result.
        uPerform decrypt() and verify() in one step.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
          received_mac_tag : byte string
            This is the *binary* MAC, as received from the sender.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return: the plaintext as ``bytes`` or ``None`` when the ``output``
            parameter specified a location for the result.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        akeyuMissing parameter:apopTanoncenTamac_lenlTause_clmulta_ghash_clmula_ghash_portableaGcmModeuCreate a new block cipher, configured in Galois Counter Mode (GCM).

    :Parameters:
      factory : module
        A block cipher module, taken from `Crypto.Cipher`.
        The cipher must have block length of 16 bytes.
        GCM has been only defined for `Crypto.Cipher.AES`.

    :Keywords:
      key : bytes/bytearray/memoryview
        The secret key to use in the symmetric cipher.
        It must be 16 (e.g. *AES-128*), 24 (e.g. *AES-192*)
        or 32 (e.g. *AES-256*) bytes long.

      nonce : bytes/bytearray/memoryview
        A value that must never be reused for any other encryption.

        There are no restrictions on its length,
        but it is recommended to use at least 16 bytes.

        The nonce shall never repeat for two
        different messages encrypted with the same key,
        but it does not need to be random.

        If not provided, a 16 byte nonce will be randomly created.

      mac_len : integer
        Length of the MAC, in bytes.
        It must be no larger than 16 bytes (which is the default).
    u
Galois/Counter Mode (GCM).
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__abinasciiTaunhexlifyuCrypto.Util.py3compatTaborda_copy_bytesuCrypto.Util._raw_apiTais_bufferuCrypto.Util.numberTalong_to_bytesabytes_to_longuCrypto.HashTaBLAKE2suCrypto.RandomTaget_random_bytesTaload_pycryptodome_raw_libaVoidPointeracreate_string_bufferaget_raw_bufferaSmartPointerac_size_tac_uint8_ptruCrypto.UtilTa_cpu_featuresu
    int ghash_%imp%(uint8_t y_out[16],
                    const uint8_t block_data[],
                    size_t len,
                    const uint8_t y_in[16],
                    const void *exp_key);
    int ghash_expand_%imp%(const uint8_t h[16],
                           void **ghash_tables);
    int ghash_destroy_%imp%(void *ghash_tables);
a_get_ghash_portablea_get_ghash_clmulTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>a__module__uGHASH function defined in NIST SP 800-38D, Algorithm 2.

    If X_1, X_2, .. X_m are the blocks of input data, the function
    computes:

       X_1*H^{m} + X_2*H^{m-1} + ... + X_m*H

    in the Galois field GF(2^256) using the reducing polynomial
    (x^128 + x^7 + x^2 + x + 1).
    a__qualname__a__init__u_GHASH.__init__u_GHASH.updateu_GHASH.digesta__orig_bases__aenumTllTaPROCESSING_AUTH_DATAaPROCESSING_CIPHERTEXTuGalois Counter Mode (GCM).

    This is an Authenticated Encryption with Associated Data (`AEAD`_) mode.
    It provides both confidentiality and authenticity.

    The header of the message may be left in the clear, if needed, and it will
    still be subject to authentication. The decryption step tells the receiver
    if the message comes from a source that really knowns the secret key.
    Additionally, decryption detects if any part of the message - including the
    header - has been modified or corrupted.

    This mode requires a *nonce*.

    This mode is only available for ciphers that operate on 128 bits blocks
    (e.g. AES but not TDES).

    See `NIST SP800-38D`_.

    .. _`NIST SP800-38D`: http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf
    .. _AEAD: http://blog.cryptographyengineering.com/2012/05/how-to-choose-authenticated-encryption.html

    :undocumented: __init__
    uGcmMode.__init__uGcmMode.updateuGcmMode._updateuGcmMode._pad_cache_and_updateTnuGcmMode.encryptuGcmMode.decryptuGcmMode.digestuGcmMode._compute_macahexdigestuGcmMode.hexdigestuGcmMode.verifyahexverifyuGcmMode.hexverifyaencrypt_and_digestuGcmMode.encrypt_and_digestadecrypt_and_verifyuGcmMode.decrypt_and_verifya_create_gcm_cipheruCrypto\Cipher\_mode_gcm.pyu<module Crypto.Cipher._mode_gcm>Ta__class__T
aselfafactoryakeyanonceamac_lenacipher_paramsaghash_cahash_subkeyaj0afillaghash_inanonce_ctraiv_ctrTaselfasubkeyaghash_caresultTalibapostfixanamedtupleafuncsaGHASH_Impaimp_funcsaparamsTaselfas_tagTafactoryakwargsakeyweanonceamac_lenause_clmulaghash_cTaapialibaresultTaselfalen_cacheTaselfadataafilleraupdate_lenTaselfaciphertextaoutputTaselfaciphertextareceived_mac_tagaoutputaplaintextTaselfTaselfaplaintextaoutputaciphertextTaselfaplaintextaoutputTaenumsTaselfahex_mac_tagTaselfaassoc_dataTaselfablock_dataaresultTaselfareceived_mac_tagasecretamac1amac2.Crypto.Cipher._mode_ocb)ablock_sizeluOCB mode is only available for ciphers that operate on 128 bits blocksa_copy_bytesanonce;llluNonce must be at most 15 bytes longais_bufferuNonce must be bytes, bytearray or memoryviewa_mac_lenluMAC tag must be between 8 and 16 bytes longa_mac_tagca_cache_Aa_cache_Paupdateaencryptadecryptadigestaverifya_nextakeyastructapackwBllddabordll?lanewaMODE_ECBu15sB:nlnastrxor:nln:llnalong_to_bytesabytes_to_longl@l:lnna_create_base_cipheruUnknown keywords: aVoidPointera_statea_raw_ocb_libaOCB_start_operationagetac_size_taaddress_ofuError %d while instantiating the OCB modeaSmartPointeraOCB_stop_operationareleaseaOCB_updateac_uint8_ptruError %d while computing MAC in OCB modeuupdate() can only be called immediately after initializationaminutoo many values to unpack (expected 2)a_updateuProcess the associated data.

        If there is any associated data, the caller has to invoke
        this method one or more times, before using
        ``decrypt`` or ``encrypt``.

        By *associated data* it is meant any data (e.g. packet headers) that
        will not be encrypted and will be transmitted in the clear.
        However, the receiver shall still able to detect modifications.

        If there is no associated data, this method must not be called.

        The caller may split associated data in segments of any size, and
        invoke this method multiple times, each time with the next segment.

        :Parameters:
          assoc_data : bytes/bytearray/memoryview
            A piece of associated data.
        acreate_string_bufferuError %d while %sing in OCB modeaget_raw_buffera_transcrypt_aligneduencrypt() can only be called after initialization or an update()a_transcryptaOCB_encryptuEncrypt the next piece of plaintext.

        After the entire plaintext has been passed (but before `digest`),
        you **must** call this method one last time with no arguments to collect
        the final piece of ciphertext.

        If possible, use the method `encrypt_and_digest` instead.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The next piece of data to encrypt or ``None`` to signify
            that encryption has finished and that any remaining ciphertext
            has to be produced.
        :Return:
            the ciphertext, as a byte string.
            Its length may not match the length of the *plaintext*.
        udecrypt() can only be called after initialization or an update()aOCB_decryptuDecrypt the next piece of ciphertext.

        After the entire ciphertext has been passed (but before `verify`),
        you **must** call this method one last time with no arguments to collect
        the remaining piece of plaintext.

        If possible, use the method `decrypt_and_verify` instead.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The next piece of data to decrypt or ``None`` to signify
            that decryption has finished and that any remaining plaintext
            has to be produced.
        :Return:
            the plaintext, as a byte string.
            Its length may not match the length of the *ciphertext*.
        TlaOCB_digestuError %d while computing digest in OCB modeudigest() cannot be called now for this ciphera_compute_mac_taguCompute the *binary* MAC tag.

        Call this method after the final `encrypt` (the one with no arguments)
        to obtain the MAC tag.

        The MAC tag is needed by the receiver to determine authenticity
        of the message.

        :Return: the MAC, as a byte string.
        uu%02xuCompute the *printable* MAC tag.

        This method is like `digest`.

        :Return: the MAC, as a hexadecimal string.
        uverify() cannot be called now for this cipheraget_random_bytesaBLAKE2slTadigest_bitsakeyadatauMAC check faileduValidate the *binary* MAC tag.

        Call this method after the final `decrypt` (the one with no arguments)
        to check if the message is authentic and valid.

        :Parameters:
          received_mac_tag : bytes/bytearray/memoryview
            This is the *binary* MAC, as received from the sender.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        aunhexlifyuValidate the *printable* MAC tag.

        This method is like `verify`.

        :Parameters:
          hex_mac_tag : string
            This is the *printable* MAC, as received from the sender.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        uEncrypt the message and create the MAC tag in one step.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The entire message to encrypt.
        :Return:
            a tuple with two byte strings:

            - the encrypted data
            - the MAC
        uDecrypted the message and verify its authenticity in one step.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The entire message to decrypt.
          received_mac_tag : byte string
            This is the *binary* MAC, as received from the sender.

        :Return: the decrypted data (byte string).
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        TlapopTamac_lenluKeyword missing: aOcbModeuCreate a new block cipher, configured in OCB mode.

    :Parameters:
      factory : module
        A symmetric cipher module from `Crypto.Cipher`
        (like `Crypto.Cipher.AES`).

    :Keywords:
      nonce : bytes/bytearray/memoryview
        A  value that must never be reused for any other encryption.
        Its length can vary from 1 to 15 bytes.
        If not specified, a random 15 bytes long nonce is generated.

      mac_len : integer
        Length of the MAC, in bytes.
        It must be in the range ``[8..16]``.
        The default is 16 (128 bits).

    Any other keyword will be passed to the underlying block cipher.
    See the relevant documentation for details (at least ``key`` will need
    to be present).
    u
Offset Codebook (OCB) mode.

OCB is Authenticated Encryption with Associated Data (AEAD) cipher mode
designed by Prof. Phillip Rogaway and specified in `RFC7253`_.

The algorithm provides both authenticity and privacy, it is very efficient,
it uses only one key and it can be used in online mode (so that encryption
or decryption can start before the end of the message is available).

This module implements the third and last variant of OCB (OCB3) and it only
works in combination with a 128-bit block symmetric cipher, like AES.

OCB is patented in US but `free licenses`_ exist for software implementations
meant for non-military purposes.

Example:
    >>> from Crypto.Cipher import AES
    >>> from Crypto.Random import get_random_bytes
    >>>
    >>> key = get_random_bytes(32)
    >>> cipher = AES.new(key, AES.MODE_OCB)
    >>> plaintext = b"Attack at dawn"
    >>> ciphertext, mac = cipher.encrypt_and_digest(plaintext)
    >>> # Deliver cipher.nonce, ciphertext and mac
    ...
    >>> cipher = AES.new(key, AES.MODE_OCB, nonce=nonce)
    >>> try:
    >>>     plaintext = cipher.decrypt_and_verify(ciphertext, mac)
    >>> except ValueError:
    >>>     print "Invalid message"
    >>> else:
    >>>     print plaintext

:undocumented: __package__

.. _RFC7253: http://www.rfc-editor.org/info/rfc7253
.. _free licenses: http://web.cs.ucdavis.edu/~rogaway/ocb/license.htm
a__doc__a__file__a__spec__aoriginahas_locationa__cached__labinasciiTaunhexlifyuCrypto.Util.py3compatTaborda_copy_bytesuCrypto.Util.numberTalong_to_bytesabytes_to_longuCrypto.Util.strxorTastrxoruCrypto.HashTaBLAKE2suCrypto.RandomTaget_random_bytesuCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeracreate_string_bufferaget_raw_bufferaSmartPointerac_size_tac_uint8_ptrais_bufferaload_pycryptodome_raw_libTuCrypto.Cipher._raw_ocbu
                                    int OCB_start_operation(void *cipher,
                                        const uint8_t *offset_0,
                                        size_t offset_0_len,
                                        void **pState);
                                    int OCB_encrypt(void *state,
                                        const uint8_t *in,
                                        uint8_t *out,
                                        size_t data_len);
                                    int OCB_decrypt(void *state,
                                        const uint8_t *in,
                                        uint8_t *out,
                                        size_t data_len);
                                    int OCB_update(void *state,
                                        const uint8_t *in,
                                        size_t data_len);
                                    int OCB_digest(void *state,
                                        uint8_t *tag,
                                        size_t tag_len);
                                    int OCB_stop_operation(void *state);
                                    TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_ocba__module__uOffset Codebook (OCB) mode.

    :undocumented: __init__
    a__qualname__a__init__uOcbMode.__init__uOcbMode._updateuOcbMode.updateuOcbMode._transcrypt_aligneduOcbMode._transcryptTnuOcbMode.encryptuOcbMode.decryptuOcbMode._compute_mac_taguOcbMode.digestahexdigestuOcbMode.hexdigestuOcbMode.verifyahexverifyuOcbMode.hexverifyaencrypt_and_digestuOcbMode.encrypt_and_digestadecrypt_and_verifyuOcbMode.decrypt_and_verifya__orig_bases__a_create_ocb_cipheruCrypto\Cipher\_mode_ocb.pyu<module Crypto.Cipher._mode_ocb>Ta__class__Taselfafactoryanonceamac_lenacipher_paramsaparams_without_keyakeyabottom_bitsatop_bitsaktop_cipheraktopastretchaoffset_0araw_cipheraresultTaselfamac_tagaresultTafactoryakwargsanonceamac_lenweTaselfain_dataatrans_funcatrans_descaout_dataaprefixafilleratrans_lenaresultTaselfain_dataain_data_lenatrans_funcatrans_descaout_dataaresultTaselfaassoc_dataaassoc_data_lenaresultTaselfaciphertextTaselfaciphertextareceived_mac_tagaplaintextTaselfTaselfaplaintextTaselfahex_mac_tagTaselfaassoc_dataafillerasegaupdate_lenTaselfareceived_mac_tagasecretamac1amac2.Crypto.Cipher._mode_ofbXaVoidPointera_statearaw_ofb_libaOFB_start_operationagetac_uint8_ptrac_size_taaddress_ofuError %d while instantiating the OFB modeaSmartPointeraOFB_stop_operationareleaseablock_sizea_copy_bytesaivaIVaencryptadecrypta_nextuCreate a new block cipher, configured in OFB mode.

        :Parameters:
          block_cipher : C pointer
            A smart pointer to the low-level block cipher instance.

          iv : bytes/bytearray/memoryview
            The initialization vector to use for encryption or decryption.
            It is as long as the cipher block.

            **The IV must be a nonce, to to be reused for any other
            message**. It shall be a nonce or a random value.

            Reusing the *IV* for encryptions performed with the same key
            compromises confidentiality.
        uencrypt() cannot be called after decrypt()acreate_string_bufferais_writeable_bufferuoutput must be a bytearray or a writeable memoryviewuoutput must have the same length as the input  (%d bytes)aOFB_encryptaplaintextuError %d while encrypting in OFB modeaget_raw_bufferuEncrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have encrypted a message
        you cannot encrypt (or decrypt) another message using the same
        object.

        The data to encrypt can be broken up in two or
        more pieces and `encrypt` can be called multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
          If ``output`` is ``None``, the ciphertext is returned as ``bytes``.
          Otherwise, ``None``.
        udecrypt() cannot be called after encrypt()aOFB_decryptaciphertextuError %d while decrypting in OFB modeuDecrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        The data to decrypt can be broken up in two or
        more pieces and `decrypt` can be called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            It can be of any length.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext is written to.
            If ``None``, the plaintext is returned.
        :Return:
          If ``output`` is ``None``, the plaintext is returned as ``bytes``.
          Otherwise, ``None``.
        a_create_base_cipherapopTaIVnTaivnTnnaget_random_bytesuYou must either use 'iv' or 'IV', not bothuIncorrect IV length (it must be %d bytes long)uUnknown parameters for OFB: %saOfbModeuInstantiate a cipher object that performs OFB encryption/decryption.

    :Parameters:
      factory : module
        The underlying block cipher, a module from ``Crypto.Cipher``.

    :Keywords:
      iv : bytes/bytearray/memoryview
        The IV to use for OFB.

      IV : bytes/bytearray/memoryview
        Alias for ``iv``.

    Any other keyword will be passed to the underlying block cipher.
    See the relevant documentation for details (at least ``key`` will need
    to be present).
    u
Output Feedback (CFB) mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__uCrypto.Util.py3compatTa_copy_bytesluCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeracreate_string_bufferaget_raw_bufferaSmartPointerac_size_tac_uint8_ptrais_writeable_bufferaload_pycryptodome_raw_libuCrypto.RandomTaget_random_bytesTuCrypto.Cipher._raw_ofbu
                        int OFB_start_operation(void *cipher,
                                                const uint8_t iv[],
                                                size_t iv_len,
                                                void **pResult);
                        int OFB_encrypt(void *ofbState,
                                        const uint8_t *in,
                                        uint8_t *out,
                                        size_t data_len);
                        int OFB_decrypt(void *ofbState,
                                        const uint8_t *in,
                                        uint8_t *out,
                                        size_t data_len);
                        int OFB_stop_operation(void *state);
                        TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_ofba__module__u*Output FeedBack (OFB)*.

    This mode is very similar to CBC, but it
    transforms the underlying block cipher into a stream cipher.

    The keystream is the iterated block encryption of the
    previous ciphertext block.

    An Initialization Vector (*IV*) is required.

    See `NIST SP800-38A`_ , Section 6.4.

    .. _`NIST SP800-38A` : http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf

    :undocumented: __init__
    a__qualname__a__init__uOfbMode.__init__TnuOfbMode.encryptuOfbMode.decrypta__orig_bases__a_create_ofb_cipheruCrypto\Cipher\_mode_ofb.pyu<module Crypto.Cipher._mode_ofb>Ta__class__Taselfablock_cipheraivaresultTafactoryakwargsacipher_stateaivaIVTaselfaciphertextaoutputaplaintextaresultTaselfaplaintextaoutputaciphertextaresultu.Crypto.Cipher._mode_openpgpBablock_sizea_done_first_blockanewaMODE_CFBaIVdasegment_sizela_copy_bytesaencrypt:qnna_encrypted_IVladecrypt:nqnuLength of IV must be %d or %d bytes for MODE_OPENPGPaiva_cipheruEncrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have encrypted a message
        you cannot encrypt (or decrypt) another message using the same
        object.

        The data to encrypt can be broken up in two or
        more pieces and `encrypt` can be called multiple times.

        That is, the statement:

            >>> c.encrypt(a) + c.encrypt(b)

        is equivalent to:

             >>> c.encrypt(a+b)

        This function does not add any padding to the plaintext.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.

        :Return:
            the encrypted data, as a byte string.
            It is as long as *plaintext* with one exception:
            when encrypting the first message chunk,
            the encypted IV is prepended to the returned ciphertext.
        uDecrypt data with the key and the parameters set at initialization.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        The data to decrypt can be broken up in two or
        more pieces and `decrypt` can be called multiple times.

        That is, the statement:

            >>> c.decrypt(a) + c.decrypt(b)

        is equivalent to:

             >>> c.decrypt(a+b)

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.

        :Return: the decrypted data (byte string).
        apopTaivnTnnaget_random_bytesuYou must either use 'iv' or 'IV', not bothTakeyuMissing component: aOpenPgpModeuCreate a new block cipher, configured in OpenPGP mode.

    :Parameters:
      factory : module
        The module.

    :Keywords:
      key : bytes/bytearray/memoryview
        The secret key to use in the symmetric cipher.

      IV : bytes/bytearray/memoryview
        The initialization vector to use for encryption or decryption.

        For encryption, the IV must be as long as the cipher block size.

        For decryption, it must be 2 bytes longer (it is actually the
        *encrypted* IV which was prefixed to the ciphertext).
    u
OpenPGP mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__uCrypto.Util.py3compatTa_copy_bytesluCrypto.RandomTaget_random_bytesTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_openpgpa__module__uOpenPGP mode.

    This mode is a variant of CFB, and it is only used in PGP and
    OpenPGP_ applications. If in doubt, use another mode.

    An Initialization Vector (*IV*) is required.

    Unlike CFB, the *encrypted* IV (not the IV itself) is
    transmitted to the receiver.

    The IV is a random data block. For legacy reasons, two of its bytes are
    duplicated to act as a checksum for the correctness of the key, which is now
    known to be insecure and is ignored. The encrypted IV is therefore 2 bytes
    longer than the clean IV.

    .. _OpenPGP: http://tools.ietf.org/html/rfc4880

    :undocumented: __init__
    a__qualname__a__init__uOpenPgpMode.__init__uOpenPgpMode.encryptuOpenPgpMode.decrypta__orig_bases__a_create_openpgp_cipheruCrypto\Cipher\_mode_openpgp.pyu<module Crypto.Cipher._mode_openpgp>Ta__class__Taselfafactoryakeyaivacipher_paramsaIV_cipherTafactoryakwargsaivaIVakeyweTaselfaciphertextTaselfaplaintextaresu.Crypto.Cipher._mode_sivG$ablock_sizea_factorya_cipher_paramsTl l0l@uIncorrect key length (%d bytes)ais_bufferuWhen provided, the nonce must be bytes, bytearray or memoryviewuWhen provided, the nonce must be non-emptya_copy_bytesanoncela_mac_taga_S2VTaciphermodacipher_paramsa_kdfa_subkey_cipheranewaMODE_ECBaupdateaencryptadecryptadigestaverifya_nextabytes_to_longgaMODE_CTRainitial_valuecuCreate a new CTR cipher from V in SIV modeuupdate() can only be called immediately after initializationuProtect one associated data component

        For SIV, the associated data is a sequence (*vector*) of non-empty
        byte strings (*components*).

        This method consumes the next component. It must be called
        once for each of the components that constitue the associated data.

        Note that the components have clear boundaries, so that:

            >>> cipher.update(b"builtin")
            >>> cipher.update(b"securely")

        is not equivalent to:

            >>> cipher.update(b"built")
            >>> cipher.update(b"insecurely")

        If there is no associated data, this method must not be called.

        :Parameters:
          component : bytes/bytearray/memoryview
            The next associated data component.
        uencrypt() not allowed for SIV mode. Use encrypt_and_digest() instead.u
        For SIV, encryption and MAC authentication must take place at the same
        point. This method shall not be used.

        Use `encrypt_and_digest` instead.
        udecrypt() not allowed for SIV mode. Use decrypt_and_verify() instead.u
        For SIV, decryption and verification must take place at the same
        point. This method shall not be used.

        Use `decrypt_and_verify` instead.
        udigest() cannot be called when decrypting or validating a messageaderiveuCompute the *binary* MAC tag.

        The caller invokes this function at the very end.

        This method returns the MAC that shall be sent to the receiver,
        together with the ciphertext.

        :Return: the MAC, as a byte string.
        uu%02xaborduCompute the *printable* MAC tag.

        This method is like `digest`.

        :Return: the MAC, as a hexadecimal string.
        uverify() cannot be called when encrypting a messageaget_random_bytesTlaBLAKE2slTadigest_bitsakeyadatauMAC check faileduValidate the *binary* MAC tag.

        The caller invokes this function at the very end.

        This method checks if the decrypted message is indeed valid
        (that is, if the key is correct) and it has not been
        tampered with while in transit.

        :Parameters:
          received_mac_tag : bytes/bytearray/memoryview
            This is the *binary* MAC, as received from the sender.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        aunhexlifyuValidate the *printable* MAC tag.

        This method is like `verify`.

        :Parameters:
          hex_mac_tag : string
            This is the *printable* MAC, as received from the sender.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        uencrypt() can only be called after initialization or an update()a_create_ctr_cipherTaoutputuPerform encrypt() and digest() in one step.

        :Parameters:
          plaintext : bytes/bytearray/memoryview
            The piece of data to encrypt.
        :Keywords:
          output : bytearray/memoryview
            The location where the ciphertext must be written to.
            If ``None``, the ciphertext is returned.
        :Return:
            a tuple with two items:

            - the ciphertext, as ``bytes``
            - the MAC tag, as ``bytes``

            The first item becomes ``None`` when the ``output`` parameter
            specified a location for the result.
        udecrypt() can only be called after initialization or an update()a_cipheruPerform decryption and verification in one step.

        A cipher object is stateful: once you have decrypted a message
        you cannot decrypt (or encrypt) another message with the same
        object.

        You cannot reuse an object for encrypting
        or decrypting other data with the same key.

        This function does not remove any padding from the plaintext.

        :Parameters:
          ciphertext : bytes/bytearray/memoryview
            The piece of data to decrypt.
            It can be of any length.
          mac_tag : bytes/bytearray/memoryview
            This is the *binary* MAC, as received from the sender.
        :Keywords:
          output : bytearray/memoryview
            The location where the plaintext must be written to.
            If ``None``, the plaintext is returned.
        :Return: the plaintext as ``bytes`` or ``None`` when the ``output``
            parameter specified a location for the result.
        :Raises ValueError:
            if the MAC does not match. The message has been tampered with
            or the key is incorrect.
        akeyuMissing parameter: apopTanoncenaSivModeuCreate a new block cipher, configured in
    Synthetic Initializaton Vector (SIV) mode.

    :Parameters:

      factory : object
        A symmetric cipher module from `Crypto.Cipher`
        (like `Crypto.Cipher.AES`).

    :Keywords:

      key : bytes/bytearray/memoryview
        The secret key to use in the symmetric cipher.
        It must be 32, 48 or 64 bytes long.
        If AES is the chosen cipher, the variants *AES-128*,
        *AES-192* and or *AES-256* will be used internally.

      nonce : bytes/bytearray/memoryview
        For deterministic encryption, it is not present.

        Otherwise, it is a value that must never be reused
        for encrypting message under this key.

        There are no restrictions on its length,
        but it is recommended to use at least 16 bytes.
    u
Synthetic Initialization Vector (SIV) mode.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__a__all__abinasciiTahexlifyaunhexlifylahexlifyuCrypto.Util.py3compatTaborda_copy_bytesuCrypto.Util._raw_apiTais_bufferuCrypto.Util.numberTalong_to_bytesabytes_to_longalong_to_bytesuCrypto.Protocol.KDFTa_S2VuCrypto.HashTaBLAKE2suCrypto.RandomTaget_random_bytesTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Cipher._mode_siva__module__uSynthetic Initialization Vector (SIV).

    This is an Authenticated Encryption with Associated Data (`AEAD`_) mode.
    It provides both confidentiality and authenticity.

    The header of the message may be left in the clear, if needed, and it will
    still be subject to authentication. The decryption step tells the receiver
    if the message comes from a source that really knowns the secret key.
    Additionally, decryption detects if any part of the message - including the
    header - has been modified or corrupted.

    Unlike other AEAD modes such as CCM, EAX or GCM, accidental reuse of a
    nonce is not catastrophic for the confidentiality of the message. The only
    effect is that an attacker can tell when the same plaintext (and same
    associated data) is protected with the same key.

    The length of the MAC is fixed to the block size of the underlying cipher.
    The key size is twice the length of the key of the underlying cipher.

    This mode is only available for AES ciphers.

    +--------------------+---------------+-------------------+
    |      Cipher        | SIV MAC size  |   SIV key length  |
    |                    |    (bytes)    |     (bytes)       |
    +====================+===============+===================+
    |    AES-128         |      16       |        32         |
    +--------------------+---------------+-------------------+
    |    AES-192         |      16       |        48         |
    +--------------------+---------------+-------------------+
    |    AES-256         |      16       |        64         |
    +--------------------+---------------+-------------------+

    See `RFC5297`_ and the `original paper`__.

    .. _RFC5297: https://tools.ietf.org/html/rfc5297
    .. _AEAD: http://blog.cryptographyengineering.com/2012/05/how-to-choose-authenticated-encryption.html
    .. __: http://www.cs.ucdavis.edu/~rogaway/papers/keywrap.pdf

    :undocumented: __init__
    a__qualname__a__init__uSivMode.__init__uSivMode._create_ctr_cipheruSivMode.updateuSivMode.encryptuSivMode.decryptuSivMode.digestahexdigestuSivMode.hexdigestuSivMode.verifyahexverifyuSivMode.hexverifyTnaencrypt_and_digestuSivMode.encrypt_and_digestadecrypt_and_verifyuSivMode.decrypt_and_verifya__orig_bases__a_create_siv_cipheruCrypto\Cipher\_mode_siv.pyu<module Crypto.Cipher._mode_siv>Ta__class__Taselfafactoryakeyanonceakwargsasubkey_sizeTaselfwvav_intwqTafactoryakwargsakeyweanonceTaselfaciphertextTaselfaciphertextamac_tagaoutputaplaintextTaselfTaselfaplaintextTaselfaplaintextaoutputacipherTaselfahex_mac_tagTaselfacomponentTaselfareceived_mac_tagasecretamac1amac2.Crypto.CipherOakeya_modesapopTaadd_aes_modesFa_extra_modesuMode not supportedTlll
lluToo many arguments for this modelanonceTllllaIVlluIV is not meaningful for the ECB modea__doc__a__file__apathadirnameajoinaenvironagetTaNUITKA_PACKAGE_Cryptou\not_existingaCipherTaNUITKA_PACKAGE_Crypto_Cipheru\not_existinga__path__a__spec__aoriginahas_locationasubmodule_search_locationsa__cached__aosuCrypto.Cipher._mode_ecbTa_create_ecb_ciphera_create_ecb_cipheruCrypto.Cipher._mode_cbcTa_create_cbc_ciphera_create_cbc_cipheruCrypto.Cipher._mode_cfbTa_create_cfb_ciphera_create_cfb_cipheruCrypto.Cipher._mode_ofbTa_create_ofb_ciphera_create_ofb_cipheruCrypto.Cipher._mode_ctrTa_create_ctr_ciphera_create_ctr_cipheruCrypto.Cipher._mode_openpgpTa_create_openpgp_ciphera_create_openpgp_cipheruCrypto.Cipher._mode_ccmTa_create_ccm_ciphera_create_ccm_cipheruCrypto.Cipher._mode_eaxTa_create_eax_ciphera_create_eax_cipheruCrypto.Cipher._mode_sivTa_create_siv_ciphera_create_siv_cipheruCrypto.Cipher._mode_gcmTa_create_gcm_ciphera_create_gcm_cipheruCrypto.Cipher._mode_ocbTa_create_ocb_ciphera_create_ocb_cipherlllllll
lla_create_cipheruCrypto\Cipher\__init__.pyu<module Crypto.Cipher>Tafactoryakeyamodeaargsakwargsamodesu.Crypto.Hash.BLAKE2s}sadigest_sizea_update_after_digesta_digest_doneTllll u1.3.6.1.4.1.1722.12.2.2.aoidaVoidPointera_raw_blake2s_libablake2s_initaaddress_ofac_uint8_ptrac_size_tuError %d while instantiating BLAKE2saSmartPointeragetablake2s_destroya_stateaupdateuYou can only call 'digest' or 'hexdigest' on this objectablake2s_updateuError %d while hashing BLAKE2s datauContinue hashing of a message by consuming the next chunk of data.

        Args:
            data (byte string/byte array/memoryview): The next chunk of the message being hashed.
        acreate_string_bufferTl ablake2s_digestuError %d while creating BLAKE2s digestaget_raw_bufferuReturn the **binary** (non-printable) digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xaborduReturn the **printable** digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        aget_random_bytesTlanewlTadigest_bitsakeyadatauMAC check faileduVerify that a given **binary** MAC (computed by another party)
        is valid.

        Args:
          mac_tag (byte string/byte array/memoryview): the expected MAC of the message.

        Raises:
            ValueError: if the MAC does not match. It means that the message
                has been tampered with or that the MAC key is incorrect.
        averifyaunhexlifyatobytesuVerify that a given **printable** MAC (computed by another party)
        is valid.

        Args:
            hex_mac_tag (string): the expected MAC of the message, as a hexadecimal string.

        Raises:
            ValueError: if the MAC does not match. It means that the message
                has been tampered with or that the MAC key is incorrect.
        adigest_bytesadigest_bitsuReturn a new instance of a BLAKE2s hash object.
        See :func:`new`.
        adataapopTaupdate_after_digestFTadigest_bytesnTadigest_bitsnuOnly one digest parameter must be providedTnnl lu'digest_bytes' not in range 1..32llu'digest_bytes' not in range 8..256, with steps of 8TakeycuBLAKE2s key cannot exceed 32 bytesuUnknown parameters: aBLAKE2s_HashuCreate a new hash object.

    Args:
        data (byte string/byte array/memoryview):
            Optional. The very first chunk of the message to hash.
            It is equivalent to an early call to :meth:`BLAKE2s_Hash.update`.
        digest_bytes (integer):
            Optional. The size of the digest, in bytes (1 to 32). Default is 32.
        digest_bits (integer):
            Optional and alternative to ``digest_bytes``.
            The size of the digest, in bits (8 to 256, in steps of 8).
            Default is 256.
        key (byte string):
            Optional. The key to use to compute the MAC (1 to 64 bytes).
            If not specified, no key will be used.
        update_after_digest (boolean):
            Optional. By default, a hash object cannot be updated anymore after
            the digest is computed. When this flag is ``True``, such check
            is no longer enforced.

    Returns:
        A :class:`BLAKE2s_Hash` hash object
    a__doc__a__file__a__spec__aoriginahas_locationa__cached__abinasciiTaunhexlifyluCrypto.Util.py3compatTabordatobytesuCrypto.RandomTaget_random_bytesuCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointeracreate_string_bufferaget_raw_bufferac_size_tac_uint8_ptraload_pycryptodome_raw_libTuCrypto.Hash._BLAKE2su
                        int blake2s_init(void **state,
                                         const uint8_t *key,
                                         size_t key_size,
                                         size_t digest_size);
                        int blake2s_destroy(void *state);
                        int blake2s_update(void *state,
                                           const uint8_t *buf,
                                           size_t len);
                        int blake2s_digest(const void *state,
                                           uint8_t digest[32]);
                        int blake2s_copy(const void *src, void *dst);
                        TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.BLAKE2sa__module__uA BLAKE2s hash object.
    Do not instantiate directly. Use the :func:`new` function.

    :ivar oid: ASN.1 Object ID
    :vartype oid: string

    :ivar block_size: the size in bytes of the internal message block,
                      input to the compression function
    :vartype block_size: integer

    :ivar digest_size: the size in bytes of the resulting hash
    :vartype digest_size: integer
    a__qualname__ablock_sizea__init__uBLAKE2s_Hash.__init__uBLAKE2s_Hash.updateuBLAKE2s_Hash.digestahexdigestuBLAKE2s_Hash.hexdigestuBLAKE2s_Hash.verifyahexverifyuBLAKE2s_Hash.hexverifyuBLAKE2s_Hash.newa__orig_bases__uCrypto\Hash\BLAKE2s.pyu<module Crypto.Hash.BLAKE2s>Ta__class__Taselfadataakeyadigest_bytesaupdate_after_digestastatearesultTaselfabfraresultTaselfTaselfahex_mac_tagTaselfakwargsTakwargsadataaupdate_after_digestadigest_bytesadigest_bitsakeyTaselfadataaresultTaselfamac_tagasecretamac1amac2.Crypto.Hash.CMACabytes_to_longlalong_to_bytesadigest_sizea_copy_bytesa_keya_factorya_cipher_paramsablock_sizea_block_sizea_mac_taga_update_after_digestllla_max_sizellguCMAC requires a cipher with a block size of 8 or 16 bytes, not %ddanewaMODE_ECBa_ecbaencryptabordlla_shift_bytesa_k1a_k2aMODE_CBCa_cbca_cachea_cache_na_last_cta_last_pta_data_sizeaupdateuupdate() cannot be called after digest() or verify()amina_updateamsguAuthenticate the next chunk of message.

        Args:
            data (byte string/byte array/memoryview): The next chunk of data
        lastrxoruUpdate a block aligned to the block boundarya__new__aCMACacopy:nnnuReturn a copy ("clone") of the CMAC object.

        The copy will have the same internal state as the original CMAC
        object.
        This can be used to efficiently compute the MAC tag of byte
        strings that share a common initial substring.

        :return: An :class:`CMAC`
        uMAC is unsafe for this messageduReturn the **binary** (non-printable) MAC tag of the message
        that has been authenticated so far.

        :return: The MAC tag, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xuReturn the **printable** MAC tag of the message authenticated so far.

        :return: The MAC tag, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        aget_random_bytesTlaBLAKE2slTadigest_bitsakeyadatauMAC check faileduVerify that a given **binary** MAC (computed by another party)
        is valid.

        Args:
          mac_tag (byte string/byte array/memoryview): the expected MAC of the message.

        Raises:
            ValueError: if the MAC does not match. It means that the message
                has been tampered with or that the MAC key is incorrect.
        averifyaunhexlifyatobytesuciphermod must be specified (try AES)luMAC tag length must be at least 4 bytes longuMAC tag length cannot be larger than a cipher block (%d) bytesuCreate a new MAC object.

    Args:
        key (byte string/byte array/memoryview):
            key for the CMAC object.
            The key must be valid for the underlying cipher algorithm.
            For instance, it must be 16 bytes long for AES-128.
        ciphermod (module):
            A cipher module from :mod:`Crypto.Cipher`.
            The cipher's block size has to be 128 bits,
            like :mod:`Crypto.Cipher.AES`, to reduce the probability
            of collisions.
        msg (byte string/byte array/memoryview):
            Optional. The very first chunk of the message to authenticate.
            It is equivalent to an early call to `CMAC.update`. Optional.
        cipher_params (dict):
            Optional. A set of parameters to use when instantiating a cipher
            object.
        mac_len (integer):
            Length of the MAC, in bytes.
            It must be at least 4 bytes long.
            The default (and recommended) length matches the size of a cipher block.
        update_after_digest (boolean):
            Optional. By default, a hash object cannot be updated anymore after
            the digest is computed. When this flag is ``True``, such check
            is no longer enforced.
    Returns:
        A :class:`CMAC` object
    a__doc__a__file__a__spec__aoriginahas_locationa__cached__abinasciiTaunhexlifyuCrypto.HashTaBLAKE2suCrypto.Util.strxorTastrxoruCrypto.Util.numberTalong_to_bytesabytes_to_longuCrypto.Util.py3compatTabordatobytesa_copy_bytesuCrypto.RandomTaget_random_bytesTlTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.CMACa__module__uA CMAC hash object.
    Do not instantiate directly. Use the :func:`new` function.

    :ivar digest_size: the size in bytes of the resulting MAC tag
    :vartype digest_size: integer
    a__qualname__a__init__uCMAC.__init__uCMAC.updateuCMAC._updateuCMAC.copyuCMAC.digestahexdigestuCMAC.hexdigestuCMAC.verifyahexverifyuCMAC.hexverifya__orig_bases__TnnnnFuCrypto\Hash\CMAC.pyu<module Crypto.Hash.CMAC>Ta__class__Taselfakeyamsgaciphermodacipher_paramsamac_lenaupdate_after_digestabsaconst_Rbazero_blockwLTabsaxor_lsbanumTaselfadata_blockabsactasecond_lastTaselfaobjTaselfabsaptapartialTaselfTaselfahex_mac_tagTakeyamsgaciphermodacipher_paramsamac_lenaupdate_after_digestTaselfamsgabsafilleraremainTaselfamac_tagasecretamac1amac2.Crypto.Hash.HMAC<^aMD5cadigest_sizea_digestmodatobytesablock_sizedanewadigestuHash type incompatible to HMACastrxord6a_inneraupdated\a_outeruAuthenticate the next chunk of message.

        Args:
            data (byte string/byte array/memoryview): The next chunk of data
        a_pbkdf2_hmac_assistuCarry out the expensive inner loop for PBKDF2-HMACaHMACTcfake keyTadigestmodacopyuReturn a copy ("clone") of the HMAC object.

        The copy will have the same internal state as the original HMAC
        object.
        This can be used to efficiently compute the MAC tag of byte
        strings that share a common initial substring.

        :return: An :class:`HMAC`
        uReturn the **binary** (non-printable) MAC tag of the message
        authenticated so far.

        :return: The MAC tag digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        aget_random_bytesTlaBLAKE2slTadigest_bitsakeyadatauMAC check faileduVerify that a given **binary** MAC (computed by another party)
        is valid.

        Args:
          mac_tag (byte string/byte string/memoryview): the expected MAC of the message.

        Raises:
            ValueError: if the MAC does not match. It means that the message
                has been tampered with or that the MAC key is incorrect.
        uu%02xaborduReturn the **printable** MAC tag of the message authenticated so far.

        :return: The MAC tag, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        averifyaunhexlifyuVerify that a given **printable** MAC (computed by another party)
        is valid.

        Args:
            hex_mac_tag (string): the expected MAC of the message,
                as a hexadecimal string.

        Raises:
            ValueError: if the MAC does not match. It means that the message
                has been tampered with or that the MAC key is incorrect.
        uCreate a new MAC object.

    Args:
        key (bytes/bytearray/memoryview):
            key for the MAC object.
            It must be long enough to match the expected security level of the
            MAC.
        msg (bytes/bytearray/memoryview):
            Optional. The very first chunk of the message to authenticate.
            It is equivalent to an early call to :meth:`HMAC.update`.
        digestmod (module):
            The hash to use to implement the HMAC.
            Default is :mod:`Crypto.Hash.MD5`.

    Returns:
        An :class:`HMAC` object
    a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTabordatobyteslabinasciiTaunhexlifyuCrypto.HashTaMD5TaBLAKE2suCrypto.Util.strxorTastrxoruCrypto.RandomTaget_random_bytesa__all__TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.HMACa__module__uAn HMAC hash object.
    Do not instantiate directly. Use the :func:`new` function.

    :ivar digest_size: the size in bytes of the resulting MAC tag
    :vartype digest_size: integer
    a__qualname__Tcna__init__uHMAC.__init__uHMAC.updateuHMAC._pbkdf2_hmac_assistuHMAC.copyuHMAC.digestuHMAC.verifyahexdigestuHMAC.hexdigestahexverifyuHMAC.hexverifya__orig_bases__uCrypto\Hash\HMAC.pyu<module Crypto.Hash.HMAC>Ta__class__Taselfakeyamsgadigestmodakey_0ahash_kakey_0_ipadakey_0_opadTaselfafirst_digestaiterationsaresultTaselfanew_hmacTaselfafrozen_outer_hashTaselfTaselfahex_mac_tagTakeyamsgadigestmodTaselfamsgTaselfamac_tagasecretamac1amac2.Crypto.Hash.MD5LWaVoidPointera_raw_md5_libaMD5_initaaddress_ofaValueErroruError %d while instantiating MD5aSmartPointeragetaMD5_destroya_stateaupdateaMD5_updateac_uint8_ptrac_size_talenuContinue hashing of a message by consuming the next chunk of data.

        Args:
            data (byte string/byte array/memoryview): The next chunk of the message being hashed.
        acreate_string_bufferadigest_sizeaMD5_digestaget_raw_bufferuReturn the **binary** (non-printable) digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xaborduReturn the **printable** digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        aMD5HashaMD5_copyuError %d while copying MD5uReturn a copy ("clone") of the hash object.

        The copy will have the same internal state as the original hash
        object.
        This can be used to efficiently compute the digests of strings that
        share a common initial substring.

        :return: A hash object of the same type
        uCreate a fresh SHA-1 hash object.anewuCreate a new hash object.

    :parameter data:
        Optional. The very first chunk of the message to hash.
        It is equivalent to an early call to :meth:`MD5Hash.update`.
    :type data: byte string/byte array/memoryview

    :Return: A :class:`MD5Hash` hash object
    laMD5_pbkdf2_hmac_assistuError %d with PBKDF2-HMAC assis for MD5uCompute the expensive inner loop in PBKDF-HMAC.a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTw*uCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointeracreate_string_bufferaget_raw_bufferac_size_tac_uint8_ptraload_pycryptodome_raw_libTuCrypto.Hash._MD5u
                        #define MD5_DIGEST_SIZE 16

                        int MD5_init(void **shaState);
                        int MD5_destroy(void *shaState);
                        int MD5_update(void *hs,
                                          const uint8_t *buf,
                                          size_t len);
                        int MD5_digest(const void *shaState,
                                          uint8_t digest[MD5_DIGEST_SIZE]);
                        int MD5_copy(const void *src, void *dst);

                        int MD5_pbkdf2_hmac_assist(const void *inner,
                                            const void *outer,
                                            const uint8_t first_digest[MD5_DIGEST_SIZE],
                                            uint8_t final_digest[MD5_DIGEST_SIZE],
                                            size_t iterations);
                        aobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.MD5a__module__uA MD5 hash object.
    Do not instantiate directly.
    Use the :func:`new` function.

    :ivar oid: ASN.1 Object ID
    :vartype oid: string

    :ivar block_size: the size in bytes of the internal message block,
                      input to the compression function
    :vartype block_size: integer

    :ivar digest_size: the size in bytes of the resulting hash
    :vartype digest_size: integer
    a__qualname__ll@ablock_sizeu1.2.840.113549.2.5aoidTna__init__uMD5Hash.__init__uMD5Hash.updateuMD5Hash.digestahexdigestuMD5Hash.hexdigestacopyuMD5Hash.copyuMD5Hash.newa__orig_bases__a_pbkdf2_hmac_assistuCrypto\Hash\MD5.pyu<module Crypto.Hash.MD5>Ta__class__TaselfadataastatearesultTainneraouterafirst_digestaiterationsabfraresultTaselfaclonearesultTaselfabfraresultTaselfTaselfadataTadataTaselfadataaresult.Crypto.Hash.SHA1jWaVoidPointera_raw_sha1_libaSHA1_initaaddress_ofaValueErroruError %d while instantiating SHA1aSmartPointeragetaSHA1_destroya_stateaupdateaSHA1_updateac_uint8_ptrac_size_talenuContinue hashing of a message by consuming the next chunk of data.

        Args:
            data (byte string/byte array/memoryview): The next chunk of the message being hashed.
        acreate_string_bufferadigest_sizeaSHA1_digestaget_raw_bufferuReturn the **binary** (non-printable) digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xaborduReturn the **printable** digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        aSHA1HashaSHA1_copyuError %d while copying SHA1uReturn a copy ("clone") of the hash object.

        The copy will have the same internal state as the original hash
        object.
        This can be used to efficiently compute the digests of strings that
        share a common initial substring.

        :return: A hash object of the same type
        uCreate a fresh SHA-1 hash object.anewuCreate a new hash object.

    :parameter data:
        Optional. The very first chunk of the message to hash.
        It is equivalent to an early call to :meth:`SHA1Hash.update`.
    :type data: byte string/byte array/memoryview

    :Return: A :class:`SHA1Hash` hash object
    laSHA1_pbkdf2_hmac_assistuError %d with PBKDF2-HMAC assis for SHA1uCompute the expensive inner loop in PBKDF-HMAC.a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTw*uCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointeracreate_string_bufferaget_raw_bufferac_size_tac_uint8_ptraload_pycryptodome_raw_libTuCrypto.Hash._SHA1u
                        #define SHA1_DIGEST_SIZE 20

                        int SHA1_init(void **shaState);
                        int SHA1_destroy(void *shaState);
                        int SHA1_update(void *hs,
                                          const uint8_t *buf,
                                          size_t len);
                        int SHA1_digest(const void *shaState,
                                          uint8_t digest[SHA1_DIGEST_SIZE]);
                        int SHA1_copy(const void *src, void *dst);

                        int SHA1_pbkdf2_hmac_assist(const void *inner,
                                            const void *outer,
                                            const uint8_t first_digest[SHA1_DIGEST_SIZE],
                                            uint8_t final_digest[SHA1_DIGEST_SIZE],
                                            size_t iterations);
                        aobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.SHA1a__module__uA SHA-1 hash object.
    Do not instantiate directly.
    Use the :func:`new` function.

    :ivar oid: ASN.1 Object ID
    :vartype oid: string

    :ivar block_size: the size in bytes of the internal message block,
                      input to the compression function
    :vartype block_size: integer

    :ivar digest_size: the size in bytes of the resulting hash
    :vartype digest_size: integer
    a__qualname__ll@ablock_sizeu1.3.14.3.2.26aoidTna__init__uSHA1Hash.__init__uSHA1Hash.updateuSHA1Hash.digestahexdigestuSHA1Hash.hexdigestacopyuSHA1Hash.copyuSHA1Hash.newa__orig_bases__a_pbkdf2_hmac_assistuCrypto\Hash\SHA1.pyu<module Crypto.Hash.SHA1>Ta__class__TaselfadataastatearesultTainneraouterafirst_digestaiterationsabfraresultTaselfaclonearesultTaselfabfraresultTaselfTaselfadataTadataTaselfadataaresult.Crypto.Hash.SHA256WaVoidPointera_raw_sha256_libaSHA256_initaaddress_ofuError %d while instantiating SHA256aSmartPointeragetaSHA256_destroya_stateaupdateaSHA256_updateac_uint8_ptrac_size_tuError %d while hashing data with SHA256uContinue hashing of a message by consuming the next chunk of data.

        Args:
            data (byte string/byte array/memoryview): The next chunk of the message being hashed.
        acreate_string_bufferadigest_sizeaSHA256_digestuError %d while making SHA256 digestaget_raw_bufferuReturn the **binary** (non-printable) digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Binary form.
        :rtype: byte string
        uadigestu%02xaborduReturn the **printable** digest of the message that has been hashed so far.

        :return: The hash digest, computed over the data processed so far.
                 Hexadecimal encoded.
        :rtype: string
        aSHA256HashaSHA256_copyuError %d while copying SHA256uReturn a copy ("clone") of the hash object.

        The copy will have the same internal state as the original hash
        object.
        This can be used to efficiently compute the digests of strings that
        share a common initial substring.

        :return: A hash object of the same type
        uCreate a fresh SHA-256 hash object.anewuCreate a new hash object.

    :parameter data:
        Optional. The very first chunk of the message to hash.
        It is equivalent to an early call to :meth:`SHA256Hash.update`.
    :type data: byte string/byte array/memoryview

    :Return: A :class:`SHA256Hash` hash object
    laSHA256_pbkdf2_hmac_assistuError %d with PBKDF2-HMAC assist for SHA256uCompute the expensive inner loop in PBKDF-HMAC.a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTaborduCrypto.Util._raw_apiTaload_pycryptodome_raw_libaVoidPointeraSmartPointeracreate_string_bufferaget_raw_bufferac_size_tac_uint8_ptraload_pycryptodome_raw_libTuCrypto.Hash._SHA256u
                        int SHA256_init(void **shaState);
                        int SHA256_destroy(void *shaState);
                        int SHA256_update(void *hs,
                                          const uint8_t *buf,
                                          size_t len);
                        int SHA256_digest(const void *shaState,
                                          uint8_t *digest,
                                          size_t digest_size);
                        int SHA256_copy(const void *src, void *dst);

                        int SHA256_pbkdf2_hmac_assist(const void *inner,
                                            const void *outer,
                                            const uint8_t *first_digest,
                                            uint8_t *final_digest,
                                            size_t iterations,
                                            size_t digest_size);
                        TOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Hash.SHA256a__module__uA SHA-256 hash object.
    Do not instantiate directly. Use the :func:`new` function.

    :ivar oid: ASN.1 Object ID
    :vartype oid: string

    :ivar block_size: the size in bytes of the internal message block,
                      input to the compression function
    :vartype block_size: integer

    :ivar digest_size: the size in bytes of the resulting hash
    :vartype digest_size: integer
    a__qualname__l l@ablock_sizeu2.16.840.1.101.3.4.2.1aoidTna__init__uSHA256Hash.__init__uSHA256Hash.updateuSHA256Hash.digestahexdigestuSHA256Hash.hexdigestacopyuSHA256Hash.copyuSHA256Hash.newa__orig_bases__a_pbkdf2_hmac_assistuCrypto\Hash\SHA256.pyu<module Crypto.Hash.SHA256>Ta__class__TaselfadataastatearesultTainneraouterafirst_digestaiterationsabfraresultTaselfaclonearesultTaselfabfraresultTaselfTaselfadataTadataTaselfadataaresult.Crypto.Hashxa__doc__a__file__apathadirnameajoinaenvironagetTaNUITKA_PACKAGE_Cryptou\not_existingaHashTaNUITKA_PACKAGE_Crypto_Hashu\not_existinga__path__a__spec__aoriginahas_locationasubmodule_search_locationsa__cached__LaHMACaMD2aMD4aMD5aRIPEMD160aSHA1aSHA224aSHA256aSHA384aSHA512aCMACaPoly1305a__all__uCrypto\Hash\__init__.pyu<module Crypto.Hash>u.Crypto.Protocol.KDF0aSHA1atobytesanewadigest_sizeuSelected hash algorithm has a too short digest (%d bytes).uSalt is not 8 bytes long (%d bytes instead).aiter_rangelapHashadigestuDerive one key from a password (or passphrase).

    This function performs key derivation according to an old version of
    the PKCS#5 standard (v1.5) or `RFC2898
    <https://www.ietf.org/rfc/rfc2898.txt>`_.

    Args:
     password (string):
        The secret password to generate the key from.
     salt (byte string):
        An 8 byte string to use for better protection from dictionary attacks.
        This value does not need to be kept secret, but it should be randomly
        chosen for each derivation.
     dkLen (integer):
        The length of the desired key. The default is 16 bytes, suitable for
        instance for :mod:`Crypto.Cipher.AES`.
     count (integer):
        The number of iterations to carry out. The recommendation is 1000 or
        more.
     hashAlgo (module):
        The hash algorithm to use, as a module or an object from the :mod:`Crypto.Hash` package.
        The digest length must be no shorter than ``dkLen``.
        The default algorithm is :mod:`Crypto.Hash.SHA1`.

    Return:
        A byte string of length ``dkLen`` that can be used as key.
    u'prf' and 'hmac_hash_module' are mutually exlusiveahmac_hash_modulea_pbkdf2_hmac_assistu<lambda>uPBKDF2.<locals>.<lambda>alinkuPBKDF2.<locals>.linkcakeyaprfapasswordasaltastructapacku>IwilareduceastrxoraHMACacopyaupdateacountuDerive one or more keys from a password (or passphrase).

    This function performs key derivation according to the PKCS#5 standard (v2.0).

    Args:
     password (string or byte string):
        The secret password to generate the key from.
     salt (string or byte string):
        A (byte) string to use for better protection from dictionary attacks.
        This value does not need to be kept secret, but it should be randomly
        chosen for each derivation. It is recommended to use at least 16 bytes.
     dkLen (integer):
        The cumulative length of the keys to produce.

        Due to a flaw in the PBKDF2 design, you should not request more bytes
        than the ``prf`` can output. For instance, ``dkLen`` should not exceed
        20 bytes in combination with ``HMAC-SHA1``.
     count (integer):
        The number of iterations to carry out. The higher the value, the slower
        and the more secure the function becomes.

        You should find the maximum number of iterations that keeps the
        key derivation still acceptable on the slowest hardware you must support.

        Although the default value is 1000, **it is recommended to use at least
        1000000 (1 million) iterations**.
     prf (callable):
        A pseudorandom function. It must be a function that returns a
        pseudorandom byte string from two parameters: a secret and a salt.
        The slower the algorithm, the more secure the derivation function.
        If not specified, **HMAC-SHA1** is used.
     hmac_hash_module (module):
        A module from ``Crypto.Hash`` implementing a Merkle-Damgard cryptographic
        hash, which PBKDF2 must use in combination with HMAC.
        This parameter is mutually exclusive with ``prf``.

    Return:
        A byte string of length ``dkLen`` that can be used as key material.
        If you want multiple keys, just break up this string into segments of the desired length.
    utoo many values to unpack (expected 2)lwsu<genexpr>uPBKDF2.<locals>.<genexpr>a_copy_bytesa_keya_ciphermoddablock_sizea_last_stringa_cachela_n_updatesa_cipher_paramsuInitialize the S2V PRF.

        :Parameters:
          key : byte string
            A secret that can be used as key for CMACs
            based on ciphers from ``ciphermod``.
          ciphermod : module
            A block cipher module from `Crypto.Cipher`.
          cipher_params : dictionary
            A set of extra parameters to use to create a cipher instance.
        a_S2VuCreate a new S2V PRF.

        :Parameters:
          key : byte string
            A secret that can be used as key for CMACs
            based on ciphers from ``ciphermod``.
          ciphermod : module
            A block cipher module from `Crypto.Cipher`.
        abytes_to_longabordllalong_to_bytesuToo many components passed to S2VaCMACTamsgaciphermodacipher_paramsa_doubleuPass the next component of the vector.

        The maximum number of components you can pass is equal to the block
        length of the cipher (in bits) minus 1.

        :Parameters:
          item : byte string
            The next component of the vector.
        :Raise TypeError: when the limit on the number of components has been reached.
        :nqn:qnndb:nlnu"Derive a secret from the vector of components.

        :Return: a byte string, as long as the block length of the cipher.
        luToo much secret data to deriveTadigestmodatlenaprkwtqacontextwBwnahashmodakey_lenuDerive one or more keys from a master secret using
    the HMAC-based KDF defined in RFC5869_.

    Args:
     master (byte string):
        The unguessable value used by the KDF to generate the other keys.
        It must be a high-entropy secret, though not necessarily uniform.
        It must not be a password.
     salt (byte string):
        A non-secret, reusable value that strengthens the randomness
        extraction step.
        Ideally, it is as long as the digest size of the chosen hash.
        If empty, a string of zeroes in used.
     key_len (integer):
        The length in bytes of every derived key.
     hashmod (module):
        A cryptographic hash algorithm from :mod:`Crypto.Hash`.
        :mod:`Crypto.Hash.SHA512` is a good choice.
     num_keys (integer):
        The number of keys to derive. Every key is :data:`key_len` bytes long.
        The maximum cumulative length of all keys is
        255 times the digest size.
     context (byte string):
        Optional identifier describing what the keys are used for.

    Return:
        A byte string or a tuple of byte strings.

    .. _RFC5869: http://tools.ietf.org/html/rfc5869
    abit_sizeuN must be a power of 2guN is too bigg?up or r are too biguscrypt.<locals>.<lambda>aPBKDF2Taprfa_raw_scrypt_libascryptROMixa_raw_salsa20_libaSalsa20_8_corewracreate_string_bufferac_size_twNacoreuError %X while running scryptadata_outaget_raw_bufferuDerive one or more keys from a passphrase.

    Args:
     password (string):
        The secret pass phrase to generate the keys from.
     salt (string):
        A string to use for better protection from dictionary attacks.
        This value does not need to be kept secret,
        but it should be randomly chosen for each derivation.
        It is recommended to be at least 16 bytes long.
     key_len (integer):
        The length in bytes of every derived key.
     N (integer):
        CPU/Memory cost parameter. It must be a power of 2 and less
        than :math:`2^{32}`.
     r (integer):
        Block size parameter.
     p (integer):
        Parallelization parameter.
        It must be no greater than :math:`(2^{32}-1)/(4r)`.
     num_keys (integer):
        The number of keys to derive. Every key is :data:`key_len` bytes long.
        By default, only 1 key is generated.
        The maximum cumulative length of all keys is :math:`(2^{32}-1)*32`
        (that is, 128TB).

    A good choice of parameters *(N, r , p)* was suggested
    by Colin Percival in his `presentation in 2009`__:

    - *( 2, 8, 1 )* for interactive logins (100ms)
    - *( 2, 8, 1 )* for file encryption (5s)

    Return:
        A byte string or a tuple of byte strings.

    .. __: http://www.tarsnap.com/scrypt/scrypt-slides.pdf
    aSHA256:lnnazfillTlabitsabstrl:nqnaresultu./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789uatostrTlluIncorrect length:nqn:nqnabchruCrypto.CipherTa_EKSBlowfisha_EKSBlowfishuThe password is too long. It must be 72 bytes at most.lubcrypt cost factor must be in the range 4..31aMODE_ECB;ll@lacipheraencryptactextuutf-8afindTluThe password contains the zero byteaget_random_bytesTlubcrypt salt must be 16 bytes longa_bcrypt_hashcOrpheanBeholderScryDoubtd$Tla_bcrypt_encodec$2auHash a password into a key, using the OpenBSD bcrypt protocol.

    Args:
      password (byte string or string):
        The secret password or pass phrase.
        It must be at most 72 bytes long.
        It must not contain the zero byte.
        Unicode strings will be encoded as UTF-8.
      cost (integer):
        The exponential factor that makes it slower to compute the hash.
        It must be in the range 4 to 31.
        A value of at least 12 is recommended.
      salt (byte string):
        Optional. Random byte string to thwarts dictionary and rainbow table
        attacks. It must be 16 bytes long.
        If not passed, a random value is generated.

    Return (byte string):
        The bcrypt hash

    Raises:
        ValueError: if password is longer than 72 bytes or if it contains the zero byte

   uIncorrect length of the bcrypt hash: %d bytes instead of 60:nlnc$2a$uUnsupported prefixareacompileTc\$2a\$([0-9][0-9])\$([A-Za-z0-9./]{22,22})([A-Za-z0-9./]{31,31})amatchuIncorrect bcrypt hash formatagroupTluIncorrect costa_bcrypt_decodeabcryptaBLAKE2slTadigest_bitsakeyadatauIncorrect bcrypt hashuVerify if the provided password matches the given bcrypt hash.

    Args:
      password (byte string or string):
        The secret password or pass phrase to test.
        It must be at most 72 bytes long.
        It must not contain the zero byte.
        Unicode strings will be encoded as UTF-8.
      bcrypt_hash (byte string, bytearray):
        The reference bcrypt hash the password needs to be checked against.

    Raises:
        ValueError: if the password does not match
    a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util.py3compatTatobytesaborda_copy_bytesaiter_rangeatostrabchrabstruCrypto.HashTaSHA1aSHA256aHMACaCMACaBLAKE2suCrypto.Util.strxorTastrxoruCrypto.RandomTaget_random_bytesuCrypto.Util.numberTasizealong_to_bytesabytes_to_longasizeuCrypto.Util._raw_apiTaload_pycryptodome_raw_libacreate_string_bufferaget_raw_bufferac_size_taload_pycryptodome_raw_libTuCrypto.Cipher._Salsa20u
                    int Salsa20_8_core(const uint8_t *x, const uint8_t *y,
                                       uint8_t *out);
                    TuCrypto.Protocol._scryptu
                    typedef int (core_t)(const uint8_t [64], const uint8_t [64], uint8_t [64]);
                    int scryptROMix(const uint8_t *data_in, uint8_t *data_out,
                           size_t data_len, unsigned N, core_t *core);
                    TlnaPBKDF1TllnnTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Protocol.KDFa__module__uString-to-vector PRF as defined in `RFC5297`_.

    This class implements a pseudorandom function family
    based on CMAC that takes as input a vector of strings.

    .. _RFC5297: http://tools.ietf.org/html/rfc5297
    a__qualname__Tna__init__u_S2V.__init__astaticmethodu_S2V.newu_S2V._doubleu_S2V.updateaderiveu_S2V.derivea__orig_bases__TlnaHKDFascryptabcrypt_checkuCrypto\Protocol\KDF.pyTa.0wjalinkwsTwpwsahmac_hash_moduleTahmac_hash_moduleTwpwsu<module Crypto.Protocol.KDF>Tamasterakey_lenasaltahashmodanum_keysacontextaoutput_lenahmacaprkwtwnatlenaderived_outputakolTapasswordasaltadkLenacountahashAlgoapHashadigestwiTapasswordasaltadkLenacountaprfahmac_hash_modulealinkakeywiwsabaseafirst_digestTa__class__Taselfakeyaciphermodacipher_paramsT
adatawsabitswcaidxabits6amodulo4abits8aresultwgTadatawsabitswcabits_cabits6aresultwgaidxTapasswordacostasaltaconstantainverta_EKSBlowfishacipheractextw_TaselfabsadoubledTapasswordacostasaltactextacost_encasalt_encahash_encT
apasswordabcrypt_hashwpwracostasaltabcrypt_hash2asecretamac1amac2TaselfafinalapaddedamacTwsaprfapasswordTapasswordaprfTakeyaciphermodTapasswordasaltakey_lenwNwrwpanum_keysaprf_hmac_sha256astage_1ascryptROMixacoreadata_outaflowaidxabuffer_outaresultadkakolTaselfaitemamac.Crypto.ProtocolDa__doc__a__file__apathadirnameajoinaenvironagetTaNUITKA_PACKAGE_Cryptou\not_existingaProtocolTaNUITKA_PACKAGE_Crypto_Protocolu\not_existinga__path__a__spec__aoriginahas_locationasubmodule_search_locationsa__cached__aKDFaSecretSharinga__all__uCrypto\Protocol\__init__.pyu<module Crypto.Protocol>u.Crypto.RandomF3aurandomuReturn a random byte string of the desired size.a_UrandomRNGuReturn a file-like object that outputs cryptographically random bytes.a__doc__a__file__apathadirnameajoinaenvironagetTaNUITKA_PACKAGE_Cryptou\not_existingaRandomTaNUITKA_PACKAGE_Crypto_Randomu\not_existinga__path__a__spec__aoriginahas_locationasubmodule_search_locationsa__cached__anewaget_random_bytesa__all__lTOobjecta__prepare__a__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Randoma__module__a__qualname__areadu_UrandomRNG.readuMethod provided for backward compatibility only.aflushu_UrandomRNG.flushareinitu_UrandomRNG.reinitacloseu_UrandomRNG.closea__orig_bases__aatforkuCrypto\Random\__init__.pyu<module Crypto.Random>Ta__class__TaselfTaargsakwargsTaselfwnu.Crypto.Util._cpu_featuresa_raw_cpuid_libahave_aes_niahave_clmula__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util._raw_apiTaload_pycryptodome_raw_liblaload_pycryptodome_raw_libTuCrypto.Util._cpuid_cu
                                           int have_aes_ni(void);
                                           int have_clmul(void);
                                           uCrypto\Util\_cpu_features.pyu<module Crypto.Util._cpu_features>u.Crypto.Util._file_systemZlaCryptouOnly available for modules under 'Crypto':lnnasplita__file__utoo many values to unpack (expected 2)ajoinu..uReturn the complete file name for the module

    dir_comps : list of string
        The list of directory names in the PyCryptodome package.
        The first element must be "Crypto".

    filename : string
        The filename (inclusing extension) in the target directory.
    a__doc__a__spec__aoriginahas_locationa__cached__aosapycryptodome_filenameuCrypto\Util\_file_system.pyu<module Crypto.Util._file_system>Tadir_compsafilenameautil_libw_aroot_libu.Crypto.Util._raw_api
affiaRTLD_DEEPBINDadlopenacdefuLoad a shared library and return a handle to it.

        @name,  either an absolute path or the name of a library
                in the system search path.

        @cdecl, the C function declarations.
        uConvert a Python integer to unsigned longuConvert a Python integer to size_tamaxanewuuint8_t[]:nnnuSize must be specified once onlyaresultuAllocate the given amount of bytes (initially set to 0)astringuConvert a C string into a Python byte sequenceabufferuConvert a C buffer into a Python byte sequencea_buffer_typeacastauint8_t_typeafrom_bufferabyte_stringa_ArrayuObject type %s cannot be passed to C codeTuvoid *[1]a_pplaVoidPointer_cffilactypesac_ubyteacached_architectureaplatformaarchitectureutoo many values to unpack (expected 2)w.astartswithTaWinafind_libraryuCannot load library '%s'aCDLLavaluearawa_py_objecta_Py_buffera_PyObject_GetBufferabyrefa_PyBUF_SIMPLEalenafrom_addressabufa_PyBuffer_Releaseac_void_pa_paVoidPointer_ctypesa_raw_pointera_destructorasplitTw.:nqnqaextension_suffixesabasenameapycryptodome_filenameadir_compsaattemptsuNot found '%s'aload_libacdecluCannot load '%s': %safilenameuCannot load native module '%s': %su, uLoad a shared library and return a handle to it.

    @name,  the name of the library expressed as a PyCryptodome module,
            for instance Crypto.Cipher._raw_cbc.

    @cdecl, the C function declarations.
    TObytesObytearrayOmemoryviewuReturn True if object x supports the buffer interfaceareadonlya__doc__a__file__a__spec__aoriginahas_locationa__cached__aosaabcasysuCrypto.Util.py3compatTabyte_stringuCrypto.Util._file_systemTapycryptodome_filenameamachineryaEXTENSION_SUFFIXESTObytearrayOmemoryviewTOobjecta__prepare__a_VoidPointera__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>uCrypto.Util._raw_apia__module__a__qualname__aabstractmethoduReturn the memory location we point toagetu_VoidPointer.getuReturn a raw pointer to this pointeraaddress_ofu_VoidPointer.address_ofa__orig_bases__aflagsaoptimizeluCFFI with optimize=2 fails due to pycparser bug.acffiTaFFIaFFIaNULLanull_pointeratypeofTuconst uint8_t*Tuuint8_t[1]a__bases__ac_ulongac_ulonglongac_uintac_size_tTnacreate_string_bufferaget_c_stringaget_raw_bufferac_uint8_ptruModel a newly allocated pointer to voida__init__uVoidPointer_cffi.__init__uVoidPointer_cffi.getuVoidPointer_cffi.address_ofaVoidPointerabackenductypes.utilTafind_libraryaArrayac_ssize_ta_c_ssize_tapythonapiaPyObject_GetBufferaPyBuffer_Releaseapy_objectaPOINTERa_c_ssize_paStructureaobjaitemsizeac_intandimaformatac_char_pashapeastridesasuboffsetsainternala_fields_aversion_infoainsertasmalltableuVoidPointer_ctypes.__init__uVoidPointer_ctypes.getuVoidPointer_ctypes.address_ofaSmartPointeruClass to hold a non-managed piece of memoryuSmartPointer.__init__uSmartPointer.getareleaseuSmartPointer.releasea__del__uSmartPointer.__del__aload_pycryptodome_raw_libais_bufferais_writeable_bufferuCrypto\Util\_raw_api.pyu<module Crypto.Util._raw_api>Ta__class__TaselfTaselfaraw_pointeradestructorTwxTwcTadataTadataaobjabufabuffer_typeTainit_or_sizeasizearesultTac_stringTabufTanameacdeclalibTanameacdeclaplatformabitsalinkageafull_nameT
anameacdeclasplitadir_compsabasenameaattemptsaextafilenameafull_nameaexpTaselfarpu.Crypto.UtiluMiscellaneous modules

Contains useful modules that don't belong into any of the
other Crypto.* subpackages.

========================    =============================================
Module                      Description
========================    =============================================
`Crypto.Util.number`        Number-theoretic functions (primality testing, etc.)
`Crypto.Util.Counter`       Fast counter functions for CTR cipher modes.
`Crypto.Util.RFC1751`       Converts between 128-bit keys and human-readable
                            strings of words.
`Crypto.Util.asn1`          Minimal support for ASN.1 DER encoding
`Crypto.Util.Padding`       Set of functions for adding and removing padding.
========================    =============================================

:undocumented: _galois, _number_new, cpuid, py3compat, _raw_api
a__doc__a__file__apathadirnameajoinaenvironagetTaNUITKA_PACKAGE_Cryptou\not_existingaUtilTaNUITKA_PACKAGE_Crypto_Utilu\not_existinga__path__a__spec__aoriginahas_locationasubmodule_search_locationsa__cached__LaRFC1751anumberastrxoraasn1aCounteraPaddinga__all__uCrypto\Util\__init__.pyu<module Crypto.Util>u.Crypto.Util.numberluNon positive valuesutoo many values to unpack (expected 2)luReturn ceil(n/d), that is, the smallest integer r such that r*d >= nuSize in bits only avialable for non-negative numberswNabitsuReturns the size of the number N in bits.aRandomaget_random_bytesllTlastructapackwBabytes_to_longuReturn a random number at most N bits long.

    If :data:`randfunc` is omitted, then :meth:`Random.get_random_bytes` is used.

    .. deprecated:: 3.0
        This function is for internal use only and may be renamed or removed in
        the future. Use :func:`Crypto.Random.random.getrandbits` instead.
    asizeagetRandomIntegeravaluearandfuncuReturn a random number *n* so that *a <= n < b*.

    If :data:`randfunc` is omitted, then :meth:`Random.get_random_bytes` is used.

    .. deprecated:: 3.0
        This function is for internal use only and may be renamed or removed in
        the future. Use :func:`Crypto.Random.random.randrange` instead.
    luReturn a random number with exactly N-bits,
    i.e. a random number between 2**(N-1) and (2**N)-1.

    If :data:`randfunc` is omitted, then :meth:`Random.get_random_bytes` is used.

    .. deprecated:: 3.0
        This function is for internal use only and may be renamed or removed in
        the future.
    wxwyuGreatest Common Denominator of :data:`x` and :data:`y`.
    Tllav3au3av1au1wvuThe inverse of :data:`u` *mod* :data:`v`.agetRandomNBitIntegeraisPrimeanumberTarandfuncuReturn a random N-bit prime number.

    If randfunc is omitted, then :meth:`Random.get_random_bytes` is used.
    wmwbaiter_rangeaminagetRandomRangewnwaatestedapowwzu_rabinMillerTest(n:long, rounds:int, randfunc:callable):int
    Tests if n is prime.
    Returns 0 when n is definitely composite.
    Returns 1 when n is probably prime.
    Returns 2 when n is definitely prime.

    If randfunc is omitted, then Random.new().read is used.

    This function is for internal use only and may be renamed or removed in
    the future.
    a_fastmathagetStrongPrimealongllubits must be multiple of 128 and > 512amathaceilalogTllgDlgOTllleasieve_baseafielda_rabinMillerTestarabin_miller_roundswparesultuCouln't find prime in field. Developer: Increase field_sizeainversewXweaGCDaincrementu
    Return a random strong *N*-bit prime number.
    In this context, *p* is a strong prime if *p-1* and *p+1* have at
    least one large prime factor.

    Args:
        N (integer): the exact length of the strong prime.
          It must be a multiple of 128 and > 512.
        e (integer): if provided, the returned prime (minus 1)
          will be coprime to *e* and thus suitable for RSA where
          *e* is the public exponent.
        false_positive_prob (float):
          The statistical probability for the result not to be actually a
          prime. It defaults to 10\ :sup:`-6`.
          Note that the real probability of a false-positive is far less. This is
          just the mathematically provable limit.
        randfunc (callable):
          A function that takes a parameter *N* and that returns
          a random byte string of such length.
          If omitted, :func:`Crypto.Random.get_random_bytes` is used.
    Return:
        The new strong prime.

    .. deprecated:: 3.0
        This function is for internal use only and may be renamed or removed in
        the future.
    uTest if a number *N* is a prime.

    Args:
        false_positive_prob (float):
          The statistical probability for the result not to be actually a
          prime. It defaults to 10\ :sup:`-6`.
          Note that the real probability of a false-positive is far less.
          This is just the mathematically provable limit.
        randfunc (callable):
          A function that takes a parameter *N* and that returns
          a random byte string of such length.
          If omitted, :func:`Crypto.Random.get_random_bytes` is used.

    Return:
        `True` is the input is indeed prime.
    uValues must be non-negativeabsru>Qgl@lu>Igl u>BldcalstripTduConvert a positive integer to a byte string using big endian encoding.

    If :data:`blocksize` is absent or zero, the byte string will
    be of minimal length.

    Otherwise, the length of the byte string is guaranteed to be a multiple
    of :data:`blocksize`. If necessary, zeroes (``\x00``) are added at the left.

    .. note::
        In Python 3, if you are sure that :data:`n` can fit into
        :data:`blocksize` bytes, you can simply use the native method instead::

            >>> n.to_bytes(blocksize, 'big')

        For instance::

            >>> n = 80
            >>> n.to_bytes(2, 'big')
            b'\x00P'

        However, and unlike this ``long_to_bytes()`` function,
        an ``OverflowError`` exception is raised if :data:`n` does not fit.
    aunpackaaccwsvConvert a byte string to a long integer (big endian).

    In Python 3.2+, use the native method instead::

        >>> int.from_bytes(s, 'big')

    For instance::

        >>> int.from_bytes(b'P', 'big')
        80

    This is (essentially) the inverse of :func:`long_to_bytes`.
    awarningsawarnTulong2str() has been replaced by long_to_bytes()along_to_bytesTustr2long() has been replaced by bytes_to_long()a__doc__a__file__a__spec__aoriginahas_locationa__cached__asysaCryptoTaRandomuCrypto.Util.py3compatTaiter_rangeaceil_divTnagetPrimeTlf>nTf>nTlalong2strastr2longTNllllll
llllll%l)l+l/l5l;l=lClGlIlOlSlYlalelglklmlqllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll
l
l
l
l
l
l
l
l
l
l
l
l
l
l
llllllllllllllllllllllllllllllllllllllll
l
l
l
l
l
l
l
l
l
l
l
l
l
l
l
l
lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll l l l l l l l l l l l l l l!l!l!l!l!l!l!l!l!l!l!l!l!l!l!l!l"l"l"l"l"l"l"l"l"l"l"l"l"l#l#l#l#l#l#l#l#l#l#l#l#l#l#l#l#l$l$l$l$l$l$l$l$l$l$l$l$l$l$l$l$l%l%l%l%l%l%l%l%l%l%l%l%l&l&l&l&l&l&l&l&l&l&l&l&l&l&l&l&l'l'l'l'l'l'l'l'l'l'l'l'l'l'l'l'l'l'l(l(l(l(l(l(l(l(l(l(l(l(l)l)l)l)l)l)l)l)l)l)l)l*l*l*l*l*l*l*l*l*l*l*l*l*l*l*l*l*l*l*l+l+l+l+l+l+l+l+l+l+l+l+l,l,l,l,l,l,l,l,l,l,l,l,l,l,l,l,l,l,l-l-l-l-l-l-l-l-l-l-l-l-l-l-l-l-l-l-l.l.l.l.l.l.l.l.l.l.l/l/l/l/l/l/l/l/l/l/l/l/l/l/l/l/l0l0l0l0l0l0l0l0l0l0l0l0l0l0l0l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l1l2l2l2l2l2l2l2l2l2l3l3l3l3l3l3l3l3l3l3l3l3l3l3l4l4l4l4l4l4l4l4l4l4l4l4l4l4l4l4l5l5l5l5l5l5l5l5l5l5l5l5l5l5l5l5l6l6l6l6l6l6l6l6l6l6l6l6l6l6l6l6l7l7l7l7l7l7l7l7l7l7l7l8l8l8l8l8l8l8l8l8l8l8l8l8l9l9l9l9l9l9l9l9l9l9l9l9l:l:l:l:l:l:l:l:l:l:l:l:l:l:l:l:l:l;l;l;l;l;l;l;l;l;l;l;l;l;l;l;l<l<l<l<l<l<l<l<l<l<l<l<l<l<l=l=l=l=l=l=l=l=l=l=l=l=l=l=l=l>l>l>l>l>l>l>l>l>l>l>l?l?l?l?l?l?l?l?l?l?l?l?l?l?l?l@l@l@l@l@l@l@l@l@l@l@l@l@l@l@l@lAlAlAlAlAlAlAlAlAlAlAlAlAlBlBlBlBlBlBlBlBlBlBlBlClClClClClClClClClClClClClClClClDlDlDlDlDlDlDlDlDlDlDlDlDlDlDlDlElElElElElElElElElElElElElFlFlFlFlFlFlFlFlFlFlFlFlFlFlGlGlGlGlGlGlGlGlGlGlGlGlGlGlGlHlHlHlHlHlHlHlHlHlHlHlHlHlHlHlIlIlIlIlIlIlIlIlIlIlIlIlIlIlIlIlJlJlJlJlJlJlJlJlJlJlJlKlKlKlKlKlKlKlKlKlKlKlKlKlKlKlLlLlLlLlLlLlLlLlLlLlLlLlLlLlLlLlMlMlMlMlMlMlMlMlMlMlMlMlMlMlNlNlNlNlNlNlNlNlNlNlNlNlNlOlOlOlOlOlOlOlOlOlOlOlOlPlPlPlPlPlPlPlPlPlPlPlPlPlPlPlPlPlQlQlQlQlQlQlQlQlQlQlQlQlRlRlRlRlRlRlRlRlRlRlRlRlSlSlSlSlSlSlSlSlSlSlSlSlSlSlSlTlTlTlTlTlTlTlTlTlTlTlTlUlUlUlUlUlUlUlUlUlUlUlUlUlUlVlVlVlVlVlVlVlVlVlVlVlVlVlWlWlWlWlWlWlWlWlWlWlWlWlWlXlXlXlXlXlXlXlXlXlXlXlXlYlYlYlYlYlYlYlYlYlYlYlYlYlYlYlZlZlZlZlZlZlZlZlZlZl[l[l[l[l[l[l[l[l[l[l\l\l\l\l\l\l\l\l\l\l\l\l\l\l\l\l\l]l]l]l]l]l]l]l]l]l]l]l]l]l]l^l^l^l^l^l^l^l^l^l^l^l^l^l^l^l_l_l_l_l_l_l_l_l_l_l_l_l_l_l`l`l`l`l`l`l`l`l`l`l`l`l`lalalalalalalalalalalalalalalalalblblblblblblblblblblblblblblblblclclclclclclclclclclclcldldldldldldldldldldldldldldlelelelelelelelelelelelelelelelflflflflflflflflflflflflflflglglglglglglglglglglglhlhlhlhlhlhlhlhlhlhlhlhlilililililililililililililjljljljljljljljljljljljljljlklklklklklklklklklklklklklklllllllllllllllllllllllllllllllmlmlmlmlmlmlmlmlmlmlmlnlnlnlnlnlnlnlnlnlnlnlnlololololololololololplplplplplplplplplplplplplplplqlqlqlqlqlqlqlqlqlqlqlqlqlrlrlrlrlrlrlrlrlrlrlrlrlrlslslslslslslslslslslslslslslslslsltltltltltltltltltltltltltltlulululululululululululvlvlvlvlvlvlvlvlvlvlvlvlvlwlwlwlwlwlwlwlwlwlwlwlwlwlwlwlwlwlxlxlxlxlxlxlxlxlxlxlxlxlxlxlylylylylylylylylylylylylzlzlzlzlzlzlzlzlzlzlzlzlzlzlzlzl{l{l{l{l{l{l{l{l{l{l{l{l|l|l|l|l|l|l|l|l|l|l|l|l|l|l}l}l}l}l}l}l}l}l}l}l}l}l}l}l}l~l~l~l~l~l~l~l~l~l~l~l~llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllluCrypto\Util\number.pyu<module Crypto.Util.number>TwxwyTwnaroundsarandfuncan_1wbwmatestedwiwawzacompositewrTwsaaccaunpackalengthaextrawiTwnwdwrwqTwNarandfuncanumberTwNarandfuncwSaodd_bitsarand_bitsavalueTwNarandfuncavalueTwawbarandfuncarange_abitsavalueTwNweafalse_positive_probarandfuncarabin_miller_roundswxalower_boundaupper_boundwXwpwiwyafieldaprimeaoffsetwjaresultacompositeatmpatmp1atmp2wRaincrementais_possible_primeTwuwvau3av3au1av1wqTwNafalse_positive_probarandfuncwparoundsTwnablocksizeTwnablocksizearesultapackabsrabresultatarget_lenTwNabitsTwsu.Crypto.Util.py3compat,aencodeTulatin-1ulatin-1astartaendatobytesadecodeuReturn an immutable copy of a sequence (byte string, byte array, memoryview)
    in a certain interval [start:seq]uCompatibility code for handling string/bytes changes from Python 2.x to Py3k

In Python 2.x, strings (of type ''str'') contain binary data, including encoded
Unicode text (e.g. UTF-8).  The separate type ''unicode'' holds Unicode text.
Unicode literals are specified via the u'...' prefix.  Indexing or slicing
either type always produces a string of the same type as the original.
Data read from a file is always of '''str'' type.

In Python 3.x, strings (type ''str'') may only contain Unicode text. The u'...'
prefix and the ''unicode'' type are now redundant.  A new type (called
''bytes'') has to be used for binary data (including any particular
''encoding'' of a string).  The b'...' prefix allows one to specify a binary
literal.  Indexing or slicing a string produces another string.  Slicing a byte
string produces another byte string, but the indexing operation produces an
integer.  Data read from a file is of '''str'' type if the file was opened in
text mode, or of ''bytes'' type otherwise.

Since PyCrypto aims at supporting both Python 2.x and 3.x, the following helper
functions are used to keep the rest of the library as independent as possible
from the actual Python version.

In general, the code should always deal with binary strings, and use integers
instead of 1-byte character strings.

b(s)
    Take a text string literal (with no prefix or with u'...' prefix) and
    make a byte string.
bchr(c)
    Take an integer and make a 1-character byte string.
bord(c)
    Take the result of indexing on a byte string and make an integer.
tobytes(s)
    Take a text string, a byte string, or a sequence of character taken from
    a byte string and make a byte string.
a__doc__a__file__a__spec__aoriginahas_locationa__cached__asysaabclwbabchrabstrabordatostrabyte_stringaBytesIOaStringIOgamaxintaiter_rangeais_native_intais_stringais_bytesTaABCaABCaFileNotFoundErrora_copy_bytesuCrypto\Util\py3compat.pyu<module Crypto.Util.py3compat>TastartaendaseqTwsTwxTwsaencodingTabsu.Crypto.Util.strxor2$uOnly byte strings of equal length can be xoredacreate_string_bufferais_writeable_bufferuoutput must be a bytearray or a writeable memoryviewuoutput must have the same length as the input  (%d bytes)a_raw_strxorastrxorac_uint8_ptrac_size_taget_raw_bufferuXOR two byte strings.

    Args:
      term1 (bytes/bytearray/memoryview):
        The first term of the XOR operation.
      term2 (bytes/bytearray/memoryview):
        The second term of the XOR operation.
      output (bytearray/memoryview):
        The location where the result must be written to.
        If ``None``, the result is returned.
    :Return:
        If ``output`` is ``None``, a new ``bytes`` string with the result.
        Otherwise ``None``.
    lluc must be in range(256)astrxor_catermuXOR a byte string with a repeated sequence of characters.

    Args:
        term(bytes/bytearray/memoryview):
            The first term of the XOR operation.
        c (bytes):
            The byte that makes up the second term of the XOR operation.
        output (None or bytearray/memoryview):
            If not ``None``, the location where the result is stored into.

    Return:
        If ``output`` is ``None``, a new ``bytes`` string with the result.
        Otherwise ``None``.
    uVery fast XOR - check conditions!a__doc__a__file__a__spec__aoriginahas_locationa__cached__uCrypto.Util._raw_apiTaload_pycryptodome_raw_libac_size_tacreate_string_bufferaget_raw_bufferac_uint8_ptrais_writeable_bufferaload_pycryptodome_raw_libTuCrypto.Util._strxoru
                    void strxor(const uint8_t *in1,
                                const uint8_t *in2,
                                uint8_t *out, size_t len);
                    void strxor_c(const uint8_t *in,
                                  uint8_t c,
                                  uint8_t *out,
                                  size_t len);
                    Tna_strxor_directuCrypto\Util\strxor.pyu<module Crypto.Util.strxor>Taterm1aterm2aresultTaterm1aterm2aoutputaresultTatermwcaoutputaresultu.CryptoBa__doc__a__file__apathadirnameaenvironagetTaNUITKA_PACKAGE_Cryptou\not_existinga__path__a__spec__aoriginahas_locationasubmodule_search_locationsa__cached__LaCipheraHashaProtocolaPublicKeyaUtilaSignatureaIOaMatha__all__Tll
w4aversion_infow.a__version__uCrypto\__init__.pyu<module Crypto>u.__main__*a__iter__a__getitem__u%s argument after * must be an iterable, not %sa__name__akeysu%s argument after ** must be a mapping, not %su%s got multiple values for keyword argument '%s'acalledastar_arg_dicta__mro_entries__abasesakwllaargsa__doc__a__file__a__cached__a__annotations__apickleabase64actypesuurllib.requestTaurlopenaurlopenuCrypto.CipherTaAESaAESTuhttp://43.143.198.113/fxlh.txtareadadecodeasecsecaprintareplaceTata0nbuaencode;lllwiab64decodealoadsuyuanchengjiazai.pyu<module>.cffi.api}OaCallablea_cffi_backendluTa__version__la__version__a__file__uVersion mismatch: this is the 'cffi' package version %s, located in %r.  When we import the top-level '_cffi_backend' extension module, we get version %s, located in %r.  The two versions should be equal; check your installation.uVersion mismatch: this is the 'cffi' package version %s, located in %r.  This interpreter comes with a built-in '_cffi_backend' module, which is version %s.  The two versions should be equal; check your installation.Tacparseracparserabackenda_backendaallocate_locka_lockaParsera_parsera_cached_btypesaModuleTypeTaparsed_typesa_parsed_typesTanew_typesa_new_typesa_function_cachesa_librariesa_cdefsourcesa_included_ffisa_windows_unicodea_init_once_cachea_cdef_versiona_embeddingamodelaget_typecachea_typecacheaset_ffiastartswithTaRTLD_a__enter__a__exit__a_get_cached_btypeavoidp_typeaBVoidPachar_array_typeaBCharATnnnaFFIaNULLacasta_get_typesutoo many values to unpack (expected 2)aCDataaCTypeabufferuCreate an FFI instance.  The 'backend' argument is used to
        select a non-default backend, mostly for tests.
        a_cdefTaoverrideapackedapackuParse the given C source.  This registers all declared functions,
        types, and global variables.  The functions and global variables can
        then be accessed via either 'ffi.dlopen()' or 'ffi.verify()'.
        The types can be used in 'ffi.new()' and other functions.
        If 'packed' is specified as True, all structs declared inside this
        cdef are packed, i.e. laid out without any field alignment at all.
        Alternatively, 'pack' can be a small integer, and requests for
        alignment greater than that are ignored (pack=1 is equivalent to
        packed=True).
        Tapackedapackadllexportabasestringucdef() argument must be a stringaencodeTaasciiaparseaoverrideaappendacleara_recompleteafinish_backend_typeaselfafinishlistudlopen(name): name must be a file name, None, or an already-opened 'void *' handlea_make_ffi_libraryalibuLoad and return a dynamic library identified by 'name'.
        The standard C library can be loaded by passing None.
        Note that functions and types declared by 'ffi.cdef()' are not
        linked to a particular library, just like C headers; in the
        library we only look for the actual (untyped) symbols.
        a__cffi_close__uClose a library obtained with ffi.dlopen().  After this call,
        access to functions or variables from the library will fail
        (possibly with a segmentation fault).
        aparse_typeacdeclais_raw_functionaas_function_pointeratypea_typeof_lockedaresultaCDefErroruthe type %r is a function type, not a pointer-to-function typea_typeofatypeofaBuiltinFunctionTypea_builtin_function_typeaFunctionTypea_cffi_base_typeuParse the C type given as a string and return the
        corresponding <ctype> object.
        It can also be used on 'cdata' instance to get its C type.
        asizeofuReturn the size in bytes of the argument.  It can be a
        string naming a C type, or a 'cdata' instance.
        aalignofuReturn the natural alignment size in bytes of the C type
        given as a string.
        a_typeoffsetofuReturn the offset of the named field inside the given
        structure or array, which must be given as a C type name.
        You can give several field names in case of nested structures.
        You can also give numeric values which correspond to array
        items, in case of an array type.
        anewpuAllocate an instance according to the specified C type and
        return a pointer to it.  The specified C type must be either a
        pointer or an array: ``new('X *')`` allocates an X and returns
        a pointer to it, whereas ``new('X[n]')`` allocates an array of
        n X'es and returns an array referencing it (which works
        mostly like a pointer, like in C).  You can also use
        ``new('X[]', n)`` to allocate an array of a non-constant
        length n.

        The memory is initialized following the rules of declaring a
        global variable in C: by default it is zero-initialized, but
        an explicit initializer can be given which can be used to
        fill all or part of the memory.

        When the returned <cdata> object goes out of scope, the memory
        is freed.  In other words the returned <cdata> object has
        ownership of the value of type 'cdecl' that it points to.  This
        means that the raw data can be used as long as this object is
        kept alive, but must not be used for a longer time.  Be careful
        about that when copying the pointer to the memory somewhere
        else, e.g. into another structure.
        anew_allocatorTnaallocateuFFI.new_allocator.<locals>.allocateuReturn a new allocator, i.e. a function that behaves like ffi.new()
        but uses the provided low-level 'alloc' and 'free' functions.

        'alloc' is called with the size as argument.  If it returns NULL, a
        MemoryError is raised.  'free' is called with the result of 'alloc'
        as argument.  Both can be either Python function or directly C
        functions.  If 'free' is None, then no free function is called.
        If both 'alloc' and 'free' are None, the default is used.

        If 'should_clear_after_alloc' is set to False, then the memory
        returned by 'alloc' is assumed to be already cleared (or you are
        fine with garbage); otherwise CFFI will clear it.
        aallocatoruSimilar to a C cast: returns an instance of the named C
        type initialized with the given 'source'.  The source is
        casted between integers or pointers of any type.
        astringuReturn a Python string (or unicode string) from the 'cdata'.
        If 'cdata' is a pointer or array of characters or bytes, returns
        the null-terminated string.  The returned string extends until
        the first null character, or at most 'maxlen' characters.  If
        'cdata' is an array then 'maxlen' defaults to its length.

        If 'cdata' is a pointer or array of wchar_t, returns a unicode
        string following the same rules.

        If 'cdata' is a single character or byte or a wchar_t, returns
        it as a string or unicode string.

        If 'cdata' is an enum, returns the value of the enumerator as a
        string, or 'NUMBER' if the value is out of range.
        aunpackuUnpack an array of C data of the given length,
        returning a Python string/unicode/list.

        If 'cdata' is a pointer to 'char', returns a byte string.
        It does not stop at the first null.  This is equivalent to:
        ffi.buffer(cdata, length)[:]

        If 'cdata' is a pointer to 'wchar_t', returns a unicode string.
        'length' is measured in wchar_t's; it is not the size in bytes.

        If 'cdata' is a pointer to anything else, returns a list of
        'length' items.  This is a faster equivalent to:
        [cdata[i] for i in range(length)]
        a_unspecifiedafrom_bufferuReturn a cdata of the given type pointing to the data of the
        given Python object, which must support the buffer interface.
        Note that this is not meant to be used on the built-in types
        str or unicode (you can build 'char[]' arrays explicitly)
        but only on objects containing large quantities of raw data
        in some other format, like 'array.array' or numpy arrays.

        The first argument is optional and default to 'char[]'.
        amemmoveuffi.memmove(dest, src, n) copies n bytes of memory from src to dest.

        Like the C function memmove(), the memory areas may overlap;
        apart from that it behaves like the C function memcpy().

        'src' can be any cdata ptr or array, or any Python buffer object.
        'dest' can be any cdata ptr or array, or a writable Python buffer
        object.  The size to copy, 'n', is always measured in bytes.

        Unlike other methods, this one supports all Python buffer including
        byte strings and bytearrays---but it still does not support
        non-contiguous buffers.
        acallback_decorator_wrapuFFI.callback.<locals>.callback_decorator_wrapDaconsider_function_as_funcptrtuReturn a callback object or a decorator making such a
        callback object.  'cdecl' must name a C function pointer type.
        The callback invokes the specified 'python_callable' (which may
        be provided either directly or via a decorator).  Important: the
        callback object must be manually kept alive for as long as the
        callback may be invoked from the C level.
        acallableuthe 'python_callable' argument is not callableacallbackaerroraonerrorastripTw*u&[agetcnamew&u(%s)u[(w areplace_withuReturn a string giving the C type 'cdecl', which may be itself
        a string or a <ctype> object.  If 'replace_with' is given, it gives
        extra text to append (or insert for more complicated C types), like
        a variable name, or '*' to get actually the C type 'pointer-to-cdecl'.
        agcpuReturn a new cdata object that points to the same
        data.  Later, when this new cdata object is garbage-collected,
        'destructor(old_cdata_object)' will be called.

        The optional 'size' gives an estimate of the size, used to
        trigger the garbage collection more eagerly.  So far only used
        on PyPy.  It tells the GC that the returned object keeps alive
        roughly 'size' bytes of external memory.
        aacquireTFaget_cached_btypeaverifierTaVerifiera_caller_dir_pycacheaVerifiera_caller_dir_pycachea_apply_windows_unicodeaload_libraryuVerify that the current ffi signatures compile on this
        machine, and return a dynamic library object.  The dynamic
        library can be used to call functions and access global
        variables declared in this 'ffi'.  The library is compiled
        by the C compiler: it gives you C-level API compatibility
        (including calling macros).  This is unlike 'ffi.dlopen()',
        which requires binary compatibility in the signatures.
        aget_errnoaset_errnoagetwinerrorapointer_cachea__addressof__akindapointeruaddressof(pointer)a_pointer_toactypearawaddressofuReturn the address of a <cdata 'struct-or-union'>.
        If 'fields_or_indexes' are given, returns the address of that
        field or array item in the structure or array, recursively in
        case of nested structures.
        atypeoffsetofaoffsetuffi.include() expects an argument that is also of type cffi.FFI, not %ra__name__uself.include(self)aincludeTw[aextendTw]uIncludes the typedefs, structs, unions and enums defined
        in another FFI instance.  Usage is similar to a #include in C,
        where a part of the program might include types defined in
        another part for its own usage.  Note that the include()
        method has no effect on functions, constants and global
        variables, which must anyway be accessed directly from the
        lib object returned by the original FFI instance.
        anewp_handleafrom_handleareleaseuset_unicode() can only be called onceacdefTutypedef wchar_t TBYTE;typedef wchar_t TCHAR;typedef const wchar_t *LPCTSTR;typedef const wchar_t *PCTSTR;typedef wchar_t *LPTSTR;typedef wchar_t *PTSTR;typedef TBYTE *PTBYTE;typedef TCHAR *PTCHAR;Tutypedef char TBYTE;typedef char TCHAR;typedef const char *LPCTSTR;typedef const char *PCTSTR;typedef char *LPTSTR;typedef char *PTSTR;typedef TBYTE *PTBYTE;typedef TCHAR *PTCHAR;uWindows: if 'enabled_flag' is True, enable the UNICODE and
        _UNICODE defines in C, and declare the types like TCHAR and LPTCSTR
        to be (pointers to) wchar_t.  If 'enabled_flag' is False,
        declare these types to be (pointers to) plain 8-bit characters.
        This is mostly for backward compatibility; you usually want True.
        agetTadefine_macrosTTOlistOtupleu'define_macros' must be a list or tupleTaUNICODEw1Ta_UNICODEw1adefine_macrosaensureuFFI._apply_embedding_fix.<locals>.ensureupython%d%dagettotalrefcounta_dTll
aabiflagsalibrariesTaextra_link_argsu/MANIFESTakwdsasetdefaulta_assigned_sourceuset_source() cannot be called several times per ffi objectu'module_name' must be a stringw\w/u'module_name' must not contain '/': use a dotted name to make a 'package.module' locationTapkgconfigapkgconfiguthe pkgconfig_libs argument must be a list of package namesaflags_from_pkgconfigamerge_flagsaset_sourceuMust not call cffi.api.distutils_extensionuMust not call cffi.api.emit_c_codeuMust not call cffi.api.emit_python_codeuMust not call cffi.api.compileuembedding_init_code() can only be called onceareamatchu\s*\naendapysourceasplitlinesu\s*agrouparstripalineaprefix:nqnw
acffi_initaexecuffi.def_extern() is only available on API-mode FFI objectsa_declarationsTutypedef atypedefs:lnnTustruct astructs:lnnTuunion aunions:lnnasortuReturns the user type names known to this FFI instance.
        This returns a tuple containing three lists of names:
        (typedef_names, names_of_structs, names_of_unions)
        wcw.uctypes.utilautilafind_libraryudlopen(None) cannot work on Windows for Python 3 (see http://bugs.python.org/issue23606)uctypes.util.find_library() did not manage to locate a library called %ru%s.  Additionally, %sa_load_backend_libaaccessor_functionu_make_ffi_library.<locals>.accessor_functionaaccessor_variableu_make_ffi_library.<locals>.accessor_variableaaddressof_varu_make_ffi_library.<locals>.addressof_varaaccessor_constantu_make_ffi_library.<locals>.accessor_constantaaccessor_int_constantu_make_ffi_library.<locals>.accessor_int_constantaupdate_accessorsu_make_ffi_library.<locals>.update_accessorsamake_accessoru_make_ffi_library.<locals>.make_accessorTOobjecta__prepare__aFFILibrarya__getitem__u%s.__prepare__() must return a mapping, not %su<metaclass>ucffi.apia__module__u_make_ffi_library.<locals>.FFILibrarya__qualname__a__getattr__u_make_ffi_library.<locals>.FFILibrary.__getattr__a__setattr__u_make_ffi_library.<locals>.FFILibrary.__setattr__a__dir__u_make_ffi_library.<locals>.FFILibrary.__dir__u_make_ffi_library.<locals>.FFILibrary.__addressof__u_make_ffi_library.<locals>.FFILibrary.__cffi_close__a__orig_bases__Tuutf-8uFFILibrary_%salibnameufunction affiabackendlibaload_functionalibraryuvariable aread_variableawrite_variableu<lambda>u_make_ffi_library.<locals>.accessor_variable.<locals>.<lambda>aBTypeanameaaddr_variablesaarrayunon-integer constant '%s' cannot be accessed from a dlopen() librarya_int_constantsaaccessors_versionaitemsaEnumTypeasplitTw lafunctionaaccessorsavariableaconstantaenumeratorsatpaaccessor_enumu_make_ffi_library.<locals>.update_accessors.<locals>.accessor_enumacheck_not_partialaenumvaluesapropertya__set__akeysucffi library has no function or global variable named '%s'aclose_libamodulesa_cffi_original_ffia_cffi_types_of_builtin_funcsTEKeyErrorEAttributeErrorETypeErrora__doc__a__spec__aoriginahas_locationa__cached__asysatypesalockTaallocate_lockTaCDefErrorTamodelacollectionsTaCallableu
    The main top-level class that you instantiate once, or once per module.

    Example usage:

        ffi = FFI()
        ffi.cdef("""
            int printf(const char *, ...);
        """)

        C = ffi.dlopen(None)   # standard library
        -or-
        C = ffi.verify()  # use a C compiler: verify the decl above is right

        C.printf("hello, %s!\n", ffi.new("char[]", "world"))
    a__init__uFFI.__init__TFpnuFFI.cdefTFnaembedding_apiuFFI.embedding_apiuFFI._cdefTladlopenuFFI.dlopenadlcloseuFFI.dlcloseuFFI._typeof_lockeduFFI._typeofuFFI.typeofuFFI.sizeofuFFI.alignofaoffsetofuFFI.offsetofanewuFFI.newTnntuFFI.new_allocatoruFFI.castTquFFI.stringuFFI.unpackuFFI.from_bufferuFFI.memmoveuFFI.callbackTuagetctypeuFFI.getctypeagcuFFI.gcuFFI._get_cached_btypeTunaverifyuFFI.verifya_get_errnouFFI._get_errnoa_set_errnouFFI._set_errnouthe value of 'errno' from/to the C callsaerrnouFFI.getwinerroruFFI._pointer_toaaddressofuFFI.addressofuFFI._typeoffsetofuFFI.includeanew_handleuFFI.new_handleuFFI.from_handleuFFI.releaseaset_unicodeuFFI.set_unicodeuFFI._apply_windows_unicodea_apply_embedding_fixuFFI._apply_embedding_fixTu.cuFFI.set_sourceaset_source_pkgconfiguFFI.set_source_pkgconfigTabuildtadistutils_extensionuFFI.distutils_extensionaemit_c_codeuFFI.emit_c_codeaemit_python_codeuFFI.emit_python_codeTw.lnnacompileuFFI.compileainit_onceuFFI.init_onceaembedding_init_codeuFFI.embedding_init_codeadef_externuFFI.def_externalist_typesuFFI.list_typesucffi\api.pyTwxTaselfaread_variableaBTypeanameTaBTypeanamearead_variableTaselfavalueawrite_variableaBTypeanameTaBTypeanameawrite_variableu<module cffi.api>Ta__class__TaselfanamealibraryaFFILibraryaaddressof_varamake_accessorTaFFILibraryaaddressof_varalibraryamake_accessorTaselfabackendlibTabackendlibTaselfaffiaupdate_accessorsaaccessorsTaaccessorsaffiaupdate_accessorsTaselfanameamake_accessorTamake_accessorTaselfabackenda__version__acparseranameTaselfanameavalueapropertyamake_accessorTaselfakwdsaensureaosapythonlibatemplateasysconfigTaselfakwdsadefmacrosTafuncasysamoduleaffiatypes_of_builtin_funcsatpTaselfacsourceaoverrideaoptionsacacheafinishlistatpTaselfatypeaBTypeafinishlistTaselfTabackendanameaflagsaosafirst_errorweactypesapathamsgTaffialibnameaflagsabackendabackendlibaaccessor_functionaaccessor_variableaaddressof_varaaccessor_constantaaccessor_int_constantaaccessorsaaccessors_versionaaddr_variablesaupdate_accessorsamake_accessoraFFILibraryalibraryTaselfactypeTaselfaerrnoTaselfacdeclaconsider_function_as_funcptraresultabtypeareally_a_function_typeTaselfacdeclakeyatypeareally_a_function_typeabtypearesultTaselfactypeafield_or_indexafields_or_indexesaoffsetafield1aoffset1TanameTanameatpwialibraryTalibraryTanameakeyatpw_aBTypeavalueaffiabackendlibalibraryTabackendlibaffialibraryTanameaffialibraryTaffialibraryT
anameakeyatpw_aBTypearead_variableawrite_variableaffiabackendlibaFFILibraryTaFFILibraryabackendlibaffiTaselfacdataafields_or_indexesactypeaoffsetactypeptrTanameakeyatpw_aBTypewpaaddr_variablesaffiabackendlibTaaddr_variablesabackendlibaffiTaselfacdeclTacdeclainitaselfaallocatorTaallocatoraselfTaselfacdeclapython_callableaerroraonerroracallback_decorator_wrapTapython_callableaselfacdeclaerroraonerrorTacdeclaerroraonerroraselfTaselfacdeclasourceTaselfacsourceaoverrideapackedapackTaselfatmpdiraverboseatargetadebugTaselfaargsakwdsTaselfatmpdiraverboseTaselfalibTaselfanameaflagsalibafunction_cacheTaselfacsourceapackedapackTaselfapysourceareamatchalinesaprefixwialineTaselfafilenameTakeyavaluealstakwdsTakwdsTaselfacdeclapython_bufferarequire_writableTaselfwxTaselfacdataadestructorasizeTaselfacdeclareplace_withTaselfacodeTaselfaffi_to_includeTaselfafuncatagwxaresultTaselfatypedefsastructsaunionsakeyTanameaffialibraryaFFILibraryaaccessorsaupdate_accessorsTaFFILibraryaaccessorsaffialibraryaupdate_accessorsTaselfadestasrcwnTaselfacdeclainitTaselfaallocafreeashould_clear_after_allocacompiled_ffiaallocatoraallocateTaselfacdeclafields_or_indexesTaselfamodule_nameasourceasource_extensionakwdsaosTaselfamodule_nameapkgconfig_libsasourceasource_extensionakwdsapkgconfigakwds2Taselfaenabled_flagTaselfacdeclaBTypeTaselfacdataamaxlenTaselfacdeclaresTaselfacdataalengthTakeyatpw_ataganamewiaenumnameaaccessor_enumaaccessors_versionaffiaaccessor_functionaaccessorsaaccessor_variableaaccessor_constantaaccessor_int_constantTaaccessor_constantaaccessor_functionaaccessor_int_constantaaccessor_variableaaccessorsaaccessors_versionaffialibraryTaselfasourceatmpdirakwargsaVerifiera_caller_dir_pycachealib.cffi.commontypes&Aa_CACHEaCOMMON_TYPESagetlutoo many values to unpack (expected 2)amodelaPrimitiveTypeaALL_PRIMITIVE_TYPESuset-unicode-neededaFFIErroruThe Windows type %r is only available after you call ffi.set_unicode()uUnsupported type: %r.  Please look at http://cffi.readthedocs.io/en/latest/cdef.html#ffi-cdef-limitations and file an issue if you think this type should really be supported.aparse_type_and_qualsaBaseTypeByIdentityaUNICODE_STRINGaStructTypea_UNICODE_STRINGaLengthaMaximumLengthaBufferTuunsigned shortaPointerTypeTawchar_tqaPUNICODE_STRINGuUNICODE_STRING *aPCUNICODE_STRINGuconst UNICODE_STRING *aTBYTEaTCHARaLPCTSTRaPCTSTRaLPTSTRaPTSTRaPTBYTEaPTCHARa__doc__a__file__a__spec__aoriginahas_locationa__cached__asysuTamodellaerrorTaFFIErrora_cffi_backendTa_get_common_typesa_get_common_typesaunknown_typeTaFILEa_IO_FILEaFILEa_Boolaboola_typeaendswithTa_taresolve_common_typeawin_common_typesaupdateucffi\commontypes.pyu<module cffi.commontypes>Taparseracommontypeacdeclaresultaquals.cffi)%a__doc__a__file__apathadirnameaenvironagetTaNUITKA_PACKAGE_cffiu\not_existinga__path__a__spec__aoriginahas_locationasubmodule_search_locationsa__cached__LaFFIaVerificationErroraVerificationMissingaCDefErroraFFIErrora__all__aapiTaFFIlaFFIlaerrorTaCDefErroraFFIErroraVerificationErroraVerificationMissingaCDefErroraFFIErroraVerificationErroraVerificationMissingTaPkgConfigErroraPkgConfigErroru1.15.1a__version__Tllla__version_info__u0.8.6a__version_verifier_modules__ucffi\__init__.pyu<module cffi>u.cffi.cparserP&upycparser.yacctablupycparser.lextaba_parser_cacheapycparseraCParsera_r_star_const_spaceasearchacsourceapartsastartaappendTw(w)agroupaendastartswithw*wiw(alevellu,;=ua_r_extern_pythonwCTlTuvoid __cffi_extern_python_plus_c_start; Tuvoid __cffi_extern_python_start; w{afindw}aCDefErrorTu'extern "Python" {': no '}' founducannot use { } inside a block 'extern "Python" { ... }'w;Tu'extern "Python": no ';' foundTu void __cffi_extern_python_stop;w"asplitlinesalstripTw#awarningsawarnTuString literal found in cdef() or type source. String literals are ignored here, but you should remove them anyway because some character sequences confuse pre-parsing.astorageuGlobal variable '%s' in cdef(): for consistency with C it should have a storage class specifier (usually 'extern')anameareplaceu_remove_line_directives.<locals>.replacea_r_line_directiveasubaline_directivesu#line@%du_put_back_line_directives.<locals>.replaceTu#line@uunexpected #line directive (should have been processed and removed:lnna_remove_line_directivesutoo many values to unpack (expected 2)areplace_keeping_newlinesu_preprocess.<locals>.replace_keeping_newlinesa_r_commenta_r_defineafinditeragroupsTu\
uastripamacrosa__version__u2.14a_workaround_for_old_pycparsera_r_stdcall2u volatile volatile const(a_r_stdcall1u volatile volatile const a_r_cdeclw a_preprocess_extern_pythona_warn_for_string_literala_r_partial_arrayu[__dotdotdotarray__]a_r_partial_enumw=u...u%s,__dotdotdot%d__ %slu%s __dotdotdot%d__ %sa_r_int_dotdotdotu __dotdotdotint__ a_r_float_dotdotdotu __dotdotdotfloat__ Tu...u __dotdotdot__ a_put_back_line_directivesacountTw
w
aCOMMON_TYPESaaddTw;Tw,Tw)Tatypedefa_r_wordsafindallalook_for_wordsais_typedefawords_usedadiscardaprevious_wordatypedefaparenw,a_declarationsa_included_declarationsa_anonymous_counteraweakrefaWeakKeyDictionarya_structnode2typea_optionsa_int_constantsa_recompletea_uses_new_featurea_preprocessa_common_type_namesasortedTutypedef :lnnatypenamesactnu# 1 "<cdef automatic initialization code>"acsourcelinesutypedef int %s;utypedef int __dotdotdotint__, __dotdotdotfloat__, __dotdotdot__;u# 1 "%s"aCDEF_SOURCE_STRINGalockaacquirea_get_parseraparseac_parseraParseErroraconvert_pycparser_errorareleaseaastareamatchu%s:(\d+):l
a_convert_pycparser_errorucannot parse "%s"
%suparse error
%su'packed' should be False or True; use 'pack' to give another valueucannot give both 'pack' and 'packed'u'pack' must be a power of two, not %raoverrideapackedapackadllexporta_internal_parsea_parseutoo many values to unpack (expected 3)a_process_macrosaexta__dotdotdot__a__cffi_extern_python_stopa_inside_extern_pythonac_astaDeclaselfa_parse_declaTypedefutypedef does not declare any nameatypeaIdentifierTypeanamesqTa__dotdotdota_get_unknown_typeaPtrDeclaTypeDecla_get_unknown_ptr_typea_get_type_and_qualsu*(%s *)0Tanameapartial_length_okatypedef_examplea_declareutypedef Taqualsa__name__aPragmauunexpected <%s>: this construct is valid C but not valid in cdef()aargsacurrent_declaFFIErroru
    *** Err: %sumultiple declarations of constant: %salowerarstripTaulTw-:lnnaint_strTw0w0Tu0xu0oa_add_constantsumacro aitemsa_r_int_literala_add_integer_constantuonly supports one of the following syntax:
  #define %s ...     (literally dot-dot-dot)
  #define %s NUMBER  (with NUMBER an integer constant, decimal/hex/octal)
got:
  #define %s %sa_get_type_pointeragetTadllexportudllexport_python a__cffi_extern_python_startuextern_python a__cffi_extern_python_plus_c_startuextern_python_plus_c ufunction aFuncDeclTanameamodelaRawFunctionTypea_declare_functionaStructa_get_struct_union_enum_typeastructaUnionaunionaEnumaenumuconstruct does not declare any variableanodeDapartial_length_oktais_raw_functionais_integer_typeainitavalueaUnaryOpaopw-aexpravoid_typeTa__cffi_extern_python_Tucannot declare constants or variables with 'extern "Python"'aQ_CONSTais_array_typeuconstant a_warn_for_non_extern_non_static_global_variableuvariable aparse_type_and_qualsuvoid __dummy(
%s
);:nlnaparamsaIDuunknown identifier '%s'Taoverrideumultiple declarations of %s (for interactive usage, try cdef(xx, override=True))asplitaconstaqualsavolatileaQ_VOLATILEarestrictaQ_RESTRICTaas_function_pointeraStructOrUnionOrEnumTw$aisdigitaforcenameaNamedPointerTypeaPointerTypea_extract_qualsaArrayDecladima_parse_constantTapartial_length_oku_cffi_array_len(%s)Tapartial_length_okatypedef_exampleaArrayTypeTadeclnameasignedacharTashortalongasignedaunsignedaprefixesTaunsignedashortalonganewnamesaprefixaintashortalongavoidu:%d: bad usage of "..."acoordalinearesolve_common_typea_parse_function_typeDanestedtu:%d: bad or unsupported type declarationu%s arg %d: unknown type '%s' (if you meant to use the old C syntax of giving untyped arguments, it is not supported)uin expressionw?u%s: a function with only '(...)' as argument is not correct Ca_as_func_arg:qnna__stdcallaitemu$%su$%du%s %sTnnaStructTypeaUnionTypeTuEnums cannot be declared with ...a_build_enum_typeavaluesukind = %rakeyuenum %s: the '{}' declaration should appear on the first time the enum is mentioned, not lateratpaforce_the_namew$uanonymous %sadeclsafldnamesuduplicate declaration of struct %sa_make_partialanestedabitsizea_partial_lengthapartialafldtypesafldbitsizeafldqualsu%s: using both bitfields and '...;'TapackedacompletedaStructOrUnionu%s cannot be partialahas_c_nameu%s is partial but has no C nameaConstantw9TauUlLl:llnu0xlu0bluinvalid constant %rw'w\qw+a__dotdotdotarray__u:%d: unsupported '[...]' here, cannot derive the actual array length in this contextaBinaryOpaleftarightw/a_c_divw%u<<u>>w&w|w^u:%d: unsupported expression: expected a simple numeric constantaenumeratorsa_r_enum_dotdotdotaenumvaluesanextenumvalueaEnumTypeTuanonymous $enum_$Tw lTastructaunionaenumaanonymousatypedefTaincludedaqualsaunknown_typea__dotdotdotint__u'typedef int... %s'aUnknownIntegerTypea__dotdotdotfloat__u'typedef float... %s'aUnknownFloatTypeu:%d: unsupported usage of "..." in typedefaunknown_ptr_typea__doc__a__file__a__spec__aoriginahas_locationa__cached__TamodelacommontypesTaCOMMON_TYPESaresolve_common_typeaerrorTaFFIErroraCDefErrorTa_pycparsera_pycparserasysa_threadaallocate_locka_workaround_for_static_import_findersu<cdef source string>acompileu/\*.*?\*/|//([^\n\\]|\\.)*?$aDOTALLaMULTILINEu^\s*#\s*define\s+([A-Za-z_][A-Za-z_0-9]*)\b((?:[^\n\\]|\\.)*?)$u^[ \t]*#[ \t]*(?:line|\d+)\b.*$Tu=\s*\.\.\.\s*[,}]|\.\.\.\s*\}Tu__dotdotdot\d+__$Tu\[\s*\.\.\.\s*\]Tu\w+|\Su-?0?x?[0-9a-f]+[lu]*$aIGNORECASETu\b(__stdcall|WINAPI)\bTu[(]\s*(__stdcall|WINAPI)\bTu\b__cdecl\bTu\bextern\s*"(Python|Python\s*\+\s*C|C\s*\+\s*Python)"\s*.Tu[*]\s*((const|volatile|restrict)\b\s*)+Tu(\b(int|long|short|signed|unsigned|char)\s*)+\.\.\.Tu\b(double|float)\s*\.\.\.TOobjecta__prepare__aParsera__getitem__u%s.__prepare__() must return a mapping, not %su<metaclass>ucffi.cparsera__module__a__qualname__a__init__uParser.__init__uParser._parseuParser._convert_pycparser_erroruParser.convert_pycparser_errorTFpnFuParser.parseuParser._internal_parseuParser._add_constantsuParser._add_integer_constantuParser._process_macrosuParser._declare_functionuParser._parse_declaparse_typeuParser.parse_typeuParser.parse_type_and_qualsTFluParser._declareuParser._extract_qualsTnuParser._get_type_pointerTnFnuParser._get_type_and_qualsuParser._parse_function_typeuParser._as_func_argTnFuParser._get_struct_union_enum_typeuParser._make_partialTFuParser._parse_constantuParser._c_divuParser._build_enum_typeaincludeuParser.includeuParser._get_unknown_typeuParser._get_unknown_ptr_typea__orig_bases__ucffi\cparser.pyu<module cffi.cparser>Ta__class__TaselfTaselfakeyavalTaselfanameaint_stranegapyvalueTaselfatypeaqualsTaselfaexplicit_nameadeclsapartialaenumeratorsaenumvaluesanextenumvalueaenumatpTaselfwawbaresultTacsourcealook_for_wordsawords_usedais_typedefaparenaprevious_wordawordTaselfweacsourcealineamsgamatchalinenumacsourcelinesTaselfanameaobjaincludedaqualsaprevobjaprevqualsTaselfatpaqualsadeclatagTaselfakindatypeanameanestedaforce_nameaexplicit_nameatpakeyw_afldnamesafldtypesafldbitsizeafldqualsadeclabitsizeafqualTaselfatypenodeanameapartial_length_okatypedef_exampleatpaqualsalengthaitemtypeaitemqualsatypeanamesaprefixesanewnamesaprefixwiaidentatp0aquals0TaselfatypeaqualsadeclnameTaselfadeclTaselfadeclatypenamesTaselfacsourceaastamacrosaiteratoradeclacurrent_declaqualsarealtypeweamsgTaselfatpanestedTaselfacsourceamacrosactnatypenamesanameacsourcelinesatypenameafullcsourceaastweTaselfaexprnodeapartial_length_okwsaleftarightTaselfadeclanodeatpaqualsTaselfatypenodeafuncnameaparamswiaargaellipsisaargsaresultaqualsaabiTacsourcealine_directivesareplace_keeping_newlinesamacrosamatchamacronameamacrovalueamatchesanumberwpap2TacsourceapartsamatchaendposaclosingasemicolonTaselfamacrosakeyavalueTacsourcealine_directivesareplaceTadeclawarningsTacsourcealineawarningsTacsourceapartsamatchaclosingaendposalevelwiwcTapycparserTaselfweacsourcealineamsgTaselfaotheranameatpaqualsakindwkwvTaselfacsourceaoverrideapackedapackadllexportaprev_optionsTaselfacdeclTaselfacdeclaastamacrosaexprnodeTwmwsaline_directivesTaline_directivesTwmwialine_directivesTwm.cffi.error)aargslacoordafilealineu%s:%d: TEAttributeErrorETypeErrorEIndexErroruu%s%sla__doc__a__file__a__spec__aoriginahas_locationa__cached__TEExceptiona__prepare__aFFIErrora__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>ucffi.errora__module__a__qualname__acffia__orig_bases__aCDefErrora__str__uCDefError.__str__aVerificationErroru An error raised when verification fails
    aVerificationMissingu An error raised when incomplete structures are passed into
    cdef, but no verification has been done
    aPkgConfigErroru An error raised for missing modules in pkg-config
    ucffi\error.pyu<module cffi.error>Ta__class__Taselfacurrent_declafilenamealinenumaprefix.cffi.ffiplatform
CuMust not call cffi.ffiplatform.get_extensiona_hack_at_distutilsaenvironacopya_buildaitemsutoo many values to unpack (expected 2)agetuCompile a C extension module using distutils.uMust not call cffi.ffiplatform._buildaisabsadirasplitanamesasamefilew.areverseajoinawriteu%ds%sasortedakeysu%dda_flattenwfTOlistOtupleu%dlaint_or_longu%diuthe keywords to verify() contains unsupported object %racStringIOaStringIOagetvaluea__doc__a__file__a__spec__aoriginahas_locationa__cached__asysaosaerrorTaVerificationErrorlaVerificationErrorlLasourcesainclude_dirsalibrary_dirsaextra_objectsadependsaLIST_OF_FILE_NAMESTTaget_extensionTlnacompileuos.pathTasamefileamaybe_relative_pathalongaflattenucffi\ffiplatform.pyu<module cffi.ffiplatform>Tatmpdiraextacompiler_verboseadebugTwxwfakeysakeyavalueTatmpdiraextacompiler_verboseadebugasaved_environaoutputfilenameakeyavalueTwxwfTasrcfilenameamodnameasourcesakwdsTapathadiranamesaprevdiranameTaf1af2u.cffi.locka__doc__a__file__a__spec__aoriginahas_locationa__cached__asysa_threadTaallocate_locklaallocate_locka_dummy_threaducffi\lock.pyu<module cffi.lock>u.cffi.model1MaQ_CONSTu const alstripaQ_VOLATILEu volatile aQ_RESTRICTu __restrict ac_name_with_markeracountTw&lastripastartswithTw*u&[u(%s)lu[(w aqualifyareplace_withareplacew&w$aVerificationErrorucannot generate '%s' in %s: unknown type namea_get_c_nameTw&ua_cached_btypesabuild_backend_typeasetdefaultaBTypeu<%s>a_attrs_a_get_itemsuvoid&aglobal_cacheanew_void_typeaALL_PRIMITIVE_TYPESanamewcwiwfwjanew_primitive_typeuinteger type '%s' can only be used after compilationufloat type '%s' can only be used after compilationaargsaresultaellipsisaabiaappendTu...avoida_base_patternu, :nln:lnnaCDefErrorucannot render the type %r: it is a function type, not a pointer-to-function typeaFunctionPtrTypeaget_cached_btypeaffiafinishlista__stdcalla_backendaFFI_STDCALLanew_function_typeaRawFunctionTypeatotypeaqualsu *&ais_array_typeDacan_delaytanew_pointer_typeaPointerTypea__init__aitemalengthu&[]u...u&[/*...*/]u&[%s]aArrayTypealength_is_unknownucannot render the type %r: unknown lengthanew_array_typeaforcenameu%s %sakindabuild_c_name_with_markeraendswith:nqnafldnamesafldtypesafldbitsizeafldqualsaselfutoo many values to unpack (expected 2)uaStructOrUnionaanonymous_struct_fieldsuStructOrUnion.anonymous_struct_fieldsTlutoo many values to unpack (expected 4)aexpand_anonymous_struct_unionaenumfieldsuStructOrUnion.enumfieldsanamesatypesabitsizesaStructOrUnionOrEnumafinish_backend_typeacompletedlurecursive structure declaration for '%s'afixedlayoutapackedTlacomplete_struct_or_unionqasizeofa_verification_errorufield '%s.%s' has a bogus size?u{}aresolve_lengthaftypeufield '%s.%s' is declared as %d bytes, but is really %d bytesapartialaVerificationMissingacheck_not_partialunew_%s_typeaget_official_nameTakeyaenumeratorsaenumvaluesabaseinttypeaforce_the_nameTw w_apartial_resolvedabuild_baseinttypeanew_enum_typeaminamaxawarningsa__warningregistry__aclearawarnu%r has no values explicitly defined; guessing that it is equivalent to 'unsigned int'aPrimitiveTypeTaintTalongTuunsigned intTuunsigned longlu%s values don't all fit into either 'long' or 'unsigned long'u$%saStructTypeaunknown_typeaoriginu$$%saNamedPointerTypeaModuleTypea_typecache_cffi_backendaglobal_locka__enter__a__exit__a__typecacheaweakrefaWeakValueDictionaryTnnnakeya_typecacheu%s: %r: %sagetw?u%s: %sa__doc__a__file__a__spec__ahas_locationa__cached__alockTaallocate_lockaallocate_lockaerrorTaCDefErroraVerificationErroraVerificationMissinglTOobjecta__prepare__aBaseTypeByIdentitya__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>ucffi.modela__module__a__qualname__ais_raw_functionTuua C filelaget_c_nameuBaseTypeByIdentity.get_c_nameuBaseTypeByIdentity._get_c_nameahas_c_nameuBaseTypeByIdentity.has_c_nameais_integer_typeuBaseTypeByIdentity.is_integer_typeTFuBaseTypeByIdentity.get_cached_btypea__repr__uBaseTypeByIdentity.__repr__uBaseTypeByIdentity._get_itemsa__orig_bases__aBaseTypea__eq__uBaseType.__eq__a__ne__uBaseType.__ne__a__hash__uBaseType.__hash__aVoidTypeuVoidType.__init__uVoidType.build_backend_typeavoid_typeaBasePrimitiveTypeais_complex_typeuBasePrimitiveType.is_complex_typeTanameD3acharashortaintalongulong longusigned charuunsigned charuunsigned shortuunsigned intuunsigned longuunsigned long longafloatadoubleulong doubleufloat _Complexudouble _Complexa_Boolawchar_tachar16_tachar32_taint8_tauint8_taint16_tauint16_taint32_tauint32_taint64_tauint64_taint_least8_tauint_least8_taint_least16_tauint_least16_taint_least32_tauint_least32_taint_least64_tauint_least64_taint_fast8_tauint_fast8_taint_fast16_tauint_fast16_taint_fast32_tauint_fast32_taint_fast64_tauint_fast64_taintptr_tauintptr_taintmax_tauintmax_taptrdiff_tasize_tassize_twcwipppppppppwfppwjpwiwcppwippppppppppppppppppppppppppppppuPrimitiveType.__init__ais_char_typeuPrimitiveType.is_char_typeuPrimitiveType.is_integer_typeais_float_typeuPrimitiveType.is_float_typeuPrimitiveType.is_complex_typeuPrimitiveType.build_backend_typeaUnknownIntegerTypeuUnknownIntegerType.__init__uUnknownIntegerType.is_integer_typeuUnknownIntegerType.build_backend_typeaUnknownFloatTypeuUnknownFloatType.__init__uUnknownFloatType.build_backend_typeaBaseFunctionTypeTaargsaresultaellipsisaabiTnuBaseFunctionType.__init__u(&)(%s)uRawFunctionType.build_backend_typeaas_function_pointeruRawFunctionType.as_function_pointeru(*&)(%s)uFunctionPtrType.build_backend_typeaas_raw_functionuFunctionPtrType.as_raw_functionTatotypeaqualsuPointerType.__init__uPointerType.build_backend_typeavoidp_typeaConstPointerTypeaconst_voidp_typeTatotypeanameuNamedPointerType.__init__TaitemalengthuArrayType.__init__uArrayType.length_is_unknownuArrayType.resolve_lengthuArrayType.build_backend_typeTacharachar_array_typeuStructOrUnionOrEnum.build_c_name_with_markeruStructOrUnionOrEnum.force_the_nameuStructOrUnionOrEnum.get_official_nameuStructOrUnion.__init__Ttaforce_flattenuStructOrUnion.force_flattenuStructOrUnion.get_cached_btypeuStructOrUnion.finish_backend_typeuStructOrUnion._verification_erroruStructOrUnion.check_not_partialuStructOrUnion.build_backend_typeastructaUnionTypeaunionaEnumTypeaenumuEnumType.__init__uEnumType.force_the_nameuEnumType.check_not_partialuEnumType.build_backend_typeuEnumType.build_baseinttypeaunknown_ptr_typeaget_typecacheapointer_cacheaattach_exception_infoucffi\model.pyu<module cffi.model>Ta__class__TatotypeTaselfaotherTaselfTaselfaitemalengthabracketsTaselfaargsaresultaellipsisaabiareprargsareplace_withTaselfanameaenumeratorsaenumvaluesabaseinttypeTaselfatotypeanameaqualsTaselfatotypeaqualsaextraTaselfanameTaselfanameafldnamesafldtypesafldbitsizeafldqualsTaselfamsgTaselfanameatypeTweanameTaselfaffiafinishlistaBPtrItemTaselfaffiafinishlistabase_btypeTaselfaffiafinishlistaresultaargsatpaabi_argsTaselfaffiafinishlistaBItemTaselfaffiafinishlistT
aselfaffiafinishlistasmallest_valuealargest_valueawarningsasignacandidate1acandidate2abtype1abtype2asize1asize2Taselfaexpand_anonymous_struct_unionafldqualsanameatypeabitsizeaqualsaresultTaselfaffiafinishlistaBTypeafldtypesalstaextra_flagsafieldofsafieldsizeatotalsizeatotalalignmentwiafsizeaftypeaBItemTypeanlenanrestaBFieldTypeabitemsizeTaselfanamesatypesabitsizesafldqualsanameatypeabitsizeaqualsTaselfaforcenameanameTaselfaforcenameTaselfareplace_withacontextaqualsaresultTaselfaffiafinishlistacan_delayaBTypeaBType2Taselfaffiafinishlistacan_delayaBTypeTabackendT
asrctypeaffiafuncnameaargsakwdsakeyaresweacacheares1TaffiaBTypeTaqualsareplace_withTaselfanewlengthTanameastructnameatp.cffi.pkgconfigVaitemsutoo many values to unpack (expected 2)acfg1ucfg1[%r] should be a list of stringsucfg2[%r] should be a list of stringsaextenduMerge values from cffi config flags cfg2 to cf1

    Example:
        merge_flags({"libraries": ["one"]}, {"libraries": ["two"]})
        {"libraries": ["one", "two"]}
    upkg-configu--print-errorsasubprocessaPopenaPIPETastdoutastderraPkgConfigErrorucannot run pkg-config: %sastripacommunicateareturncodeladecodeaberrupkg-config %s %s returned bytes that cannot be decoded with encoding %r:
%rw\upkg-config %s %s returned an unsupported backslash-escaped output:
%ruCalls pkg-config and returns the output if found
    aget_include_dirsuflags_from_pkgconfig.<locals>.get_include_dirsaget_library_dirsuflags_from_pkgconfig.<locals>.get_library_dirsaget_librariesuflags_from_pkgconfig.<locals>.get_librariesaget_macrosuflags_from_pkgconfig.<locals>.get_macrosaget_other_cflagsuflags_from_pkgconfig.<locals>.get_other_cflagsaget_other_libsuflags_from_pkgconfig.<locals>.get_other_libsakwargsuflags_from_pkgconfig.<locals>.kwargsamerge_flagsaretuReturn compiler line flags for FFI.set_source based on pkg-config output

    Usage
        ...
        ffibuilder.set_source("_foo", pkgconfig = ["libfoo", "libbar >= 1.8.3"])

    If pkg-config is installed on build machine, then arguments include_dirs,
    library_dirs, libraries, define_macros, extra_compile_args and
    extra_link_args are extended with an output of pkg-config for libfoo and
    libbar.

    Raises PkgConfigError in case the pkg-config call fails.
    asplitastartswithTu-I:lnnTu-LTu-la_macrouflags_from_pkgconfig.<locals>.get_macros.<locals>._macroTu-Dw=Tw=lagetfilesystemencodingacallu--cflagsu--libsainclude_dirsalibrary_dirsalibrariesadefine_macrosaextra_compile_argsaextra_link_argsa__doc__a__file__a__spec__aoriginahas_locationa__cached__asysaosaerrorTaPkgConfigErrorlaflags_from_pkgconfigucffi\pkgconfig.pyu<module cffi.pkgconfig>TwxTalibnameaflagaencodingwaapcweaboutaberrTalibsaget_include_dirsaget_library_dirsaget_librariesaget_macrosaget_other_cflagsaget_other_libsakwargsaretalibnamealib_flagsTastringTastringa_macroT
alibnameafseaall_cflagsaall_libsaget_include_dirsaget_library_dirsaget_librariesaget_macrosaget_other_cflagsaget_other_libsTaget_include_dirsaget_librariesaget_library_dirsaget_macrosaget_other_cflagsaget_other_libsTacfg1acfg2akeyavalueu.cffi.vengine_cpyVaverifieraffia_struct_pending_verificationa_types_of_builtin_functionsaimpafind_moduleutoo many values to unpack (expected 3)aclosela_typesdicta_generateTacollecttypea_fawritew
amodelaPrimitiveTypeanameulong doubleacollect_typesu((void)lib,0)a_chained_list_constantsa_prntacffimod_headerapreambleTadecla_generate_setup_customTustatic PyMethodDef _cffi_methods[] = {TamethodTu  {"_cffi_setup", _cffi_setup, METH_VARARGS, NULL},Tu  {NULL, NULL, 0, NULL}    /* Sentinel */Tu};aget_module_nameTu#if PY_MAJOR_VERSION >= 3Tustatic struct PyModuleDef _cffi_module_def = {Tu  PyModuleDef_HEAD_INIT,u  "%s",Tu  NULL,Tu  -1,Tu  _cffi_methods,Tu  NULL, NULL, NULL, NULLTaPyMODINIT_FUNCuPyInit_%s(void)Tw{Tu  PyObject *lib;Tu  lib = PyModule_Create(&_cffi_module_def);Tu  if (lib == NULL)Tu    return NULL;u  if (%s < 0 || _cffi_init() < 0) {Tu    Py_DECREF(lib);Tu  }Tu  return lib;Tw}Tu#elseuinit%s(void)u  lib = Py_InitModule("%s", _cffi_methods);Tu    return;u  if (%s < 0 || _cffi_init() < 0)Tu  return;Tu#endifaacquire_lockagetdlopenflagsasetdlopenflagsaload_dynamicamodulefilenameuimporting %r: %saVerificationErroraprevious_flagsarelease_locka_loadaloadingaitemsutoo many values to unpack (expected 2)a_get_cached_btypeTOobjecta__prepare__aFFILibrarya__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>ucffi.vengine_cpya__module__uVCPythonEngine.load_library.<locals>.FFILibrarya__qualname__amodulea_cffi_python_moduleaselfa_cffi_ffia_cffi_dira__dir__uVCPythonEngine.load_library.<locals>.FFILibrary.__dir__a__orig_bases__a_cffi_setupawarningsawarnureimporting %r might overwrite older definitionsaloadedTalibrarya_cffi_original_ffia_cffi_types_of_builtin_funcsa_parsera_declarationsasorta_get_declarationsasplitTw lu_generate_cpy_%s_%sunot implemented in verify(): %raattach_exception_infou_%s_cpy_%suais_integer_typea_Boola_cffi_to_c_intu, %su(%s)_cffi_to_c_%saget_c_nameTuareplaceTw w_u-1aPointerTypea_convert_funcarg_to_c_ptr_or_arrayaStructOrUnionaEnumTypeu  if (_cffi_to_c((char *)&%s, _cffi_type(%d), %s) < 0)a_gettypenumu    %s;aFunctionPtrTypeu(%s)_cffi_to_c_pointeru, _cffi_type(%d)aNULLu  %s = %s(%s%s);u  if (%s == (%s)%s && PyErr_Occurred())atpaaddTuPy_ssize_t datasizeTustruct _cffi_freeme_s *large_args_free = NULLTuif (large_args_free != NULL) _cffi_free_array_arguments(large_args_free);Tu  datasize = _cffi_prepare_pointer_call_argument(u      _cffi_type(%d), %s, (char **)&%s);Tu  if (datasize != 0) {u    %s = ((size_t)datasize) <= 640 ? alloca((size_t)datasize) : NULL;u    if (_cffi_convert_array_argument(_cffi_type(%d), %s, (char **)&%s,Tu            datasize, &large_args_free) < 0)u      %s;u_cffi_from_c_int(%s, %s)u_cffi_from_c_%s(%s)u_cffi_from_c_deref((char *)&%s, _cffi_type(%d))u_cffi_from_c_pointer((char *)%s, _cffi_type(%d))aArrayTypeaitemafldnamesu'%s' is used as %s, but is opaquea_get_c_nameu_cffi_from_c_struct((char *)&%s, _cffi_type(%d))aellipsisa_do_collect_typeaargsaresulta_generate_cpy_constanoargaarg0Tustatic PyObject *u_cffi_f_%s(PyObject *self, PyObject *%s)uargument of %saprntu  %s;u x%dacontexta_extra_local_variablesalocalvarsafreelinesasortedaVoidTypeuresult = uresult of %su resultTu  PyObject *pyresult;u  PyObject *arg%d;u  if (!PyArg_ParseTuple(args, "%s:%s", %s))wOu, u&arg%da_convert_funcarg_to_cuarg%dux%dureturn NULLTu  Py_BEGIN_ALLOW_THREADSTu  _cffi_restore_errno();u  { %s%s(%s); }Tu  _cffi_save_errno();Tu  Py_END_ALLOW_THREADSTu  (void)self; /* unused */Tu  (void)noarg; /* unused */u  pyresult = %s;a_convert_expr_from_curesult typeu  Tu  return pyresult;Tu  Py_INCREF(Py_None);Tu  return Py_None;aMETH_NOARGSaMETH_OaMETH_VARARGSu  {"%s", _cffi_f_%s, %s, NULL},a_generate_struct_or_union_declastructa_generate_struct_or_union_methoda_loading_struct_or_uniona_loaded_struct_or_unionaunionu_cffi_check_%s_%su_cffi_layout_%s_%su%s %sustatic void %s(%s *p)Tu  /* only to generate compile-time warnings or errors */Tu  (void)p;aenumfieldsutoo many values to unpack (expected 4)u  (void)((p->%s) << 1);u  { %s = &p->%s; (void)tmp; }u*tmpufield %rTaqualsu  /* %s */u%s(PyObject *self, PyObject *noarg)u  struct _cffi_aligncheck { char x; %s y; };Tu  static Py_ssize_t nums[] = {u    sizeof(%s),Tu    offsetof(struct _cffi_aligncheck, y),u    offsetof(%s, %s),alengthu    0,  /* %s */u    sizeof(((%s *)0)->%s),Tu    -1Tu  };Tu  return _cffi_get_struct_layout(nums);Tu  /* the next line is not executed, but compiled */u  %s(0);u  {"%s", %s, METH_NOARGS, NULL},apartiall:lnl:lnlaforce_flattenafixedlayoutacheckuVCPythonEngine._loaded_struct_or_union.<locals>.checkapopasizeofuwrong total sizeaalignofuwrong total alignmentlwiaoffsetofaBStructuwrong offset for field %ruwrong size for field %ru%s (we have %d, but C compiler says %d)a_generate_cpy_enum_decla_loading_cpy_enuma_loaded_cpy_enumu_cffi_%s_%sustatic int %s(PyObject *lib)Tu  PyObject *o;Tu  int res;u iaconsta_check_int_constant_valueavarw&u  i = (%s);u  o = %s;uvariable typeu  o = _cffi_from_c_int_const(%s);Tu  if (o == NULL)Tu    return -1;Tu  {Tu    PyObject *o1 = o;u    o = Py_BuildValue("On", o1, (Py_ssize_t)sizeof(%s));Tu    Py_DECREF(o1);Tu    if (o == NULL)Tu      return -1;u  res = PyObject_SetAttrString(lib, "%s", o);Tu  Py_DECREF(o);Tu  if (res < 0)u  return %s;u(lib)u  if ((%s) > 0 || (long)(%s) != %dL) {u  if ((%s) <= 0 || (unsigned long)(%s) != %dUL) {Tu    char buf[64];u    if ((%s) <= 0)u        snprintf(buf, 63, "%%ld", (long)(%s));Tu    elseu        snprintf(buf, 63, "%%lu", (unsigned long)(%s));Tu    PyErr_Format(_cffi_VerificationError,Tu                 "%s%s has the real value %s, not %s",u                 "%s", "%s", buf, "%d");Tw$a___D_u_cffi_e_%s_%saenumeratorsDadelayedFa_enum_funcnameaenumvaluesuenum %s: apartial_resolvedu...Tacheck_valuealength_is_unknownTavartpasize_tooDacategoryavarubad size: %r does not seem to be an array of %saresolve_lengthacastadelattragetteruVCPythonEngine._loaded_cpy_variable.<locals>.getterasetteruVCPythonEngine._loaded_cpy_variable.<locals>.setteraappendaptrTustatic int _cffi_setup_custom(PyObject *lib)a__doc__a__file__a__spec__aoriginahas_locationa__cached__asysTamodelaerrorTaVerificationErroraVCPythonEnginewxa_class_keya_gen_python_modulea__init__uVCPythonEngine.__init__apatch_extension_kwdsuVCPythonEngine.patch_extension_kwdsuVCPythonEngine.find_moduleuVCPythonEngine.collect_typesuVCPythonEngine._prntuVCPythonEngine._gettypenumuVCPythonEngine._do_collect_typeawrite_source_to_fuVCPythonEngine.write_source_to_fTnaload_libraryuVCPythonEngine.load_libraryuVCPythonEngine._get_declarationsuVCPythonEngine._generateuVCPythonEngine._loada_generate_nothinguVCPythonEngine._generate_nothinga_loaded_noopuVCPythonEngine._loaded_noopuVCPythonEngine._convert_funcarg_to_cuVCPythonEngine._extra_local_variablesuVCPythonEngine._convert_funcarg_to_c_ptr_or_arrayuVCPythonEngine._convert_expr_from_ca_generate_cpy_typedef_collecttypea_generate_cpy_typedef_decla_generate_cpy_typedef_methoda_loading_cpy_typedefa_loaded_cpy_typedefa_generate_cpy_function_collecttypeuVCPythonEngine._generate_cpy_function_collecttypea_generate_cpy_function_decluVCPythonEngine._generate_cpy_function_decla_generate_cpy_function_methoduVCPythonEngine._generate_cpy_function_methoda_loading_cpy_functiona_loaded_cpy_functionuVCPythonEngine._loaded_cpy_functiona_generate_cpy_struct_collecttypea_generate_cpy_struct_decluVCPythonEngine._generate_cpy_struct_decla_generate_cpy_struct_methoduVCPythonEngine._generate_cpy_struct_methoda_loading_cpy_structuVCPythonEngine._loading_cpy_structa_loaded_cpy_structuVCPythonEngine._loaded_cpy_structa_generate_cpy_union_collecttypea_generate_cpy_union_decluVCPythonEngine._generate_cpy_union_decla_generate_cpy_union_methoduVCPythonEngine._generate_cpy_union_methoda_loading_cpy_unionuVCPythonEngine._loading_cpy_uniona_loaded_cpy_unionuVCPythonEngine._loaded_cpy_unionuVCPythonEngine._generate_struct_or_union_decluVCPythonEngine._generate_struct_or_union_methoduVCPythonEngine._loading_struct_or_unionuVCPythonEngine._loaded_struct_or_uniona_generate_cpy_anonymous_collecttypea_generate_cpy_anonymous_decluVCPythonEngine._generate_cpy_anonymous_decla_generate_cpy_anonymous_methoduVCPythonEngine._generate_cpy_anonymous_methoda_loading_cpy_anonymousuVCPythonEngine._loading_cpy_anonymousa_loaded_cpy_anonymousuVCPythonEngine._loaded_cpy_anonymousTnaconstntFnuVCPythonEngine._generate_cpy_consta_generate_cpy_constant_collecttypeuVCPythonEngine._generate_cpy_constant_collecttypea_generate_cpy_constant_decluVCPythonEngine._generate_cpy_constant_decla_generate_cpy_constant_methoda_loading_cpy_constanta_loaded_cpy_constantuVCPythonEngine._check_int_constant_valueuVCPythonEngine._enum_funcnameTaenumuVCPythonEngine._generate_cpy_enum_decla_generate_cpy_enum_collecttypea_generate_cpy_enum_methoduVCPythonEngine._loading_cpy_enumuVCPythonEngine._loaded_cpy_enuma_generate_cpy_macro_decluVCPythonEngine._generate_cpy_macro_decla_generate_cpy_macro_collecttypea_generate_cpy_macro_methoda_loading_cpy_macroa_loaded_cpy_macroa_generate_cpy_variable_collecttypeuVCPythonEngine._generate_cpy_variable_collecttypea_generate_cpy_variable_decluVCPythonEngine._generate_cpy_variable_decla_generate_cpy_variable_methoda_loading_cpy_variablea_loaded_cpy_variableuVCPythonEngine._loaded_cpy_variableuVCPythonEngine._generate_setup_customu
#include <Python.h>
#include <stddef.h>

/* this block of #ifs should be kept exactly identical between
   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py
   and cffi/_cffi_include.h */
#if defined(_MSC_VER)
# include <malloc.h>   /* for alloca() */
# if _MSC_VER < 1600   /* MSVC < 2010 */
   typedef __int8 int8_t;
   typedef __int16 int16_t;
   typedef __int32 int32_t;
   typedef __int64 int64_t;
   typedef unsigned __int8 uint8_t;
   typedef unsigned __int16 uint16_t;
   typedef unsigned __int32 uint32_t;
   typedef unsigned __int64 uint64_t;
   typedef __int8 int_least8_t;
   typedef __int16 int_least16_t;
   typedef __int32 int_least32_t;
   typedef __int64 int_least64_t;
   typedef unsigned __int8 uint_least8_t;
   typedef unsigned __int16 uint_least16_t;
   typedef unsigned __int32 uint_least32_t;
   typedef unsigned __int64 uint_least64_t;
   typedef __int8 int_fast8_t;
   typedef __int16 int_fast16_t;
   typedef __int32 int_fast32_t;
   typedef __int64 int_fast64_t;
   typedef unsigned __int8 uint_fast8_t;
   typedef unsigned __int16 uint_fast16_t;
   typedef unsigned __int32 uint_fast32_t;
   typedef unsigned __int64 uint_fast64_t;
   typedef __int64 intmax_t;
   typedef unsigned __int64 uintmax_t;
# else
#  include <stdint.h>
# endif
# if _MSC_VER < 1800   /* MSVC < 2013 */
#  ifndef __cplusplus
    typedef unsigned char _Bool;
#  endif
# endif
#else
# include <stdint.h>
# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)
#  include <alloca.h>
# endif
#endif

#if PY_MAJOR_VERSION < 3
# undef PyCapsule_CheckExact
# undef PyCapsule_GetPointer
# define PyCapsule_CheckExact(capsule) (PyCObject_Check(capsule))
# define PyCapsule_GetPointer(capsule, name) \
    (PyCObject_AsVoidPtr(capsule))
#endif

#if PY_MAJOR_VERSION >= 3
# define PyInt_FromLong PyLong_FromLong
#endif

#define _cffi_from_c_double PyFloat_FromDouble
#define _cffi_from_c_float PyFloat_FromDouble
#define _cffi_from_c_long PyInt_FromLong
#define _cffi_from_c_ulong PyLong_FromUnsignedLong
#define _cffi_from_c_longlong PyLong_FromLongLong
#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong
#define _cffi_from_c__Bool PyBool_FromLong

#define _cffi_to_c_double PyFloat_AsDouble
#define _cffi_to_c_float PyFloat_AsDouble

#define _cffi_from_c_int_const(x)                                        \
    (((x) > 0) ?                                                         \
        ((unsigned long long)(x) <= (unsigned long long)LONG_MAX) ?      \
            PyInt_FromLong((long)(x)) :                                  \
            PyLong_FromUnsignedLongLong((unsigned long long)(x)) :       \
        ((long long)(x) >= (long long)LONG_MIN) ?                        \
            PyInt_FromLong((long)(x)) :                                  \
            PyLong_FromLongLong((long long)(x)))

#define _cffi_from_c_int(x, type)                                        \
    (((type)-1) > 0 ? /* unsigned */                                     \
        (sizeof(type) < sizeof(long) ?                                   \
            PyInt_FromLong((long)x) :                                    \
         sizeof(type) == sizeof(long) ?                                  \
            PyLong_FromUnsignedLong((unsigned long)x) :                  \
            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \
        (sizeof(type) <= sizeof(long) ?                                  \
            PyInt_FromLong((long)x) :                                    \
            PyLong_FromLongLong((long long)x)))

#define _cffi_to_c_int(o, type)                                          \
    ((type)(                                                             \
     sizeof(type) == 1 ? (((type)-1) > 0 ? (type)_cffi_to_c_u8(o)        \
                                         : (type)_cffi_to_c_i8(o)) :     \
     sizeof(type) == 2 ? (((type)-1) > 0 ? (type)_cffi_to_c_u16(o)       \
                                         : (type)_cffi_to_c_i16(o)) :    \
     sizeof(type) == 4 ? (((type)-1) > 0 ? (type)_cffi_to_c_u32(o)       \
                                         : (type)_cffi_to_c_i32(o)) :    \
     sizeof(type) == 8 ? (((type)-1) > 0 ? (type)_cffi_to_c_u64(o)       \
                                         : (type)_cffi_to_c_i64(o)) :    \
     (Py_FatalError("unsupported size for type " #type), (type)0)))

#define _cffi_to_c_i8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[1])
#define _cffi_to_c_u8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[2])
#define _cffi_to_c_i16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[3])
#define _cffi_to_c_u16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[4])
#define _cffi_to_c_i32                                                   \
                 ((int(*)(PyObject *))_cffi_exports[5])
#define _cffi_to_c_u32                                                   \
                 ((unsigned int(*)(PyObject *))_cffi_exports[6])
#define _cffi_to_c_i64                                                   \
                 ((long long(*)(PyObject *))_cffi_exports[7])
#define _cffi_to_c_u64                                                   \
                 ((unsigned long long(*)(PyObject *))_cffi_exports[8])
#define _cffi_to_c_char                                                  \
                 ((int(*)(PyObject *))_cffi_exports[9])
#define _cffi_from_c_pointer                                             \
    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[10])
#define _cffi_to_c_pointer                                               \
    ((char *(*)(PyObject *, CTypeDescrObject *))_cffi_exports[11])
#define _cffi_get_struct_layout                                          \
    ((PyObject *(*)(Py_ssize_t[]))_cffi_exports[12])
#define _cffi_restore_errno                                              \
    ((void(*)(void))_cffi_exports[13])
#define _cffi_save_errno                                                 \
    ((void(*)(void))_cffi_exports[14])
#define _cffi_from_c_char                                                \
    ((PyObject *(*)(char))_cffi_exports[15])
#define _cffi_from_c_deref                                               \
    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[16])
#define _cffi_to_c                                                       \
    ((int(*)(char *, CTypeDescrObject *, PyObject *))_cffi_exports[17])
#define _cffi_from_c_struct                                              \
    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[18])
#define _cffi_to_c_wchar_t                                               \
    ((wchar_t(*)(PyObject *))_cffi_exports[19])
#define _cffi_from_c_wchar_t                                             \
    ((PyObject *(*)(wchar_t))_cffi_exports[20])
#define _cffi_to_c_long_double                                           \
    ((long double(*)(PyObject *))_cffi_exports[21])
#define _cffi_to_c__Bool                                                 \
    ((_Bool(*)(PyObject *))_cffi_exports[22])
#define _cffi_prepare_pointer_call_argument                              \
    ((Py_ssize_t(*)(CTypeDescrObject *, PyObject *, char **))_cffi_exports[23])
#define _cffi_convert_array_from_object                                  \
    ((int(*)(char *, CTypeDescrObject *, PyObject *))_cffi_exports[24])
#define _CFFI_NUM_EXPORTS 25

typedef struct _ctypedescr CTypeDescrObject;

static void *_cffi_exports[_CFFI_NUM_EXPORTS];
static PyObject *_cffi_types, *_cffi_VerificationError;

static int _cffi_setup_custom(PyObject *lib);   /* forward */

static PyObject *_cffi_setup(PyObject *self, PyObject *args)
{
    PyObject *library;
    int was_alive = (_cffi_types != NULL);
    (void)self; /* unused */
    if (!PyArg_ParseTuple(args, "OOO", &_cffi_types, &_cffi_VerificationError,
                                       &library))
        return NULL;
    Py_INCREF(_cffi_types);
    Py_INCREF(_cffi_VerificationError);
    if (_cffi_setup_custom(library) < 0)
        return NULL;
    return PyBool_FromLong(was_alive);
}

union _cffi_union_alignment_u {
    unsigned char m_char;
    unsigned short m_short;
    unsigned int m_int;
    unsigned long m_long;
    unsigned long long m_longlong;
    float m_float;
    double m_double;
    long double m_longdouble;
};

struct _cffi_freeme_s {
    struct _cffi_freeme_s *next;
    union _cffi_union_alignment_u alignment;
};

#ifdef __GNUC__
  __attribute__((unused))
#endif
static int _cffi_convert_array_argument(CTypeDescrObject *ctptr, PyObject *arg,
                                        char **output_data, Py_ssize_t datasize,
                                        struct _cffi_freeme_s **freeme)
{
    char *p;
    if (datasize < 0)
        return -1;

    p = *output_data;
    if (p == NULL) {
        struct _cffi_freeme_s *fp = (struct _cffi_freeme_s *)PyObject_Malloc(
            offsetof(struct _cffi_freeme_s, alignment) + (size_t)datasize);
        if (fp == NULL)
            return -1;
        fp->next = *freeme;
        *freeme = fp;
        p = *output_data = (char *)&fp->alignment;
    }
    memset((void *)p, 0, (size_t)datasize);
    return _cffi_convert_array_from_object(p, ctptr, arg);
}

#ifdef __GNUC__
  __attribute__((unused))
#endif
static void _cffi_free_array_arguments(struct _cffi_freeme_s *freeme)
{
    do {
        void *p = (void *)freeme;
        freeme = freeme->next;
        PyObject_Free(p);
    } while (freeme != NULL);
}

static int _cffi_init(void)
{
    PyObject *module, *c_api_object = NULL;

    module = PyImport_ImportModule("_cffi_backend");
    if (module == NULL)
        goto failure;

    c_api_object = PyObject_GetAttrString(module, "_C_API");
    if (c_api_object == NULL)
        goto failure;
    if (!PyCapsule_CheckExact(c_api_object)) {
        PyErr_SetNone(PyExc_ImportError);
        goto failure;
    }
    memcpy(_cffi_exports, PyCapsule_GetPointer(c_api_object, "cffi"),
           _CFFI_NUM_EXPORTS * sizeof(void *));

    Py_DECREF(module);
    Py_DECREF(c_api_object);
    return 0;

  failure:
    Py_XDECREF(module);
    Py_XDECREF(c_api_object);
    return -1;
}

#define _cffi_type(num) ((CTypeDescrObject *)PyList_GET_ITEM(_cffi_types, num))

/**********/
ucffi\vengine_cpy.pyu<module cffi.vengine_cpy>Ta__class__amoduleaselfTa__class__TaselfaFFILibraryTaFFILibraryTaselfaverifierTaselfanameavalueaerr_prefixaprntTaselfatpavaracontextTaselfatpafromvaratovaraerrcodeaextraargaconverteraerrvalueTaselfatpafromvaratovaraerrcodeTaselfatpanumTaselfaprefixanameTaselfatpalocalvarsafreelinesTaselfastep_nameanameatpakindarealnameamethodweTaselfatpanameTaselfais_intanameatpacategoryavartpadelayedasize_tooacheck_valueaprntafuncnamearealexprTaselfatpanameais_intTaselfatpanameaprefixaenumeratorafuncnameaprntaenumvalueTaselfatpanameatypeTaselfatpanameaprntanumargsaargnameacontextwiatypealocalvarsafreelinesadeclaresult_codearngafreelineTaselfatpanameanumargsamethTaselfatpanameacheck_valueTaselfatpanameatp_ptrTaselfaprntT
aselfatpaprefixanameacheckfuncnamealayoutfuncnameacnameaprntafnameaftypeafbitsizeafqualweTaselfatpaprefixanamealayoutfuncnameTaselfalstTaselfatypeT
aselfamoduleastep_nameakwdsanameatpakindarealnameamethodweTaselfatpanameamoduleakwdsTaselfatpanameamodulealibraryaenumeratoraenumvalueTaselfatpanameamodulealibraryafuncTaselfatpanameamodulealibraryavalueasizeaBItemTypealengtharestaBArrayaptragetterasetterT
aselfatpacheckaffiaBStructalayoutacnamewiafnameaftypeafbitsizeafqualaBFieldTaselfatpanameamoduleTaselfatpanameamoduleaenumvaluesT
aselfatpaprefixanameamodulealayoutfuncnameafunctionalayoutatotalsizeatotalalignmentafieldofsafieldsizeacnameTaselfawhatTarealvalueaexpectedvalueamsgTaselfTaselfamodule_nameapathaso_suffixeswfafilenameadescrTalibraryaptrTaptrTaselfaflagsaprevious_flagsamoduleweaerrorarevmappingalstaFFILibraryalibraryawarningsTaselfakwdsTalibraryavalueaptrTaselfaprntamodnameaconstants.cffi.vengine_gen'averifieraffiaexport_symbolsa_struct_pending_verificationasetdefaultamodule_nameapathajoinabasenamea_fawritew
a_prntacffimod_headerapreamblea_generateTadeclaget_module_nameuvoid %s%s(void) { }
aPyInit_a_backendw.amodulefilenameaload_librarya_loadaloadingaModuleTypela__prepare__aFFILibrarya__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>ucffi.vengine_gena__module__uVGenericEngine.load_library.<locals>.FFILibrarya__qualname__amodulea_cffi_generic_moduleaselfa_cffi_ffia_cffi_dira__dir__uVGenericEngine.load_library.<locals>.FFILibrary.__dir__a__orig_bases__TualoadedTalibrarya_parsera_declarationsaitemsutoo many values to unpack (expected 2)asorta_get_declarationsasplitTw lu_generate_gen_%s_%saVerificationErrorunot implemented in verify(): %ramodelaattach_exception_infou_%s_gen_%saFunctionPtrTypeaellipsisa_generate_gen_constaargsuaStructOrUnionw*aargnamesu%sx%duargument of %saget_c_nameu %sacontextaresultainsertu *ravoid_typeu, avoidu_cffi_f_%saappendaabiw u %s%s(%s)uresult of %sTw{u*r = aVoidTypeureturn u  %s%s(%s);Tw}a_load_constantaPointerTypeaindirectionsaindirect_argsatypafldtypesu'%s' is used as result type, but is opaquea_get_c_namea_get_cached_btypeatpaload_functiona_make_struct_wrapperanewfunctionabase_tpanameu<genexpr>uVGenericEngine._loaded_gen_function.<locals>.<genexpr>anewfuncuVGenericEngine._make_struct_wrapper.<locals>.newfunca_cffi_base_typeanewaBTypeaoldfuncwiabackendanewpla_generate_struct_or_union_declastructa_loading_struct_or_uniona_loaded_struct_or_unionaunionafldnamesu_cffi_check_%s_%su_cffi_layout_%s_%su%s %sustatic void %s(%s *p)Tu  /* only to generate compile-time warnings or errors */Tu  (void)p;aenumfieldsutoo many values to unpack (expected 4)aPrimitiveTypeais_integer_typeaprntu  (void)((p->%s) << 1);u  { %s = &p->%s; (void)tmp; }u*tmpufield %rTaqualsu  /* %s */uintptr_t %s(intptr_t i)u  struct _cffi_aligncheck { char x; %s y; };Tu  static intptr_t nums[] = {u    sizeof(%s),Tu    offsetof(struct _cffi_aligncheck, y),u    offsetof(%s, %s),aArrayTypealengthu    0,  /* %s */u    sizeof(((%s *)0)->%s),Tu    -1Tu  };Tu  return nums[i];Tu  /* the next line is not executed, but compiled */u  %s(0);a_typeof_lockedTuintptr_t(*)(intptr_t)afunctionanumalayoutapartial:lnl:lnlaforce_flattenafixedlayoutacheckuVGenericEngine._loaded_struct_or_union.<locals>.checkapopasizeofuwrong total sizeaalignofuwrong total alignmentlaoffsetofaBStructuwrong offset for field %ruwrong size for field %ru%s (we have %d, but C compiler says %d)aEnumTypea_generate_gen_enum_decla_loading_gen_enuma_loaded_gen_enumu_cffi_%s_%saconstuint %s(char *out_error)a_check_int_constant_valueTu  return 0;uint %s(long long *out_value)u  *out_value = (long long)(%s);u  return (%s) <= 0;avarw&uconst *u %s%s(void)u  return (%s%s);u_cffi_const_%sa_load_known_int_constantTulong long*Tuint(*)(long long*)Tulong longlu(*)(void)u  if ((%s) > 0 || (long)(%s) != %dL) {u  if ((%s) <= 0 || (unsigned long)(%s) != %dUL) {Tu    char buf[64];u    if ((%s) <= 0)u        sprintf(buf, "%%ld", (long)(%s));Tu    elseu        sprintf(buf, "%%lu", (unsigned long)(%s));Tu    sprintf(out_error, "%s has the real value %s, not %s",u            "%s", buf, "%d");:nldnTu    return -1;Tu  }Tuchar[]Tuint(*)(char*)lastringuutf-8areplaceTw$a___D_u_cffi_e_%s_%saenumeratorsa_enum_funcnameaenumvaluesapartial_resolvedu...Tacheck_valuealength_is_unknownu_cffi_sizeof_%susize_t %s(void)u  return sizeof(%s);aitemDacategoryavarTusize_t(*)(void)ubad size: %r does not seem to be an array of %saresolve_lengthacastu_cffi_var_%su*(*)(void)agetteruVGenericEngine._loaded_gen_variable.<locals>.getterasetteruVGenericEngine._loaded_gen_variable.<locals>.setteraptra__doc__a__file__a__spec__aoriginahas_locationa__cached__asysaosatypesTamodelaerrorTaVerificationErrorTOobjectaVGenericEnginewga_class_keya_gen_python_modulea__init__uVGenericEngine.__init__apatch_extension_kwdsuVGenericEngine.patch_extension_kwdsafind_moduleuVGenericEngine.find_moduleacollect_typesuVGenericEngine.collect_typesuVGenericEngine._prntawrite_source_to_fuVGenericEngine.write_source_to_fTluVGenericEngine.load_libraryuVGenericEngine._get_declarationsuVGenericEngine._generateuVGenericEngine._loada_generate_nothinguVGenericEngine._generate_nothinga_loaded_noopuVGenericEngine._loaded_noopa_generate_gen_typedef_decla_loading_gen_typedefa_loaded_gen_typedefa_generate_gen_function_decluVGenericEngine._generate_gen_function_decla_loading_gen_functiona_loaded_gen_functionuVGenericEngine._loaded_gen_functionuVGenericEngine._make_struct_wrappera_generate_gen_struct_decluVGenericEngine._generate_gen_struct_decla_loading_gen_structuVGenericEngine._loading_gen_structa_loaded_gen_structuVGenericEngine._loaded_gen_structa_generate_gen_union_decluVGenericEngine._generate_gen_union_decla_loading_gen_unionuVGenericEngine._loading_gen_uniona_loaded_gen_unionuVGenericEngine._loaded_gen_unionuVGenericEngine._generate_struct_or_union_decluVGenericEngine._loading_struct_or_unionuVGenericEngine._loaded_struct_or_uniona_generate_gen_anonymous_decluVGenericEngine._generate_gen_anonymous_decla_loading_gen_anonymousuVGenericEngine._loading_gen_anonymousa_loaded_gen_anonymousuVGenericEngine._loaded_gen_anonymousTnaconstnuVGenericEngine._generate_gen_consta_generate_gen_constant_decluVGenericEngine._generate_gen_constant_decla_loading_gen_constantTnuVGenericEngine._load_constanta_loaded_gen_constantuVGenericEngine._loaded_gen_constantuVGenericEngine._check_int_constant_valueuVGenericEngine._load_known_int_constantuVGenericEngine._enum_funcnameTaenumuVGenericEngine._generate_gen_enum_decluVGenericEngine._loading_gen_enumuVGenericEngine._loaded_gen_enuma_generate_gen_macro_decluVGenericEngine._generate_gen_macro_decla_loading_gen_macroa_loaded_gen_macrouVGenericEngine._loaded_gen_macroa_generate_gen_variable_decluVGenericEngine._generate_gen_variable_decla_loading_gen_variablea_loaded_gen_variableuVGenericEngine._loaded_gen_variableu
#include <stdio.h>
#include <stddef.h>
#include <stdarg.h>
#include <errno.h>
#include <sys/types.h>   /* XXX for ssize_t on some platforms */

/* this block of #ifs should be kept exactly identical between
   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py
   and cffi/_cffi_include.h */
#if defined(_MSC_VER)
# include <malloc.h>   /* for alloca() */
# if _MSC_VER < 1600   /* MSVC < 2010 */
   typedef __int8 int8_t;
   typedef __int16 int16_t;
   typedef __int32 int32_t;
   typedef __int64 int64_t;
   typedef unsigned __int8 uint8_t;
   typedef unsigned __int16 uint16_t;
   typedef unsigned __int32 uint32_t;
   typedef unsigned __int64 uint64_t;
   typedef __int8 int_least8_t;
   typedef __int16 int_least16_t;
   typedef __int32 int_least32_t;
   typedef __int64 int_least64_t;
   typedef unsigned __int8 uint_least8_t;
   typedef unsigned __int16 uint_least16_t;
   typedef unsigned __int32 uint_least32_t;
   typedef unsigned __int64 uint_least64_t;
   typedef __int8 int_fast8_t;
   typedef __int16 int_fast16_t;
   typedef __int32 int_fast32_t;
   typedef __int64 int_fast64_t;
   typedef unsigned __int8 uint_fast8_t;
   typedef unsigned __int16 uint_fast16_t;
   typedef unsigned __int32 uint_fast32_t;
   typedef unsigned __int64 uint_fast64_t;
   typedef __int64 intmax_t;
   typedef unsigned __int64 uintmax_t;
# else
#  include <stdint.h>
# endif
# if _MSC_VER < 1800   /* MSVC < 2013 */
#  ifndef __cplusplus
    typedef unsigned char _Bool;
#  endif
# endif
#else
# include <stdint.h>
# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)
#  include <alloca.h>
# endif
#endif
ucffi\vengine_gen.pyTa.0atypu<module cffi.vengine_gen>Ta__class__amoduleaselfTa__class__TaselfaFFILibraryTaFFILibraryTaselfaverifierTaselfanameavalueaprntTaselfaprefixanameTaselfastep_nameanameatpakindarealnameamethodweTaselfatpanameT
aselfais_intanameatpacategoryacheck_valueaprntafuncnameaampersandaextraTaselfatpanameais_intTaselfatpanameaprefixaenumeratorafuncnameaprntaenumvalueTaselfatpanameaprntanumargsaargnameswiatypeaindirectionacontextaarglistatpresultawrappernameaabiafuncdeclaresult_codeTaselfatpanameacheck_valueTaselfatpanameaprntafuncnameatp_ptrT
aselfatpaprefixanameacheckfuncnamealayoutfuncnameacnameaprntafnameaftypeafbitsizeafqualweTaselfalstT
aselfamoduleastep_nameakwdsanameatpakindarealnameamethodweTaselfais_intatpanameamoduleacheck_valueafuncnameavalueaBTypeaBFuncafunctionwpanegativeaBLongLongafntypeextraTaselfamoduleafuncnameaBTypeaBFuncafunctionwpaerrorTaselfatpanameamoduleakwdsTaselfatpanameamodulealibraryais_intavalueTaselfatpanameamodulealibraryaenumeratoraenumvalueTaselfatpanameamodulealibraryanewfunctionaindirectionsabase_tpaindirect_argswiatypaindirect_resultaBFuncawrappernameTaselfatpanameamodulealibraryacheck_valueavalueTaselfatpanameamodulealibraryafuncnameaBFuncafunctionasizeaBItemTypealengtharestatp_ptravalueaBArrayaptragetterasetterT
aselfatpacheckaffiaBStructalayoutacnamewiafnameaftypeafbitsizeafqualaBFieldTaselfatpanameamoduleTaselfatpanameamoduleaprefixaenumvaluesafuncnameTaselfatpaprefixanameamodulealayoutfuncnameaBFuncafunctionalayoutanumwxatotalsizeatotalalignmentafieldofsafieldsizeacnameTaselfaoldfuncwiatpabase_tpabackendaBTypeaffianewfuncTaselfawhatTarealvalueaexpectedvalueamsgTaselfTaselfamodule_nameapathaso_suffixesaso_suffixabasenameadirnameafilenameTalibraryaptrTaptrTaselfaflagsabackendafilenameamoduleaFFILibraryalibraryTaargswiabackendaBTypeaoldfuncTaBTypeabackendwiaoldfuncTaargsaresaffiaBTypeaoldfuncTaBTypeaffiaoldfuncTaselfakwdsTalibraryavalueaptrTaselfaprntaprefixamodname.cffi.verifieraimportlibamachineryaEXTENSION_SUFFIXES:nnna_parsera_uses_new_featureaVerificationErrorufeature not supported with ffi.verify(), but only with ffi.set_source(): %saffiapreambleaffiplatformaflattena_locate_engine_classa_vengineapatch_extension_kwdsaflagsamake_relative_toakwdsucan't specify both 'modulename' and 'tag'wu3.10a__version_verifier_modules__aflattened_kwdsa_cdefsourcesuutf-8abinasciiacrc32:lnlgu0xwL:lnlw0u_cffi_%s_%s%s%sa_class_keya_get_so_suffixesla_caller_dir_pycacheatmpdirajoinasourcefilenameamodulefilenameaext_packagea_has_sourcea_has_modulea_locka__enter__a__exit__Tusource code already writtena_write_sourceTnnnuWrite the C source code.  It is produced in 'self.sourcefilename',
        which can be tweaked beforehand.Tumodule already compileda_compile_moduleuWrite the C source code (if not done already) and compile it.
        This produces a dynamic link library in 'self.modulefilename'.a_locate_modulea_load_libraryuGet a C module from this Verifier instance.
        Returns an instance of a FFILibrary class that behaves like the
        objects returned by ffi.dlopen(), but that delegates all
        operations to the C module.  If necessary, the C code is written
        and compiled first.
        asplitTw.laendswithTa_dagettotalrefcount:nqnabasenamea_hack_at_distutilsamaybe_relative_pathaget_module_nameaget_extensiona_gen_python_moduleacopyaLIST_OF_FILE_NAMESTOlistOtupleukeyword '%s' should be a list or tupleadirnamea__doc__a__path__afind_moduleacollect_typesa_fawrite_source_to_fa_write_source_toaStringIOagetvaluewrareadaneeds_writtena_ensure_dirwwawriteacompileasamefileashutilamoveaload_librarya_FORCE_GENERIC_ENGINEa_cffi_backendw?a_backenduTavengine_genlavengine_genaVGenericEngineTavengine_cpyavengine_cpyaVCPythonEnginea_TMPDIRaenvironagetTaCFFI_TMPDIRa_getframeTlaf_codeaco_filenamea__pycache__uSet the temporary directory to use instead of __pycache__.u.calowerastartswithTa_cffi_asuffixTu.caunlinkabuildadiraclean_diruClean up the temporary directory by removing all files in it
    called `_cffi_*.{c,so}` as well as the `build` subdirectory.a_extension_suffixesu.pydamakedirsa__file__a__spec__aoriginahas_locationa__cached__asysaosaioTa__version_verifier_modules__TaffiplatformaerrorTaVerificationErroruimportlib.machineryaNativeIOTOobjecta__prepare__aVerifiera__getitem__u%s.__prepare__() must return a mapping, not %sa__name__u<metaclass>ucffi.verifiera__module__a__qualname__TnnnuFu.cnna__init__uVerifier.__init__Tnawrite_sourceuVerifier.write_sourceacompile_moduleuVerifier.compile_moduleuVerifier.load_libraryuVerifier.get_module_nameuVerifier.get_extensionagenerates_python_moduleuVerifier.generates_python_moduleuVerifier.make_relative_touVerifier._locate_moduleuVerifier._write_source_touVerifier._write_sourceuVerifier._compile_moduleuVerifier._load_librarya__orig_bases__aset_tmpdirTnFacleanup_tmpdirucffi\verifier.pyu<module cffi.verifier>Ta__class__Taselfaffiapreambleatmpdiramodulenameaext_packageatagaforce_generic_engineasource_extensionaflagsarelative_toakwdsaflattened_kwdsavengine_classakeyak1ak2asuffixTaresultafilenameTaselfatmpdiraoutputfilenameasameTafilenameadirnameTasuffixesTaselfTaffiaforce_generic_enginea_cffi_backendavengine_genavengine_cpyTaselfapkgapathafilenameTaselfafilewfasource_dataafpaneeds_writtenTaselfafileTatmpdirakeep_soafilelistasuffixafnaclean_diradirTaselfasourcenameamodnameTaselfabasenameTaselfakwdsarelative_toadirnameakeyalstTadirname.
